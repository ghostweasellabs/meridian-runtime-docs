{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#meridian-runtime","title":"Meridian Runtime","text":"<p>Minimal, reusable graph runtime for Python. Build real-time, observable dataflows from small, single\u2011responsibility nodes connected by typed, bounded edges.</p> <p>Meridian gives you:</p> <ul> <li>A tiny, composable runtime (nodes, edges, subgraphs, scheduler)</li> <li>Backpressure by default with configurable overflow policies</li> <li>Control\u2011plane priorities (e.g., kill switch) for predictable behavior under load</li> <li>First\u2011class observability (structured logs, metrics, trace hooks)</li> <li>A clean, SRP/DRY\u2011friendly codebase</li> </ul> <p>Get the source: GhostWeaselLabs/meridian-runtime</p> <p>For an overview of how this documentation is organized, see About these docs</p>"},{"location":"#what-can-you-build","title":"What can you build?","text":"<ul> <li>Market/stream processing with strict backpressure</li> <li>Event enrichment and filtering pipelines</li> <li>Streaming ETL/log processing</li> <li>Control planes with prioritized signals</li> <li>Any real\u2011time graph that needs predictable flow control and visibility</li> </ul>"},{"location":"#quick-start","title":"Quick start","text":""},{"location":"#prereqs","title":"Prereqs","text":"<ul> <li>Python 3.11+</li> <li><code>uv</code> (astral-sh/uv)</li> </ul>"},{"location":"#initialize-environment","title":"Initialize environment","text":"Bash<pre><code>uv lock\nuv sync\n</code></pre>"},{"location":"#dev-loop","title":"Dev loop","text":"Bash<pre><code># Lint\nuv run ruff check .\n\n# Format check (if black is configured locally)\nuv run black --check .\n\n# Type-check\nuv run mypy src\n\n# Tests with coverage\nuv run pytest --cov=src --cov-fail-under=80\n</code></pre>"},{"location":"#run-the-examples","title":"Run the examples","text":"Bash<pre><code>git clone https://github.com/GhostWeaselLabs/meridian-runtime-examples.git\ncd meridian-runtime-examples\n\n# Hello graph (minimal)\nuv run python examples/hello_graph/main.py\n\n# Sentiment pipeline (control-plane preemption, backpressure)\nuv run python examples/sentiment/main.py --human --timeout-s 6.0\n\n# Streaming coalesce (burst smoothing with deterministic merges)\nuv run python examples/streaming_coalesce/main.py --human --timeout-s 5.0\n</code></pre>"},{"location":"#core-ideas-in-30-seconds","title":"Core ideas in 30 seconds","text":"<ul> <li>Node: single\u2011responsibility unit with typed inputs/outputs</li> <li>Edge: bounded queue with overflow policy (<code>block</code>, <code>drop</code>, <code>latest</code>, <code>coalesce</code>)</li> <li>Subgraph: reusable composition exposing its own inputs/outputs</li> <li>Scheduler: fairness + priorities; drives ticks and graceful shutdown</li> <li>Observability: logs, metrics, trace hooks embedded in the runtime</li> </ul> <p>These primitives keep graphs explicit, testable, and easy to evolve.</p>"},{"location":"#next-steps","title":"Next steps","text":"<p>Read the guides:</p> <ul> <li>Quickstart</li> <li>API Reference</li> <li>Patterns</li> <li>Observability</li> <li>Troubleshooting</li> </ul> <p>Contribute and plan:</p> <ul> <li>Contributing Guide</li> <li>Release Process</li> <li>Governance &amp; Roadmaps</li> </ul>"},{"location":"#example-layout","title":"Example layout","text":"Text Only<pre><code>src/meridian/\n  core/           # nodes, edges, subgraphs, scheduler\n  observability/  # logs, metrics, tracing hooks\n  utils/          # shared utilities\n examples/  (in `meridian-runtime-examples`)\n   hello_graph/          # minimal runnable example\n   sentiment/            # control-plane overrides and priorities\n   streaming_coalesce/   # coalescing policy under burst pressure\ntests/\n  unit/           # unit tests\n  integration/    # end-to-end graph tests\n</code></pre>"},{"location":"#design-principles","title":"Design principles","text":"<ul> <li>Small, composable files (~200 lines target)</li> <li>Single responsibility, explicit contracts</li> <li>Backpressure first; overflow policies are explicit</li> <li>Prioritize control\u2011plane messages</li> <li>Observability is not an afterthought</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>Repo: GhostWeaselLabs/meridian-runtime</li> <li>Issues: https://github.com/GhostWeaselLabs/meridian-runtime/issues</li> <li>Discussions: https://github.com/GhostWeaselLabs/meridian-runtime/discussions</li> </ul>"},{"location":"404/","title":"404 - Page Not Found","text":"<p>Oops! The page you're looking for seems to have wandered off into the dataflow void.</p> <ul> <li> <p> Home</p> <p>Return to the main page</p> </li> <li> <p> Getting Started</p> <p>Set up your environment</p> </li> <li> <p> Examples</p> <p>Explore working demos</p> </li> <li> <p> API Reference</p> <p>Browse documentation</p> </li> </ul> <p>Search Instead?</p> <p>Use the search bar above (Ctrl+K) to find what you're looking for, or browse the navigation menu.</p> <p>Found a broken link? Please report it on GitHub so we can fix it.</p>"},{"location":"tags/","title":"Tags","text":"<p>Browse documentation by topic and category.</p> <p>[TAGS]</p>"},{"location":"concepts/","title":"Concepts","text":"<p>Purpose This section explains the \"what\" and \"why\" of the Meridian Runtime. It provides context and conceptual foundations so you can understand the architecture, core ideas, and terminology before diving into guides or API reference.</p> <p>Who this is for - New contributors who want to understand the system at a high level - Users evaluating whether Meridian fits their use case - Maintainers writing or reviewing design decisions</p> <p>How to use this section - Start with About to get a concise overview - Read Patterns to learn how we expect you to compose systems - Review Observability to see how introspection is built in - Use the Glossary to align on terminology</p> <p>Contents - About: High-level overview and goals of the project - Patterns: Recommended architectural patterns and anti-patterns - Observability: Logging, metrics, traces, and how to use them effectively - Glossary: Shared vocabulary for concepts across the docs</p> <p>Conventions - Files and directories use lowercase-kebab-case - Headings use sentence case; proper nouns retain their canonical capitalization - Each page starts with a short summary of its scope</p> <p>Quick links - About: ./about.md - Patterns: ./patterns.md - Observability: ./observability.md - Glossary: ./glossary.md</p> <p>Last updated - Owner: Docs team - Status: Stable, expanded as new concepts are introduced </p>"},{"location":"concepts/about/","title":"About This Documentation","text":"<p>This documentation provides comprehensive information about Meridian Runtime, organized to help you get started quickly and dive deeper as needed.</p>","tags":["about","documentation","navigation"]},{"location":"concepts/about/#quick-links","title":"Quick links","text":"<ul> <li>Repo: GhostWeaselLabs/meridian-runtime</li> <li>Documentation: https://ghostweasellabs.github.io/meridian-runtime/</li> <li>MkDocs config: mkdocs.yml</li> </ul>","tags":["about","documentation","navigation"]},{"location":"concepts/about/#structure","title":"Structure","text":"<ul> <li>index.md \u2014 Docs homepage (user-facing landing page)</li> <li>getting-started/<ul> <li>quickstart.md \u2014 60-second setup and first run</li> <li>guide.md \u2014 Full setup, verification, development loop, and Hello Graph</li> </ul> </li> <li>examples/<ul> <li>index.md \u2014 Examples overview</li> <li>sentiment.md \u2014 Control-plane preemption, priorities, mixed capacities</li> <li>streaming-coalesce.md \u2014 Deterministic coalescing under pressure</li> </ul> </li> <li>concepts/<ul> <li>about.md \u2014 This page</li> <li>patterns.md \u2014 Common design patterns and guidance</li> <li>observability.md \u2014 Logs, metrics, tracing</li> </ul> </li> <li>reference/<ul> <li>api.md \u2014 API reference and primitives</li> </ul> </li> <li>contributing/<ul> <li>guide.md \u2014 Contribution guidelines and release process</li> <li>RELEASING.md \u2014 Release process</li> <li>docs-conventions.md \u2014 Docs style and conventions</li> </ul> </li> <li>support/<ul> <li>troubleshooting.md \u2014 Common issues and fixes</li> <li>how-to-report-issues.md \u2014 Reporting guidance</li> <li>troubleshooting-legacy.md \u2014 Legacy notes</li> </ul> </li> <li>roadmap/ \u2014 Governance and roadmap documents</li> </ul>","tags":["about","documentation","navigation"]},{"location":"concepts/about/#how-the-site-is-built-and-deployed","title":"How the site is built and deployed","text":"<ul> <li>The site is built by a GitHub Actions workflow on every push to main.</li> <li>Dependencies are pinned and installs are cached for faster, deterministic builds.</li> <li>Pages is configured to deploy from GitHub Actions (not from a branch).</li> </ul>","tags":["about","documentation","navigation"]},{"location":"concepts/about/#contributing-to-docs","title":"Contributing to docs","text":"<ol> <li>Make changes to files under <code>docs/</code> or update the nav in <code>mkdocs.yml</code>.</li> <li>Run locally with:<ul> <li><code>uv lock &amp;&amp; uv sync</code></li> <li><code>uv run mkdocs serve</code></li> </ul> </li> <li>Verify links and nav. Keep pages concise and task\u2011focused.</li> <li>Open a PR. On merge to <code>main</code>, the site auto\u2011deploys.</li> </ol>","tags":["about","documentation","navigation"]},{"location":"concepts/about/#authoring-guidelines","title":"Authoring guidelines","text":"<ul> <li>Keep pages scoped: one concept or task per page.</li> <li>Prefer short intros, then examples and practical steps.</li> <li>Cross\u2011link related topics (Quickstart, Guide, Examples, API, Patterns).</li> <li>Use consistent terminology: node, edge, subgraph, scheduler, message.</li> <li>Include minimal runnable snippets where helpful.</li> </ul>","tags":["about","documentation","navigation"]},{"location":"concepts/about/#adding-new-pages","title":"Adding new pages","text":"<ol> <li>Create a new <code>.md</code> under <code>docs/</code>.</li> <li>Add it to the nav in <code>mkdocs.yml</code> under an appropriate section.</li> <li>If the page is user\u2011facing, link it from <code>index.md</code> or a relevant section.</li> <li>For examples, add a page under <code>docs/examples/</code> and link it from <code>docs/examples/index.md</code>.</li> </ol>","tags":["about","documentation","navigation"]},{"location":"concepts/about/#issues-and-support","title":"Issues and support","text":"<ul> <li>Open issues at: https://github.com/GhostWeaselLabs/meridian-runtime/issues</li> <li>See support guidance in: report an issue</li> </ul> <p>Thank you for helping improve the Meridian Runtime docs! </p>","tags":["about","documentation","navigation"]},{"location":"concepts/architecture/","title":"Architecture","text":"","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#summary","title":"Summary","text":"<p>This page provides a high-level view of Meridian Runtime's architecture: the core components, how they interact, and the principles that guide the design. It's intended to help you understand the big picture before diving into guides or the API reference.</p>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#audience","title":"Audience","text":"<ul> <li>Engineers evaluating whether Meridian fits their use case</li> <li>Contributors who need a mental model of the runtime</li> <li>Operators who want to understand runtime behavior and observability surfaces</li> </ul>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#design-principles","title":"Design principles","text":"<p>Core Philosophy</p> <p>Meridian Runtime prioritizes predictability and observability over raw performance. Every design decision favors explicit behavior over implicit optimization.</p> <ul> <li>Single responsibility<ul> <li>Each component (node, edge, scheduler) has a clear, narrow purpose.</li> </ul> </li> <li>Backpressure by default<ul> <li>Bounded queues and explicit overflow policies keep systems stable.</li> </ul> </li> <li>Predictable execution<ul> <li>Priority-aware scheduling and controlled concurrency reduce tail risk.</li> </ul> </li> <li>First-class observability<ul> <li>Structured logs, metrics, and hooks enable debugging and tuning.</li> </ul> </li> <li>Composability<ul> <li>Small nodes compose into subgraphs that compose into applications.</li> </ul> </li> <li>Minimal surface<ul> <li>Keep dependencies light and interfaces small; scale complexity with need.</li> </ul> </li> </ul>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#conceptual-overview","title":"Conceptual overview","text":"<p>At its core, Meridian Runtime executes a directed graph of nodes connected by typed, bounded edges. A scheduler coordinates execution, honoring priorities and backpressure signals. Observability surfaces (logs, metrics, tracing hooks) instrument every stage for visibility.</p> <pre><code>%%{init: {\n  \"theme\": \"base\",\n  \"themeVariables\": {\n    \"primaryColor\": \"#111827\",\n    \"primaryTextColor\": \"#ffffff\",\n    \"primaryBorderColor\": \"#111827\",\n    \"lineColor\": \"#9ca3af\",\n    \"secondaryColor\": \"#1f2937\",\n    \"tertiaryColor\": \"#111827\",\n    \"fontFamily\": \"IBM Plex Sans, Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif\"\n  }\n}}%%\nsequenceDiagram\n    autonumber\n    participant P as Producer\n    participant E1 as Edge (cap N \u00b7 policy)\n    participant N1 as Node (Transform)\n    participant E2 as Edge (cap N \u00b7 policy)\n    participant N2 as Node (Filter)\n    participant E3 as Edge (cap N \u00b7 policy)\n    participant C as Consumer\n\n    Note over P,E3: Backpressure policies: Block \u00b7 Drop \u00b7 Latest \u00b7 Coalesce\n\n    P-&gt;&gt;E1: enqueue(data)\n    alt E1 at capacity\n        E1--&gt;&gt;P: BLOCKED / DROPPED / REPLACED / COALESCED\n    else Space available\n        Note over E1: validate via PortSpec\n        E1-&gt;&gt;N1: dequeue()\n        N1-&gt;&gt;N1: process(data)\n        N1--&gt;&gt;E2: enqueue(out1)\n        alt E2 at capacity\n            E2--&gt;&gt;N1: BLOCKED / DROPPED / REPLACED / COALESCED\n        else\n            E2-&gt;&gt;N2: dequeue()\n            N2-&gt;&gt;N2: process(out1)\n            N2--&gt;&gt;E3: enqueue(out2)\n            alt E3 at capacity\n                E3--&gt;&gt;N2: BLOCKED / DROPPED / REPLACED / COALESCED\n            else\n                E3-&gt;&gt;C: dequeue()\n            end\n        end\n    end\n\n    Note over N1,N2: Metrics: node_messages_total\n    Note over E1,E3: Metrics: edge_queue_depth \u00b7 edge_dropped_total \u00b7 edge_blocked_time_seconds</code></pre> <p>Key properties:</p> <ul> <li>Edges are bounded queues; enqueue behavior is governed by policy.</li> <li>Nodes implement small, testable units of work.</li> <li>The scheduler orchestrates fairness, priority, and throughput.</li> <li>Observability is integrated rather than bolted on.</li> </ul>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#core-components","title":"Core components","text":"","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#node","title":"Node","text":"<p>See Also</p> <p>For detailed Node API, see API: Node.</p> <ul> <li>Definition     An active unit that consumes messages, performs work, and emits messages.</li> <li> <p>Responsibilities</p> <ul> <li>Validate and transform inputs</li> <li>Handle errors locally when possible</li> <li>Emit outputs, metrics, and structured logs</li> <li> <p>Characteristics</p> </li> <li> <p>Single responsibility, predictable side effects</p> </li> <li>Composable into subgraphs</li> <li>May be stateful (with careful lifecycle) or stateless</li> </ul> </li> </ul>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#edge","title":"Edge","text":"<p>Critical Design Choice</p> <p>All edges are bounded by default. Unbounded queues are not supported as they can lead to memory exhaustion and unpredictable behavior.</p> <p>See Also</p> <p>For detailed Edge API, see API: Edge.</p> <ul> <li>Definition     A typed, bounded queue connecting two nodes.</li> <li> <p>Responsibilities</p> <ul> <li>Enforce type/schema for messages</li> <li>Provide flow control via bounds</li> <li>Apply overflow policy on backpressure</li> <li> <p>Overflow policies</p> </li> <li> <p>block: backpressure the producer until space is available</p> </li> <li>drop-newest / drop-oldest: shed load explicitly</li> <li>coalesce: merge messages (e.g., keep latest state)</li> <li>timeout: fail fast and surface diagnostics</li> </ul> </li> </ul> <p>See Also</p> <p>For detailed overflow policy implementation, see API: Backpressure and overflow.</p>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#scheduler","title":"Scheduler","text":"<p>Cooperative Scheduling</p> <p>The scheduler uses cooperative multitasking rather than preemptive scheduling. Nodes must yield control to allow other work to proceed.</p> <ul> <li>Definition     The runtime's orchestrator for executing work while respecting priorities and backpressure.</li> <li> <p>Responsibilities</p> <ul> <li>Dispatch ready work units</li> <li>Honor priority (e.g., control-plane &gt; data-plane)</li> <li>Manage concurrency and fairness</li> <li>Facilitate graceful shutdown and draining</li> <li> <p>Behaviors</p> </li> <li> <p>Priority-aware queues</p> </li> <li>Cooperative backpressure handling</li> <li>Health signals and readiness/liveness reporting</li> </ul> </li> </ul> <p>See Also</p> <p>For scheduler configuration options, see API: Scheduler.</p>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#observability","title":"Observability","text":"<p>See Also</p> <p>For detailed observability configuration, see API: Observability.</p> <ul> <li>Definition     Integrated logging, metrics, and optional tracing hooks.</li> <li> <p>Responsibilities</p> <ul> <li>Emit structured logs with correlated context (e.g., trace IDs)</li> <li>Provide metrics (counters, gauges, histograms) for nodes and edges</li> <li>Expose health and performance endpoints</li> <li> <p>Examples</p> </li> <li> <p>node.processed.count</p> </li> <li>edge.enqueue.latency</li> <li>scheduler.run.queue_depth</li> <li>runtime.health.status</li> </ul> </li> </ul>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#message-flow","title":"Message flow","text":"<p>See Also</p> <p>For a visual representation, see Message flow diagram.</p> <ol> <li> <p>Ingress    Messages enter via sources or upstream nodes. Validation and typing occur at boundaries.</p> </li> <li> <p>Queuing    Edges buffer messages with explicit capacity. When full, overflow policy applies.</p> </li> <li> <p>Scheduling    The scheduler selects the next work item considering priority and readiness.</p> </li> <li> <p>Processing    The node executes work, emitting logs and metrics. Failures are handled locally if possible.</p> </li> <li> <p>Egress    Outputs are enqueued to downstream edges; observability data is emitted.</p> </li> <li> <p>Backpressure    If any downstream edge is full, enqueue follows policy, potentially signaling upstream slowdowns.</p> </li> </ol>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#lifecycle-and-operations","title":"Lifecycle and operations","text":"<ul> <li>Initialization<ul> <li>Construct graph (nodes, edges, subgraphs)</li> <li>Validate topology and types</li> <li>Initialize nodes and scheduler, register observability</li> </ul> </li> <li>Startup<ul> <li>Scheduler begins dispatching</li> <li>Health transitions to \"ready\" when nodes are initialized and draining is zero</li> </ul> </li> <li>Steady state<ul> <li>Work flows with continuous metrics/logs</li> <li>Backpressure and priorities balance throughput and latency</li> </ul> </li> <li>Shutdown (graceful)<ul> <li>Stop accepting new work</li> <li>Drain in-flight edges</li> <li>Tear down nodes and release resources</li> </ul> </li> <li>Failure handling<ul> <li>Localized retries where idempotent</li> <li>Dead-letter or quarantine for unrecoverable messages</li> <li>Emitted diagnostics for root cause analysis</li> </ul> </li> </ul>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#priorities-and-control-plane","title":"Priorities and control plane","text":"<p>Priority Preemption</p> <p>Control-plane messages can preempt data-plane work to ensure critical operations (like shutdown) are never blocked by application load.</p> <ul> <li>Priority classes<ul> <li>Control: shutdown, kill switch, health probes (highest)</li> <li>Operational: reconfiguration, housekeeping</li> <li>Data: application payloads (default)</li> </ul> </li> <li>Rationale     Ensures that critical control actions are not starved under load spikes.</li> <li>Implementation notes     Separate queues or weighted scheduling; preemption only where safe.</li> </ul> <p>See Also</p> <p>For priority implementation details, see API: Message.</p>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#composition-and-subgraphs","title":"Composition and subgraphs","text":"<p>See Also</p> <p>For detailed Subgraph API, see API: Subgraph.</p> <ul> <li>Subgraphs encapsulate a set of nodes/edges with defined ingress/egress.</li> <li> <p>Benefits</p> <ul> <li>Reusability across applications</li> <li>Local reasoning about performance and failure modes</li> <li>Easier testing and rollout</li> <li> <p>Constraints</p> </li> <li> <p>Maintain clear contracts (types, rate expectations)</p> </li> <li>Avoid leaky abstractions with explicit boundaries</li> </ul> </li> </ul>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#performance-model","title":"Performance model","text":"<ul> <li>Throughput<ul> <li>Dominated by per-node processing cost and edge contention</li> </ul> </li> <li>Latency<ul> <li>Includes queuing delay + processing + scheduling overhead</li> </ul> </li> <li>Capacity planning<ul> <li>Key tunables: edge bounds, concurrency, batch sizes, CPU allocation</li> </ul> </li> <li>Trade-offs<ul> <li>Larger queues smooth bursts but increase tail latency</li> <li>Coalescing reduces work at the cost of intermediate states</li> </ul> </li> </ul>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#reliability-and-fault-tolerance","title":"Reliability and fault tolerance","text":"<ul> <li>Strategies<ul> <li>Idempotent processing for safe retries</li> <li>Timeouts and circuit breakers at boundaries</li> <li>Dead-letter queues for pathological inputs</li> <li>Graceful shutdown with draining</li> </ul> </li> <li>Recovery<ul> <li>Restart nodes with preserved state where appropriate</li> <li>Replay from source when supported</li> </ul> </li> </ul>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#security-considerations","title":"Security considerations","text":"<ul> <li>Inputs<ul> <li>Validate and sanitize at ingress; enforce types on edges</li> </ul> </li> <li>Secrets<ul> <li>Never log secrets; prefer metadata over payloads in logs</li> </ul> </li> <li>Isolation<ul> <li>Consider process or thread boundaries for untrusted components</li> </ul> </li> <li>Telemetry<ul> <li>Ensure observability endpoints are access-controlled where needed</li> </ul> </li> </ul>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#extensibility","title":"Extensibility","text":"<ul> <li>Plug points<ul> <li>Node interfaces</li> <li>Edge overflow strategies</li> <li>Scheduler policies (priority, fairness, backoff)</li> <li>Observability sinks (metrics/logs exporters)</li> </ul> </li> <li>Guidelines<ul> <li>Keep extensions narrow and composable</li> <li>Preserve backpressure semantics</li> <li>Document performance and compatibility characteristics</li> </ul> </li> </ul>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#diagrams","title":"Diagrams","text":"","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#message-flow-simplified","title":"Message flow (simplified)","text":"<pre><code>%%{init: {\n  \"theme\": \"base\",\n  \"themeVariables\": {\n    \"primaryColor\": \"#111827\",\n    \"primaryTextColor\": \"#ffffff\",\n    \"primaryBorderColor\": \"#111827\",\n    \"lineColor\": \"#9ca3af\",\n    \"secondaryColor\": \"#1f2937\",\n    \"tertiaryColor\": \"#111827\",\n    \"fontFamily\": \"IBM Plex Sans, Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif\"\n  }\n}}%%\nsequenceDiagram\n    autonumber\n    participant S as Source\n    participant E as Edge (cap N \u00b7 policy)\n    participant N as Node\n    participant D as Downstream\n\n    S-&gt;&gt;E: enqueue(msg)\n    alt Edge at capacity\n        E--&gt;&gt;S: overflow outcome&lt;br/&gt;BLOCKED / DROPPED / REPLACED / COALESCED\n    else Space available\n        Note over E: type/schema validated (PortSpec)\n        E-&gt;&gt;N: dequeue()\n        N-&gt;&gt;N: process(msg)\n        N--&gt;&gt;E: enqueue(output)\n        E-&gt;&gt;D: dequeue()\n    end</code></pre>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#priority-aware-dispatch","title":"Priority-aware dispatch","text":"<pre><code>%%{init: {\n  \"theme\": \"base\",\n  \"themeVariables\": {\n    \"primaryColor\": \"#111827\",\n    \"primaryTextColor\": \"#ffffff\",\n    \"primaryBorderColor\": \"#111827\",\n    \"lineColor\": \"#9ca3af\",\n    \"secondaryColor\": \"#1f2937\",\n    \"tertiaryColor\": \"#111827\",\n    \"fontFamily\": \"IBM Plex Sans, Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif\"\n  }\n}}%%\nsequenceDiagram\n    autonumber\n    participant CP as Control queue\n    participant OP as Ops queue\n    participant DP as Data queue\n    participant S as Scheduler\n    participant W1 as Worker 1\n    participant W2 as Worker 2\n\n    CP-&gt;&gt;S: schedule(control)\n    OP-&gt;&gt;S: schedule(ops)\n    DP-&gt;&gt;S: schedule(data)\n\n    Note over S: Priority weights: control &gt; ops &gt; data\n    S-&gt;&gt;W1: dispatch(next)\n    S-&gt;&gt;W2: dispatch(next)\n\n    Note over CP,S: Control may preempt when present</code></pre>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#related-docs","title":"Related docs","text":"<ul> <li>About - Documentation structure and navigation</li> <li>Patterns - Common architectural patterns and examples</li> <li>Observability - Logging, metrics, and tracing</li> <li>Glossary - Shared vocabulary and terminology</li> <li>API Reference - Complete API documentation</li> <li>Local development - Development setup and workflow</li> </ul> <p>Next Steps</p> <p>After reviewing the architecture, explore Patterns for practical implementation guidance or dive into the API Reference for component documentation.</p>","tags":["architecture","design","components","runtime"]},{"location":"concepts/architecture/#appendix-operational-checks","title":"Appendix: Operational checks","text":"<ul> <li>Health<ul> <li>Liveness/readiness endpoints reflect node/scheduler state</li> </ul> </li> <li>Metrics SLOs<ul> <li>Queue depth &lt; bound threshold under nominal load</li> <li>Error rate within acceptable bounds</li> <li>P(95) latency within target</li> </ul> </li> <li>Draining<ul> <li>Shutdown completes within a defined grace period</li> </ul> </li> <li>Backpressure<ul> <li>No unbounded growth; overflow actions visible in metrics/logs </li> </ul> </li> </ul>","tags":["architecture","design","components","runtime"]},{"location":"concepts/glossary/","title":"Glossary","text":"<p>A comprehensive vocabulary for Meridian Runtime concepts, patterns, and terminology. This glossary provides clear definitions and links to relevant documentation sections for deeper understanding.</p> <p>See Also</p> <ul> <li>API Reference for detailed API documentation</li> <li>Patterns for common usage patterns</li> <li>Architecture for system design concepts</li> <li>Observability for monitoring and debugging</li> </ul>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#a","title":"A","text":"<p>Agent A long-lived process or service that hosts the runtime and executes graphs. Often responsible for lifecycle, configuration, and observability endpoints. See Architecture: Core Components.</p> <p>API (Application Programming Interface) The public surface exposed by Meridian (Python types, functions, and CLI) for building, running, and observing graphs. See API Reference for complete documentation.</p> <p>Admonition A callout box used in documentation to highlight important information, warnings, or tips. Uses <code>!!!</code> syntax in Markdown.</p> <p>Annotation A numbered reference in code examples that links to explanatory text. See Patterns for examples with code annotations.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#b","title":"B","text":"<p>Backpressure A flow-control mechanism that slows or stops producers when consumers can't keep up. Implemented via bounded queues and enqueue policies. See Patterns: Backpressure and Overflow.</p> <p>Backpressure Strategy High-level approach to handling overflow conditions. Options include <code>DROP</code> (prefer dropping items) and <code>BLOCK</code> (prefer blocking producers). See API: Policies.</p> <p>Bounded Edge/Queue A queue with a fixed capacity connecting nodes. When full, enqueue behavior follows a configured policy (e.g., block, drop, coalesce). See Architecture: Edge.</p> <p>Batch Processing Processing multiple messages together for efficiency. See Patterns: Coalesce Policy.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#c","title":"C","text":"<p>Control Message A message used for runtime coordination (e.g., shutdown, health check) that may be scheduled with higher priority than data messages. See Patterns: Control-plane Priority.</p> <p>Coalescing A drop strategy that merges or replaces older queued items with newer ones to bound memory while retaining the most relevant state. See API: Coalesce Policy.</p> <p>Composable Node A node that is designed to be reused and nested into subgraphs without side effects beyond its declared inputs/outputs. See Patterns: Subgraph Composition.</p> <p>Context Additional information attached to logs, metrics, or traces to provide operational context. See Observability: Contextual Logging.</p> <p>Counter A monotonically increasing metric type for counting events. See Observability: Metric Types.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#d","title":"D","text":"<p>Dataflow An application structure where data moves through a directed graph of nodes via typed edges. Each node transforms or routes the data. See Architecture: Message Flow.</p> <p>Dead Letter A message that cannot be processed (e.g., due to validation errors) and is routed to a diagnostic or quarantine path. See Patterns: Error Handling.</p> <p>Drain A shutdown phase where nodes finish processing in-flight messages and flush outputs before stopping. See API: Scheduler Examples.</p> <p>Drop Policy An overflow policy that discards new messages when the queue is full. See Patterns: Drop Policy.</p> <p>Distributed Tracing A technique for tracking request flow across multiple nodes and services. See Observability: Distributed Tracing.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#e","title":"E","text":"<p>Edge A directed, typed connection between nodes with a bounded queue. Responsible for backpressure and overflow policy. See Architecture: Edge.</p> <p>Enqueue Policy Behavior when an edge's bounded queue is full. Examples: block (apply backpressure), drop-oldest, drop-newest, coalesce, timeout. See API: Policy Semantics.</p> <p>Event A unit of data processed by nodes. May be generic (payload + metadata) or strongly typed. See API: Message.</p> <p>Error Message A message type used for structured error reporting. See Patterns: Error Handling.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#f","title":"F","text":"<p>Flow Control Mechanisms that regulate throughput and stability (backpressure, priorities, rate limits). See Patterns: Backpressure and Overflow.</p> <p>Fairness Scheduling property ensuring all nodes get execution time proportional to their priority. See API: Scheduler Examples.</p> <p>Factory Function A function that creates and returns instances of classes or objects. See Patterns: Policy Factories.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#g","title":"G","text":"<p>Graph A directed acyclic (or cyclic with care) network of nodes and edges representing your pipeline. Can be nested through subgraphs. See Architecture: Composition and Subgraphs.</p> <p>Gauge A metric type representing the current value of a measurement. See Observability: Metric Types.</p> <p>Graceful Shutdown A termination mode where the runtime stops accepting new work, drains in-flight messages, and cleans up resources. See API: Scheduler Examples.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#h","title":"H","text":"<p>Health Check A lightweight status probe to determine liveness/readiness of the runtime or nodes. See Patterns: Control Messages.</p> <p>Histogram A metric type for recording observations into buckets, commonly used for latency distributions. See Observability: Metric Types.</p> <p>High Priority A scheduling priority level for control messages and critical operations. See Patterns: Control-plane Priority.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#i","title":"I","text":"<p>Idempotency A property where processing the same message multiple times yields the same result. Important for retries and failure recovery. See Patterns: Error Handling.</p> <p>Ingress / Egress Ingress: entry points where data enters the graph. Egress: exit points where results leave the graph or are persisted. See Architecture: Message Flow.</p> <p>Instrumentation Adding observability code to measure performance and behavior. See Observability: Performance Monitoring.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#l","title":"L","text":"<p>Latency Budget The maximum expected end-to-end time from message ingress to egress under normal load. See Observability: Performance Considerations.</p> <p>Latest Policy An overflow policy that keeps only the newest item when the queue is full. See Patterns: Latest Policy.</p> <p>Lifecycle Hook A method called by the runtime at specific points in a node's execution (start, message, tick, stop). See Patterns: Scheduler Lifecycle.</p> <p>Log Level The minimum severity level for log messages (DEBUG, INFO, WARN, ERROR). See Observability: Log Levels.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#m","title":"M","text":"<p>Metric A numeric time-series signal used for observability (counters, gauges, histograms) emitted by the runtime and nodes. See Observability: Metrics Collection.</p> <p>Message An envelope carrying a payload and metadata (e.g., timestamps, keys, trace IDs) across edges. See API: Message.</p> <p>Message Type Classification of messages as DATA, CONTROL, or ERROR. See API: Message.</p> <p>Middleware Software that provides services to applications beyond those available from the operating system.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#n","title":"N","text":"<p>Node A single-responsibility processing unit that consumes and produces messages. The core building block of graphs. See Architecture: Node.</p> <p>Namespace A prefix applied to metric names to organize and group related metrics. See Observability: Configuration.</p> <p>Normal Priority The default scheduling priority for data messages. See Patterns: Control-plane Priority.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#o","title":"O","text":"<p>Observability Capabilities for understanding internal state and behavior through logs, metrics, and traces. See Observability.</p> <p>Overflow A queue-full condition on an edge that triggers the configured enqueue policy. See Patterns: Backpressure and Overflow.</p> <p>Overflow Policy The behavior applied when an edge's queue is full. See API: Policy Semantics.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#p","title":"P","text":"<p>Priority A scheduling attribute that influences the execution order of messages or tasks (e.g., control messages may have higher priority). See Patterns: Control-plane Priority.</p> <p>Producer / Consumer Producer: emits messages onto an edge. Consumer: receives messages from an edge. Nodes are often both. See Architecture: Message Flow.</p> <p>Port A named input or output connection point on a node. See API: Ports and PortSpec.</p> <p>Policy A configuration object that defines behavior for edges, routing, or retries. See API: Policies.</p> <p>Payload The actual data content of a message. See API: Message Fields.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#q","title":"Q","text":"<p>Queue The internal buffer on an edge that decouples producers and consumers. Bounded by design. See Architecture: Edge.</p> <p>Queue Depth The current number of messages waiting in a queue. See Observability: Built-in Metrics.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#r","title":"R","text":"<p>Retry A strategy to attempt processing again after transient failures. Often paired with idempotency and backoff policies. See API: RetryPolicy.</p> <p>Runtime The scheduler and orchestration engine that executes nodes, enforces priorities, and provides observability. See Architecture: Core Components.</p> <p>Routing The process of directing messages to specific paths based on content or policy. See Patterns: Routing.</p> <p>Routable A protocol that allows objects to provide a routing key. See API: Routing.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#s","title":"S","text":"<p>Scheduler Component that decides execution order of work items based on priorities, readiness, and backpressure signals. See Architecture: Scheduler.</p> <p>Shutdown (Graceful) A termination mode where the runtime stops accepting new work, drains in-flight messages, and cleans up resources. See API: Scheduler Examples.</p> <p>Subgraph A reusable composite of nodes and edges treated as a single unit within a larger graph. See Patterns: Subgraph Composition.</p> <p>Span A unit of work in distributed tracing that represents an operation or function call. See Observability: Distributed Tracing.</p> <p>Structured Logging Logging that uses consistent, machine-readable formats with structured fields. See Observability: Structured Logging.</p> <p>Sample Rate The fraction of operations that are traced (0.0 to 1.0). See Observability: Configuration.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#t","title":"T","text":"<p>Trace A correlated record of events across nodes/edges that captures causality for a single request or message journey. See Observability: Distributed Tracing.</p> <p>Throughput The rate at which messages are processed (e.g., messages/sec). Balanced with latency and resource usage. See Observability: Performance Considerations.</p> <p>Typed Edge An edge that enforces a payload schema or type for messages, enabling validation and safety. See API: Ports and PortSpec.</p> <p>Tick A periodic execution cycle for nodes that need time-based processing. See Patterns: Scheduler Lifecycle.</p> <p>Trace ID A unique identifier that correlates all operations within a single request or message flow. See Observability: Trace Context Management.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#u","title":"U","text":"<p>Upstream / Downstream Upstream: components that produce inputs to a node. Downstream: components that consume outputs from a node. See Architecture: Message Flow.</p> <p>Unbounded A queue or buffer without size limits (not used in Meridian Runtime by design).</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#v","title":"V","text":"<p>Validation The process of ensuring message payloads conform to expected schemas or invariants before processing. See Patterns: Error Handling.</p> <p>Version A release identifier for the runtime or application components.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#w","title":"W","text":"<p>Watermark A progress indicator that denotes that all messages up to a certain event-time or sequence have been observed/processed.</p> <p>Worker A node that performs computational work on messages.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#z","title":"Z","text":"<p>Zero-downtime Deploy A deployment strategy that avoids service interruption via techniques like blue/green, canary, or rolling updates with graceful handover.</p> <p>Zero-cost A property where features have no performance impact when disabled. See Observability: Performance Considerations.</p>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#conventions","title":"Conventions","text":"","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Use bold for glossary terms when first defined</li> <li>Use lowercase-kebab-case for filenames and directories</li> <li>Use sentence case for headings; retain canonical capitalization for proper nouns</li> <li>Prefer precise, unambiguous definitions with links to reference pages</li> </ul>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#code-standards","title":"Code Standards","text":"<ul> <li>Use snake_case for Python functions and variables</li> <li>Use PascalCase for Python classes</li> <li>Use UPPER_CASE for constants</li> <li>Use descriptive names that reflect purpose and behavior</li> </ul>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#cross-references","title":"Cross-references","text":"<ul> <li>Link to relevant API documentation sections</li> <li>Reference specific patterns and examples</li> <li>Include links to architecture concepts</li> <li>Connect related terms within the glossary</li> </ul>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/glossary/#change-requests","title":"Change Requests","text":"<ul> <li>Propose additions/edits via PRs referencing the term's first usage in code/docs</li> <li>Include examples and cross-links to relevant guides or reference pages</li> <li>Ensure new terms follow established conventions</li> <li>Update related documentation when adding new terms </li> </ul>","tags":["glossary","terminology","concepts","reference"]},{"location":"concepts/observability/","title":"Observability","text":"<p>Meridian Runtime provides a comprehensive observability system with structured logging, metrics collection, and distributed tracing. All subsystems are designed to be zero-cost when disabled and integrate seamlessly with external monitoring systems.</p> <p>See Also</p> <p>Check the API Reference for detailed API documentation and the Patterns for observability usage patterns.</p>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#tutorial-getting-started","title":"Tutorial: Getting Started","text":"","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#basic-configuration","title":"Basic Configuration","text":"<p>Configure all observability subsystems with a single configuration object:</p> Python<pre><code>from meridian.observability.config import ObservabilityConfig, configure_observability\n\n# Simple development setup\nconfig = ObservabilityConfig(\n    log_level=\"INFO\",\n    log_json=True,\n    metrics_enabled=True,\n    metrics_namespace=\"myapp\",\n    tracing_enabled=True,\n    tracing_provider=\"inmemory\",\n    tracing_sample_rate=1.0\n)\n\nconfigure_observability(config)\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#pre-configured-environments","title":"Pre-configured Environments","text":"<p>Use built-in configurations for common environments:</p> Python<pre><code>from meridian.observability.config import get_development_config, get_production_config\n\n# Development: full observability for debugging\ndev_config = get_development_config()\nconfigure_observability(dev_config)\n\n# Production: optimized for performance\nprod_config = get_production_config()\nconfigure_observability(prod_config)\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#how-to-structured-logging","title":"How-to: Structured Logging","text":"","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#basic-logging","title":"Basic Logging","text":"<p>Use structured logging with event keys and contextual fields:</p> Python<pre><code>from meridian.observability.logging import get_logger\n\nlogger = get_logger()\n\n# Simple logging\nlogger.info(\"node.start\", \"Node starting up\", node_name=\"worker\", version=\"1.0\")\n\n# Error logging with context\nlogger.error(\"node.error\", \"Failed to process message\", \n            error=\"validation_failed\", \n            message_id=\"123\",\n            port=\"input\")\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#contextual-logging","title":"Contextual Logging","text":"<p>Enrich logs with runtime context using <code>with_context()</code>:</p> Python<pre><code>from meridian.observability.logging import get_logger, with_context\n\nlogger = get_logger()\n\n# Add context for a block of operations\nwith with_context(node=\"worker\", edge_id=\"input-&gt;output\", trace_id=\"abc-123\"):\n    logger.info(\"processing.start\", \"Starting message processing\")\n\n    # All logs in this block inherit the context\n    logger.debug(\"processing.step\", \"Validating message\")\n    logger.info(\"processing.complete\", \"Message processed successfully\")\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#log-levels-and-configuration","title":"Log Levels and Configuration","text":"<p>Configure logging behavior globally:</p> Python<pre><code>from meridian.observability.logging import configure, LogLevel\n\n# Configure logging programmatically\nconfigure(\n    level=LogLevel.DEBUG,\n    extra={\"service\": \"myapp\", \"version\": \"1.0\"}\n)\n\n# JSON vs key=value format\nconfigure(level=\"INFO\")  # Uses JSON by default\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#how-to-metrics-collection","title":"How-to: Metrics Collection","text":"","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#basic-metrics","title":"Basic Metrics","text":"<p>Collect application and runtime metrics:</p> Python<pre><code>from meridian.observability.metrics import get_metrics\n\nmetrics = get_metrics()\n\n# Counters for events\nmessages_processed = metrics.counter(\"messages_processed_total\")\nmessages_processed.inc()\n\n# Gauges for current state\nqueue_depth = metrics.gauge(\"queue_depth\")\nqueue_depth.set(42)\n\n# Histograms for distributions\nprocessing_time = metrics.histogram(\"processing_duration_seconds\")\nprocessing_time.observe(0.125)\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#performance-monitoring","title":"Performance Monitoring","text":"<p>Use <code>time_block()</code> for automatic timing and metrics:</p> Python<pre><code>from meridian.observability.metrics import time_block\n\n# Automatic timing with metrics\nwith time_block(\"node_processing_duration\"):\n    result = process_message(msg)\n    # Timing automatically recorded when block exits\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#custom-metrics-with-labels","title":"Custom Metrics with Labels","text":"<p>Add dimensions to metrics for better analysis:</p> Python<pre><code>metrics = get_metrics()\n\n# Metrics with labels for filtering/grouping\nerrors_by_type = metrics.counter(\"errors_total\", labels={\"error_type\": \"validation\"})\nerrors_by_type.inc()\n\n# Node-specific metrics\nnode_metrics = metrics.gauge(\"node_memory_bytes\", labels={\"node\": \"worker\"})\nnode_metrics.set(1024 * 1024)\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#how-to-distributed-tracing","title":"How-to: Distributed Tracing","text":"","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#basic-tracing","title":"Basic Tracing","text":"<p>Create spans to track operation flow:</p> Python<pre><code>from meridian.observability.tracing import start_span\n\n# Create a span for an operation\nwith start_span(\"process_message\", {\"message_id\": \"123\", \"node\": \"worker\"}):\n    # All operations in this block are traced\n    validate_message(msg)\n    transform_message(msg)\n    send_message(msg)\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#nested-spans","title":"Nested Spans","text":"<p>Create hierarchical traces:</p> Python<pre><code>from meridian.observability.tracing import start_span\n\nwith start_span(\"pipeline_execution\", {\"pipeline\": \"data_processing\"}):\n    # Parent span\n\n    with start_span(\"validation\", {\"stage\": \"input\"}):\n        validate_input(data)\n\n    with start_span(\"transformation\", {\"stage\": \"processing\"}):\n        transform_data(data)\n\n    with start_span(\"output\", {\"stage\": \"final\"}):\n        send_output(data)\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#trace-context-management","title":"Trace Context Management","text":"<p>Manage trace context across operations:</p> Python<pre><code>from meridian.observability.tracing import set_trace_id, get_trace_id\n\n# Set trace context\nset_trace_id(\"abc-123-def-456\")\n\n# Retrieve current trace ID\ncurrent_trace = get_trace_id()\nprint(f\"Current trace: {current_trace}\")\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#reference-configuration-options","title":"Reference: Configuration Options","text":"","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#observabilityconfig","title":"ObservabilityConfig","text":"<p>Complete configuration for all observability subsystems:</p> Python<pre><code>@dataclass\nclass ObservabilityConfig:\n    # Logging\n    log_level: LogLevel = LogLevel.INFO\n    log_json: bool = True\n    log_stream: TextIO | None = None\n\n    # Metrics\n    metrics_enabled: bool = False\n    metrics_namespace: str = \"meridian-runtime\"\n\n    # Tracing\n    tracing_enabled: bool = False\n    tracing_provider: str = \"noop\"\n    tracing_sample_rate: float = 0.0\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#log-levels","title":"Log Levels","text":"<p>Available logging severity levels:</p> <ul> <li><code>DEBUG</code>: Detailed diagnostic information</li> <li><code>INFO</code>: General operational messages</li> <li><code>WARN</code>: Warning conditions</li> <li><code>ERROR</code>: Error conditions</li> </ul>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#tracing-providers","title":"Tracing Providers","text":"<p>Supported tracing backends:</p> <ul> <li><code>\"noop\"</code>: Disabled tracing (default)</li> <li><code>\"inmemory\"</code>: In-memory tracer for development</li> <li><code>\"opentelemetry\"</code>: OpenTelemetry integration (placeholder)</li> </ul>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#reference-metric-types","title":"Reference: Metric Types","text":"","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#counter","title":"Counter","text":"<p>Monotonically increasing values for counting events:</p> Python<pre><code>counter = metrics.counter(\"events_total\")\ncounter.inc()           # Increment by 1\ncounter.inc(5)          # Increment by 5\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#gauge","title":"Gauge","text":"<p>Current value measurements for state:</p> Python<pre><code>gauge = metrics.gauge(\"active_connections\")\ngauge.set(42)           # Set current value\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#histogram","title":"Histogram","text":"<p>Distribution measurements for latency and sizes:</p> Python<pre><code>histogram = metrics.histogram(\"request_duration_seconds\")\nhistogram.observe(0.125)  # Record observation\n</code></pre>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#reference-built-in-metrics","title":"Reference: Built-in Metrics","text":"","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#node-metrics","title":"Node Metrics","text":"<p>Runtime automatically collects these metrics for each node:</p> <ul> <li><code>messages_total</code>: Total messages processed</li> <li><code>errors_total</code>: Total errors encountered</li> <li><code>tick_duration</code>: Time spent in tick operations</li> </ul>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#edge-metrics","title":"Edge Metrics","text":"<p>Per-edge metrics for monitoring data flow:</p> <ul> <li><code>enqueued_total</code>: Messages enqueued</li> <li><code>dequeued_total</code>: Messages dequeued</li> <li><code>dropped_total</code>: Messages dropped due to overflow</li> <li><code>queue_depth</code>: Current queue depth</li> <li><code>blocked_time</code>: Time spent blocked</li> </ul>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#scheduler-metrics","title":"Scheduler Metrics","text":"<p>System-level performance metrics:</p> <ul> <li><code>runnable_nodes</code>: Number of runnable nodes</li> <li><code>loop_latency</code>: Scheduler loop latency</li> <li><code>priority_applied</code>: Priority scheduling decisions</li> </ul>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#explanation-observability-patterns","title":"Explanation: Observability Patterns","text":"","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#when-to-use-each-subsystem","title":"When to Use Each Subsystem","text":"<p>Logging: Use for operational events, errors, and debugging information</p> <ul> <li>\u2705 Lifecycle events (start, stop, configuration changes)</li> <li>\u2705 Error conditions with context</li> <li>\u2705 Debug information for troubleshooting</li> </ul> <p>Metrics: Use for performance monitoring and alerting</p> <ul> <li>\u2705 Throughput measurements (messages/second)</li> <li>\u2705 Latency distributions (processing time)</li> <li>\u2705 Resource utilization (memory, queue depth)</li> <li>\u2705 Business metrics (success rate, error rate)</li> </ul> <p>Tracing: Use for request flow analysis and debugging</p> <ul> <li>\u2705 Request/response flows across nodes</li> <li>\u2705 Performance bottleneck identification</li> <li>\u2705 Distributed debugging</li> <li>\u2705 Dependency analysis</li> </ul>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Zero Cost: All subsystems are no-op when disabled</li> <li>Sampling: Use tracing sample rates to control overhead</li> <li>Buffering: Metrics are buffered in memory for efficiency</li> <li>Async: Logging and metrics don't block the main processing loop</li> </ul>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#integration-with-external-systems","title":"Integration with External Systems","text":"<p>Logging: JSON format compatible with log aggregation systems</p> <ul> <li>ELK Stack (Elasticsearch, Logstash, Kibana)</li> <li>Splunk</li> <li>Cloud logging (AWS CloudWatch, GCP Logging)</li> </ul> <p>Metrics: Prometheus-compatible format</p> <ul> <li>Prometheus for collection and alerting</li> <li>Grafana for visualization</li> <li>Cloud monitoring (AWS CloudWatch, GCP Monitoring)</li> </ul> <p>Tracing: OpenTelemetry compatible</p> <ul> <li>Jaeger for trace visualization</li> <li>Zipkin for distributed tracing</li> <li>Cloud tracing (AWS X-Ray, GCP Trace)</li> </ul>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/observability/#best-practices","title":"Best Practices","text":"<ol> <li>Structured Logging: Always use event keys and structured fields</li> <li>Context Propagation: Use <code>with_context()</code> for related operations</li> <li>Metric Naming: Use consistent naming conventions (snake_case)</li> <li>Label Cardinality: Limit metric label values to prevent explosion</li> <li>Sampling: Use appropriate tracing sample rates for production</li> <li>Error Handling: Log errors with sufficient context for debugging </li> </ol>","tags":["observability","logging","metrics","tracing","monitoring","debugging"]},{"location":"concepts/patterns/","title":"Patterns","text":"<p>This page shows common graph patterns with minimal examples grounded in the actual runtime APIs.</p> <p>See Also</p> <p>Check the API Reference for detailed API documentation and semantics.</p>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#tutorial-basic-patterns","title":"Tutorial: Basic Patterns","text":"","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#message-creation-and-headers","title":"Message Creation and Headers","text":"<p>Messages automatically populate <code>trace_id</code> and <code>timestamp</code> headers if not provided:</p> Python<pre><code>from meridian.core import Message, MessageType\n\n# Headers auto-populated # (1)\nmsg = Message(MessageType.DATA, payload=\"hello\")\nprint(msg.get_trace_id())  # Auto-generated UUID\nprint(msg.get_timestamp()) # Current time\n\n# Custom headers override defaults\nmsg = Message(\n    MessageType.DATA, \n    payload=\"hello\",\n    headers={\"trace_id\": \"custom-123\", \"timestamp\": 1234567890.0}\n)\n</code></pre> <ul> <li>See Message.post_init() for auto-population logic</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#how-to-backpressure-and-overflow","title":"How-to: Backpressure and Overflow","text":"<p>Meridian provides bounded edges with configurable policies. The policy protocol and results are defined in <code>meridian.core.policies</code> (Block, Drop, Latest, Coalesce; see <code>PutResult</code>).</p> <ul> <li>Block (default): apply backpressure upstream (producer blocks/yields when full)</li> <li>Drop: discard new messages when full</li> <li>Latest: keep only the newest item when full (replace older)</li> <li>Coalesce: merge queued items under pressure via a deterministic function</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#block-default-backpressure","title":"Block (default backpressure)","text":"Python<pre><code>from meridian.core import Subgraph, Scheduler, Node, Message, MessageType, PortSpec\nfrom meridian.core.ports import Port, PortDirection\nfrom meridian.core.policies import block # (1)\n\nclass Producer(Node):\n    def __init__(self):\n        super().__init__(\n            \"producer\",\n            inputs=[],\n            outputs=[Port(\"out\", PortDirection.OUTPUT, spec=PortSpec(\"out\", int))],\n        )\n    def _handle_tick(self):\n        self.emit(\"out\", Message(type=MessageType.DATA, payload=1))\n\nclass Consumer(Node):\n    def __init__(self):\n        super().__init__(\n            \"consumer\",\n            inputs=[Port(\"in\", PortDirection.INPUT, spec=PortSpec(\"in\", int))],\n            outputs=[],\n        )\n    def _handle_message(self, port, msg):\n        print(\"got\", msg.payload)\n\nsg = Subgraph.from_nodes(\"p_block\", [Producer(), Consumer()])\n# Default policy is block(); producers cooperatively back off when capacity is reached. # (2)\nsg.connect((\"producer\",\"out\"), (\"consumer\",\"in\"), capacity=16)\nScheduler().register(sg)\nScheduler().run()\n</code></pre> <ul> <li>Factory function from policies.py</li> <li>Block policy implementation in Block.on_enqueue()</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#drop-lossy-prefer-freshness","title":"Drop (lossy, prefer freshness)","text":"Python<pre><code>from meridian.core import Subgraph, Scheduler\nfrom meridian.core.policies import drop # (1)\n# Producer/Consumer as above...\nsg = Subgraph.from_nodes(\"p_drop\", [Producer(), Consumer()])\nsg.connect((\"producer\",\"out\"), (\"consumer\",\"in\"), capacity=16, policy=drop())\nScheduler().register(sg)\nScheduler().run()\n</code></pre> <ul> <li>Drop policy factory from policies.py</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#latest-replace-older-with-newest","title":"Latest (replace older with newest)","text":"Python<pre><code>from meridian.core import Subgraph, Scheduler\nfrom meridian.core.policies import latest # (1)\n# Producer/Consumer as above...\nsg = Subgraph.from_nodes(\"p_latest\", [Producer(), Consumer()])\nsg.connect((\"producer\",\"out\"), (\"consumer\",\"in\"), capacity=4, policy=latest())\nScheduler().register(sg)\nScheduler().run()\n</code></pre> <ul> <li>Latest policy factory from policies.py</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#coalesce-deterministic-merge-under-pressure","title":"Coalesce (deterministic merge under pressure)","text":"Python<pre><code>from dataclasses import dataclass\nfrom meridian.core import Subgraph, Scheduler\nfrom meridian.core.policies import coalesce # (1)\n\n@dataclass(frozen=True, slots=True)\nclass Stat:\n    count: int\n    total: float\ndef merge_stats(a: object, b: object) -&gt; object:\n    # Deterministic, pure merge; matches coalesce(fn: Callable[[object, object], object]) # (2)\n    assert isinstance(a, Stat) and isinstance(b, Stat)\n    return Stat(count=a.count + b.count, total=a.total + b.total)\n\n# Producer emits Stat(count=1, total=value); Consumer reads Stat\nsg = Subgraph.from_nodes(\"p_coalesce\", [Producer(), Consumer()])\nsg.connect((\"producer\",\"out\"), (\"consumer\",\"in\"), capacity=8, policy=coalesce(merge_stats))\nScheduler().register(sg)\nScheduler().run()\n</code></pre> <ul> <li>Coalesce policy factory from policies.py</li> <li>Coalesce policy implementation in Coalesce.on_enqueue()</li> </ul> <p>See Also</p> <p>Backpressure semantics and <code>PutResult</code> are in API: Backpressure and overflow.</p>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#how-to-control-plane-priority","title":"How-to: Control-plane Priority","text":"<p>Control-plane messages (MessageType.CONTROL) can preempt data-plane work for predictable behavior under load. Use a dedicated <code>ctl</code> port and wire separate control edges.</p> Python<pre><code>from meridian.core import Subgraph, Scheduler, Message, MessageType, Node, PortSpec\nfrom meridian.core.ports import Port, PortDirection\n\nclass Worker(Node):\n    def __init__(self):\n        super().__init__(\n            \"worker\",\n            inputs=[\n                Port(\"in\", PortDirection.INPUT, spec=PortSpec(\"in\", int)),\n                Port(\"ctl\", PortDirection.INPUT, spec=PortSpec(\"ctl\", str)),\n            ],\n            outputs=[Port(\"out\", PortDirection.OUTPUT, spec=PortSpec(\"out\", int))],\n        )\n        self._mode = \"normal\"\n\n    def _handle_message(self, port, msg):\n        if port == \"ctl\" and msg.type == MessageType.CONTROL: # (1)\n            cmd = str(msg.payload).strip().lower()\n            if cmd in {\"normal\", \"quiet\"}:\n                self._mode = cmd\n            return\n        if port == \"in\" and self._mode != \"quiet\":\n            self.emit(\"out\", Message(MessageType.DATA, msg.payload))\n\nclass Controller(Node):\n    def __init__(self):\n        super().__init__(\"controller\", inputs=[], outputs=[Port(\"ctl\", PortDirection.OUTPUT, spec=PortSpec(\"ctl\", str))])\n    def _handle_tick(self):\n        self.emit(\"ctl\", Message(MessageType.CONTROL, \"quiet\"))\n\nsg = Subgraph.from_nodes(\"ctl_demo\", [Worker(), Controller()])\n# Control edge: small capacity; scheduler treats CONTROL with higher priority. # (2)\nsg.connect((\"controller\",\"ctl\"), (\"worker\",\"ctl\"), capacity=4)\n# Add data edges as needed...\nScheduler().register(sg)\nScheduler().run()\n</code></pre> <ul> <li>MessageType.CONTROL defined in message.py</li> <li>Priority handling in SchedulerConfig.fairness_ratio</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#how-to-error-handling","title":"How-to: Error Handling","text":"<p>Handle errors gracefully with proper message types and structured logging:</p> Python<pre><code>from meridian.core import Message, MessageType\nfrom meridian.observability.logging import get_logger, with_context\n\nclass SafeNode(Node):\n    def _handle_message(self, port, msg):\n        logger = get_logger()\n        try:\n            # Process message\n            result = self._process(msg.payload)\n            self.emit(\"out\", Message(MessageType.DATA, result))\n        except ValueError as e:\n            # Emit structured error message # (1)\n            error_info = {\"error\": str(e), \"port\": port, \"payload_type\": type(msg.payload).__name__}\n            self.emit(\"error\", Message(MessageType.ERROR, payload=error_info)) # (2)\n            with with_context(node=self.name, port=port): # (3)\n                logger.error(\"node.error\", f\"Validation error: {e}\", error=str(e))\n        except Exception as e:\n            # Log and continue for unexpected errors\n            with with_context(node=self.name, port=port):\n                logger.error(\"node.fatal\", f\"Unexpected error: {e}\", error=str(e))\n            # Optionally emit error message\n            self.emit(\"error\", Message(MessageType.ERROR, payload={\"error\": str(e)}))\n</code></pre> <ul> <li>Error message structure from MessageType.ERROR</li> <li>ERROR message type for structured error reporting</li> <li>Contextual logging from logging.py</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#reference-scheduler-configuration-and-lifecycle","title":"Reference: Scheduler Configuration and Lifecycle","text":"<p>The cooperative scheduler is tuned via <code>SchedulerConfig</code>. Nodes participate using lifecycle hooks (<code>on_start</code>, <code>on_message</code>, <code>on_tick</code>, <code>on_stop</code>).</p> Python<pre><code>from meridian.core import Scheduler, SchedulerConfig\n\nclass LifecycleNode(Node):\n    def on_start(self): # (1)\n        \"\"\"Called when node starts processing.\"\"\"\n        print(f\"Node {self.name} starting\")\n\n    def on_stop(self): # (2)\n        \"\"\"Called when node stops processing.\"\"\"\n        print(f\"Node {self.name} stopping\")\n\n    def _handle_message(self, port, msg): # (3)\n        \"\"\"Called for each incoming message.\"\"\"\n        print(f\"Processing message on {port}\")\n\n    def _handle_tick(self): # (4)\n        \"\"\"Called periodically for time-based processing.\"\"\"\n        print(f\"Tick for {self.name}\")\n\ncfg = SchedulerConfig(\n    tick_interval_ms=25,        # tick readiness interval # (5)\n    fairness_ratio=(4, 2, 1),   # (control, high, normal) priority weights # (6)\n    max_batch_per_node=8,       # work quota per scheduling slice # (7)\n    idle_sleep_ms=1,\n    shutdown_timeout_s=6.0,     # graceful stop when idle\n)\nsched = Scheduler(cfg)\n# Register subgraphs, then:\nsched.run()\n</code></pre> <ul> <li>Lifecycle hooks defined in Node</li> <li>Node lifecycle management in Scheduler</li> <li>Message handling in scheduler main loop</li> <li>Tick handling with interval from SchedulerConfig</li> <li>SchedulerConfig definition in scheduler.py</li> <li>Priority weights for different message types</li> <li>Batch size limits for fairness</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#reference-observability-patterns","title":"Reference: Observability Patterns","text":"<p>Configure logging/metrics/tracing once; use contextual logging within nodes.</p> Python<pre><code>from meridian.observability.config import ObservabilityConfig, configure_observability # (1)\nfrom meridian.observability.logging import get_logger, with_context\n\n# Configure all observability subsystems\nconfigure_observability(ObservabilityConfig(\n    log_level=\"INFO\",\n    log_json=False,           # human-readable\n    metrics_enabled=True,     # Enable metrics collection\n    metrics_namespace=\"myapp\",\n    tracing_enabled=True,     # Enable tracing\n    tracing_provider=\"inmemory\",\n    tracing_sample_rate=-0,\n))\n\nlogger = get_logger()\nwith with_context(node=\"demo\", edge_id=\"main_pipeline\"): # (2)\n    logger.info(\"demo.start\", \"Starting pipeline\", version=\"-0\")\n</code></pre> <ul> <li>ObservabilityConfig from config.py</li> <li>Context management from logging.py</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#metrics-and-tracing","title":"Metrics and Tracing","text":"Python<pre><code>from meridian.observability.metrics import get_metrics, time_block # (1)\nfrom meridian.observability.tracing import start_span # (2)\n\nclass InstrumentedNode(Node):\n    def _handle_message(self, port, msg):\n        metrics = get_metrics()\n\n        # Time the processing\n        with time_block(\"node_processing_duration\"): # (3)\n            with start_span(\"process_message\", {\"port\": port, \"type\": msg.type.value}): # (4)\n                result = self._process(msg.payload)\n                metrics.counter(\"messages_processed_total\").inc() # (5)\n                self.emit(\"out\", Message(MessageType.DATA, result))\n</code></pre> <ul> <li>Metrics utilities from metrics.py</li> <li>Tracing utilities from tracing.py</li> <li>Timing instrumentation for performance monitoring</li> <li>Span creation for distributed tracing</li> <li>Counter increment for metrics collection</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#reference-subgraph-composition-and-reuse","title":"Reference: Subgraph Composition and Reuse","text":"<ul> <li>Expose clear input/output ports and validate wiring.</li> <li>Compose smaller subgraphs and expose a clean surface.</li> </ul> Python<pre><code>from meridian.core import Subgraph, Node, PortSpec, Message, MessageType\nfrom meridian.core.ports import Port, PortDirection\n\nclass Upper(Node):\n    def __init__(self):\n        super().__init__(\n            \"upper\",\n            inputs=[Port(\"in\", PortDirection.INPUT, spec=PortSpec(\"in\", str))],\n            outputs=[Port(\"out\", PortDirection.OUTPUT, spec=PortSpec(\"out\", str))],\n        )\n    def _handle_message(self, port, msg):\n        self.emit(\"out\", Message(type=MessageType.DATA, payload=str(msg.payload).upper()))\n\nclass Printer(Node):\n    def __init__(self):\n        super().__init__(\n            \"printer\",\n            inputs=[Port(\"in\", PortDirection.INPUT, spec=PortSpec(\"in\", str))],\n            outputs=[],\n        )\n    def _handle_message(self, port, msg):\n        print(msg.payload)\n\nsg = Subgraph.from_nodes(\"upper_print\", [Upper(), Printer()]) # (1)\nsg.connect((\"upper\",\"out\"), (\"printer\",\"in\"), capacity=8)\n</code></pre> <ul> <li>Subgraph composition from subgraph.py</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#reference-routing","title":"Reference: Routing","text":"<p>Partition or direct items using a routing key. If a payload implements <code>Routable</code>, the runtime uses its <code>route_key()</code>. Otherwise, <code>RoutingPolicy.key</code> is used.</p> Python<pre><code>from dataclasses import dataclass\nfrom meridian.core.policies import Routable, RoutingPolicy # (1)\n\n@dataclass(frozen=True, slots=True)\nclass Event(Routable): # (2)\n   user_id: str\n   value: int\n   def route_key(self) -&gt; str:\n       # Route by user for per-user ordering/partitioning\n       return self.user_id\n\npolicy = RoutingPolicy(key=\"default\") # (3)\n# In runtime paths that select a route, the policy will use Event.route_key() if available,\n# else fall back to the provided default key.\nrk1 = policy.select(Event(user_id=\"u123\", value=7))  # \"u123\" # (4)\nrk2 = policy.select({\"value\": 7})                    # \"default\"\n</code></pre> <ul> <li>Routing types from policies.py</li> <li>Routable protocol definition</li> <li>RoutingPolicy implementation</li> <li>Policy selection logic in RoutingPolicy.select()</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#reference-additional-policy-types","title":"Reference: Additional Policy Types","text":"","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#retrypolicy-and-backpressurestrategy","title":"RetryPolicy and BackpressureStrategy","text":"Python<pre><code>from meridian.core.policies import RetryPolicy, BackpressureStrategy # (1)\n\n# Retry behavior for operations\nretry_policy = RetryPolicy.SIMPLE  # or RetryPolicy.NONE # (2)\n\n# High-level backpressure strategy\nstrategy = BackpressureStrategy.BLOCK  # or BackpressureStrategy.DROP # (3)\n</code></pre> <ul> <li>Additional policy types from policies.py</li> <li>RetryPolicy enum values</li> <li>BackpressureStrategy enum values</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#explanation-pattern-selection-guidelines","title":"Explanation: Pattern Selection Guidelines","text":"","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#when-to-use-each-backpressure-policy","title":"When to Use Each Backpressure Policy","text":"<ul> <li>Block: Use for lossless data where producers can wait (e.g., database writes, file processing)</li> <li>Drop: Use for telemetry, monitoring, or low-importance streams where freshness matters more than completeness</li> <li>Latest: Use for UI state, configuration updates, or single-slot consumers that only need the newest value</li> <li>Coalesce: Use for batchable workloads where combining items reduces pressure (e.g., aggregations, summaries)</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#control-vs-data-messages","title":"Control vs Data Messages","text":"<ul> <li>CONTROL: Use for lifecycle events, configuration changes, or coordination signals</li> <li>DATA: Use for normal application payloads</li> <li>ERROR: Use for structured error reporting that should be handled by error consumers</li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"concepts/patterns/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Keep node processing time bounded to maintain fairness</li> <li>Use appropriate edge capacities based on producer/consumer rates</li> <li>Enable metrics and tracing in development to identify bottlenecks</li> <li>Consider <code>max_batch_per_node</code> tuning for latency-sensitive workloads </li> </ul>","tags":["patterns","architecture","best-practices","examples","backpressure","observability"]},{"location":"contributing/CI-TRIAGE/","title":"CI Triage and Ownership Guide","text":"<p>Status: Active Owner: Core Maintainers Last Updated: 2025-01-01</p> <p>This guide explains how to triage and fix Continuous Integration (CI) failures quickly and with low churn. It complements CONTRIBUTING.md and documents the owners, common failures, and step-by-step remediation.</p> <p>Quick Links - CI dashboard: GitHub Actions \u2192 CI workflow - Docs: MkDocs build logs under \u201cBuild MkDocs site\u201d - Link Checker: \u201cCheck links (lychee)\u201d - Snippet Smoke: \u201cValidate docs commands\u201d - Build-and-Test: \u201cLint, Type, and Test (Python 3.11)\u201d</p> <p>Ownership and Escalation Primary Owners - CI Orchestration (workflow logic, caching, concurrency):   - Lead: doubletap-dave   - Backup: core-maintainer-2 - Linting &amp; Formatting (ruff, black, pre-commit):   - Lead: core-maintainer-1   - Backup: core-maintainer-3 - Types (mypy):   - Lead: core-maintainer-2   - Backup: core-maintainer-1 - Tests &amp; Coverage (pytest):   - Lead: core-maintainer-3   - Backup: core-maintainer-2 - Docs Build (MkDocs) &amp; Snippets:   - Lead: docs-maintainer-1   - Backup: core-maintainer-1 - Link Check (lychee):   - Lead: docs-maintainer-1   - Backup: core-maintainer-3</p> <p>Escalation 1) If you cannot fix within 1\u20132 commits, open an issue labeled ci-broken and assign the relevant owner. 2) If the failure blocks a critical PR, coordinate in the team channel and apply a minimal, reversible mitigation while working on a root-cause fix. 3) For flaky jobs, switch to non-blocking only as a short-term mitigation and track a follow-up issue with a deadline.</p> <p>General Triage Workflow 1) Identify failing job(s) - From the PR/commit page, open GitHub Actions logs. - Note the first failure; ignore cascading errors.</p> <p>2) Reproduce locally (CI parity) - Sync dependencies with uv:   - uv lock (if missing)   - uv sync - Run the failing tool locally:   - Lint: uv run ruff check .   - Format: uv run black --check .   - Types: uv run mypy src   - Tests: uv run pytest   - Docs: mkdocs build --strict   - Snippets: mimic the job\u2019s uv run invocation   - Links: run lychee locally or verify URLs by hand; respect .lycheeignore</p>"},{"location":"contributing/CI-TRIAGE/#apply-the-smallest-fix-that-unblocks-ci","title":"Apply the smallest fix that unblocks CI","text":"<ul> <li>Prefer a single focused commit.</li> <li>Avoid speculative changes; let linters/type-checkers guide fixes.</li> <li>If flakiness is external, add to .lycheeignore or apply limited retries with clear comments.</li> </ul> <p>4) Verify and merge - Push the fix; ensure CI is fully green on the PR. - If a temporary relaxation was used, open a tracking issue to revert it and set a due date.</p> <p>Common Failures and Fixes Build-and-Test - ruff lint failures:   - Run: uv run ruff check .   - Fix the reported rules; use # noqa only with justification.   - Keep line length at 100 (aligned with black). - black format check:   - Run: uv run black .   - Commit formatting changes. - mypy type errors:   - Prefer precise types and typed signatures over Any.   - Add Protocols or TypedDict where interfaces are implied.   - Avoid global Optional unless semantically required; prefer non-None invariants. - pytest failures:   - Run: uv run pytest -q --maxfail=1   - Stabilize flaky tests (timeouts, sleeps). For integration-like tests, prefer deterministic stubs.   - If coverage dips under threshold, add tests or adjust threshold temporarily with a tracked deadline.</p> <p>Docs: MkDocs build - mkdocs build --strict fails:   - Missing pages in nav: update mkdocs.yml nav or links in docs.   - Broken anchors or malformed Markdown (unterminated fences): fix formatting.   - Ensure all code fences have language identifiers (bash, python, toml, yaml).   - Replace \u201c---\u201d used as a visual separator with *** or . - Locally reproduce: pip install mkdocs mkdocs-material mkdocs-git-revision-date-localized-plugin; then mkdocs build --strict.</p> <p>Docs Snippet Validation - \u201cValidate docs commands\u201d import errors:   - Ensure invocations run via uv run python so package imports work.   - Keep snippet scope deterministic, short, and side-effect free.   - For unavoidable non-determinism, wrap in try/except and log non-fatal errors to stderr, but return non-zero on true failures.</p> <p>Link Checker (lychee) - Transient external failures:   - Use .lycheeignore for known flaky domains.   - Keep small retries: --max-retries 2, --retry-wait-time 2.   - Exclude private or build-only assets: --exclude-all-private, --exclude-file .lycheeignore. - Broken internal links:   - Prefer local links that work in both GitHub and MkDocs (e.g., ./quickstart.md).   - Avoid ../docs patterns in page bodies.</p> <p>Appendix: Link-Check Triage (Simple) - Goal: Fix or quarantine broken links quickly with minimal knobs. - Quick Steps:   1) Open \u201cCheck links (lychee)\u201d job \u2192 read the step summary.   2) If the URL is yours (docs/internal): fix the link or heading/anchor; keep it relative (./page.md#anchor).   3) If the URL is external and flaky: add a precise pattern to .lycheeignore with a short comment (why it flakes).   4) Re-run CI. If still failing, raise a small PR with the fix and link to the failing log. - Minimal Knobs:   - Prefer editing the broken URL over changing lychee args.   - Only ignore domains you don\u2019t control and that are consistently flaky.   - Keep ignores specific (domain + path if possible), not broad wildcards. - Local check:   - lychee --no-progress --include-fragments --exclude-file .lycheeignore docs . - Done when:   - CI is green and the link works locally (or is narrowly ignored with justification).</p> <p>Caching and Concurrency - Caching   - actions/setup-python with cache: \"pip\" is enabled.   - uv handles locking and environments; avoid mixing pip install for project deps (except tooling like mkdocs). - Concurrency   - Concurrency group ci-\\({{ github.workflow }}-\\) cancels in-progress runs on the same ref to reduce churn.}</p> <p>Promotion Policy: Link-Check to Required - Keep link-check non-blocking until stable across 3\u20135 consecutive PRs on main. - Monitor runtime and rate-limit behavior. - When stable:   - Remove continue-on-error: true from link-check job.   - Set it as a required status check in repository settings.   - Update this document and M99 plan status.</p> <p>Temporary Relaxations and Deadlines - Any relaxation (e.g., non-blocking link-check, coverage threshold dips) must:   - Be documented in the relevant file (workflow, pyproject) with a TODO and issue link.   - Have a tracking issue with an explicit deadline to restore the target.</p>"},{"location":"contributing/CI-TRIAGE/#local-parity-quick-commands","title":"Local Parity Quick Commands","text":"<ul> <li>Setup:</li> <li>uv lock (first time)</li> <li>uv sync</li> </ul>"},{"location":"contributing/CI-TRIAGE/#lintformat","title":"Lint/Format","text":"<ul> <li>uv run ruff check .</li> <li>uv run black --check .</li> </ul>"},{"location":"contributing/CI-TRIAGE/#types","title":"Types","text":"<ul> <li>uv run mypy src</li> </ul>"},{"location":"contributing/CI-TRIAGE/#tests","title":"Tests","text":"<ul> <li>uv run pytest</li> </ul>"},{"location":"contributing/CI-TRIAGE/#coverage-local-view","title":"Coverage (local view)","text":"<ul> <li>uv run pytest --cov=src --cov-report=term-missing</li> </ul>"},{"location":"contributing/CI-TRIAGE/#docs","title":"Docs","text":"<ul> <li>pip install mkdocs mkdocs-material mkdocs-git-revision-date-localized-plugin</li> <li>mkdocs build --strict</li> </ul> <p>Commit Hygiene - Keep CI fixes low-churn: one problem, one commit. - Write clear commit messages: \u201cci(link-check): add retries and ignore flaky domain X\u201d - Avoid reformat-only commits mixed with logic changes; use pre-commit locally to prevent noise.</p> <p>Appendix: When to Open an Issue vs. Commit Directly - Commit directly when:   - The fix is mechanical, low-risk, and reproducible locally. - Open an issue when:   - Flakiness persists after retries and ignores.   - Types/test failures need design changes.   - Docs IA or nav adjustments affect multiple pages.</p> <p>Cross-Reference - CONTRIBUTING.md: Setup, development workflow, pre-commit instructions. - M99 Plan: Status and acceptance criteria for docs and CI stabilization.</p>"},{"location":"contributing/CI-TRIAGE/#change-log-ci-triage-doc","title":"Change Log (CI Triage Doc)","text":"<ul> <li>2025-01-01: Initial version documenting owners, triage flow, common fixes, and promotion policy for link-check.</li> <li>2025-01-02: Added \u201cAppendix: Link-Check Triage (Simple)\u201d with quick steps and minimal knobs.</li> </ul>"},{"location":"contributing/RELEASING/","title":"Releasing Meridian Runtime","text":""},{"location":"contributing/RELEASING/#summary","title":"Summary","text":"<p>This guide describes the end-to-end process for preparing, tagging, verifying, and publishing a release of Meridian Runtime. It follows Semantic Versioning (SemVer) and emphasizes reliability, privacy, and reproducibility.</p>"},{"location":"contributing/RELEASING/#1-versioning-policy-semver","title":"1. Versioning Policy (SemVer)","text":"<p>We follow semantic versioning for all public APIs:</p> <ul> <li>MAJOR (<code>X.y.z</code>): incompatible API changes</li> <li>MINOR (<code>x.Y.z</code>): backward-compatible functionality  </li> <li>PATCH (<code>x.y.Z</code>): backward-compatible bug fixes</li> </ul>"},{"location":"contributing/RELEASING/#public-api-scope","title":"Public API Scope","text":"<ul> <li>Anything documented in <code>README</code> and docs, public classes/functions/types in primary packages, and command-line interface behaviors.</li> <li>Experimental APIs must be marked clearly and may change across minor versions.</li> </ul>"},{"location":"contributing/RELEASING/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Require an RFC/Decision Record (DR), migration notes, and explicit changelog entries.</li> <li>Avoid breaking changes in MINOR and PATCH releases.</li> </ul>"},{"location":"contributing/RELEASING/#2-pre-flight-checklist","title":"2. Pre-Flight Checklist","text":"<p>Ensure the following before cutting a release:</p>"},{"location":"contributing/RELEASING/#roadmap-and-drs","title":"Roadmap and DRs","text":"<ul> <li>Any release-defining DRs merged and linked.</li> <li><code>M0</code> governance and policies still accurate or updated.</li> </ul>"},{"location":"contributing/RELEASING/#quality-gates","title":"Quality Gates","text":"<ul> <li>Lint: clean</li> <li>Types: clean</li> <li>Tests: all pass locally and in CI</li> <li>Coverage targets: \u2265 80% critical modules, \u2265 70% overall (exceptions documented)</li> <li>Packaging sanity: build succeeds and artifacts import cleanly</li> </ul>"},{"location":"contributing/RELEASING/#documentation","title":"Documentation","text":"<ul> <li><code>README</code>: current quickstart, status, links to docs</li> <li><code>docs/plan</code>: updated if scope changed</li> <li><code>docs/support</code>: updated troubleshooting if necessary</li> <li>Examples and notebooks are maintained in the external <code>meridian-runtime-examples</code> repository. Ensure example smoke tests pass there prior to release.</li> </ul>"},{"location":"contributing/RELEASING/#observability-and-privacy-posture","title":"Observability and Privacy Posture","text":"<ul> <li>No payload contents in error events/logs by default</li> <li>Redaction hooks tested where applicable</li> <li>Diagnostics instructions current</li> </ul>"},{"location":"contributing/RELEASING/#dependency-review","title":"Dependency Review","text":"<ul> <li>Minimal, vetted runtime dependencies</li> <li>No accidental dev-only packages leaking into runtime</li> <li>License compatibility ok</li> </ul>"},{"location":"contributing/RELEASING/#3-determine-next-version","title":"3. Determine Next Version","text":"<p>Decide the version bump type based on changes since the last release:</p> <ul> <li>PATCH: bug fixes, performance improvements without API changes, documentation-only changes that don't alter published APIs, test infra</li> <li>MINOR: new features, optional adapters, new CLI subcommands that are backward compatible</li> <li>MAJOR: breaking changes, removed/renamed public APIs, incompatible behavior changes</li> </ul>"},{"location":"contributing/RELEASING/#record-the-rationale","title":"Record the Rationale","text":"<ul> <li>In the changelog's \"Unreleased \u2192 <code>&lt;version&gt;</code>\" section</li> <li>In any relevant DRs</li> </ul>"},{"location":"contributing/RELEASING/#4-changelog-management","title":"4. Changelog Management","text":"<p>Location: <code>CHANGELOG.md</code> (or equivalent in the repository root)</p>"},{"location":"contributing/RELEASING/#structure","title":"Structure","text":"<ul> <li>Unreleased</li> <li><code>&lt;version&gt;</code> \u2014 YYYY-MM-DD</li> <li>Added</li> <li>Changed</li> <li>Deprecated</li> <li>Removed</li> <li>Fixed</li> <li>Security</li> </ul>"},{"location":"contributing/RELEASING/#guidelines","title":"Guidelines","text":"<ul> <li>Use terse, user-focused entries.</li> <li>Link to PRs/issues/DRs for context.</li> <li>Include migration notes for any behavior or API changes.</li> <li>Call out privacy/observability behavior changes explicitly.</li> </ul>"},{"location":"contributing/RELEASING/#process","title":"Process","text":"<ol> <li>Move items from Unreleased to a new section for the version.</li> <li>Ensure every entry is clear and actionable for users.</li> <li>Leave an empty Unreleased section for future work.</li> </ol>"},{"location":"contributing/RELEASING/#5-update-version-and-metadata","title":"5. Update Version and Metadata","text":"<ul> <li>Update the package version (<code>pyproject.toml</code> or version module).</li> <li>Update any version strings in documentation if necessary.</li> <li>Verify dependency pins for examples and lockfiles for tools (e.g., <code>uv</code>).</li> </ul>"},{"location":"contributing/RELEASING/#version-consistency-checks","title":"Version Consistency Checks","text":"<ul> <li>Build artifact shows the intended version.</li> <li>Importing the package yields the same version (e.g., <code>meridian.__version__</code> if present).</li> <li>CLI reports the same version when applicable.</li> </ul>"},{"location":"contributing/RELEASING/#6-build-and-sanity-check","title":"6. Build and Sanity Check","text":""},{"location":"contributing/RELEASING/#local-build","title":"Local Build","text":"<ul> <li>Build source and wheel artifacts using the project's standard tooling.</li> <li>Confirm artifacts are small and do not include unnecessary files.</li> </ul>"},{"location":"contributing/RELEASING/#sanity-tests","title":"Sanity Tests","text":"<ul> <li>Create a clean virtual environment.</li> <li>Install the local artifact(s).</li> <li>Import key modules; run a small example or smoke tests.</li> <li>Run <code>ruff</code>, <code>mypy</code>, and <code>pytest</code> in a controlled environment to confirm no packaging regressions.</li> </ul>"},{"location":"contributing/RELEASING/#7-verification-suite","title":"7. Verification Suite","text":"<p>Run smoke and integration checks:</p> <ul> <li>Examples: run the primary examples end-to-end</li> <li>Scheduler: verify fairness basic invariants and clean shutdown</li> <li>Bounded edges: verify overflow policies (block, drop, latest, coalesce)</li> <li>Observability: verify structured logs appear with expected keys</li> <li>Error handling: ensure no payload contents in error events by default</li> <li>Type-check and lint: clean</li> <li>Tests: full suite green</li> </ul>"},{"location":"contributing/RELEASING/#performance-sanity","title":"Performance Sanity","text":"<ul> <li>Run lightweight micro-benchmarks or repeatable load scripts (if present)</li> <li>Compare results to previous release ranges (no significant regressions)</li> </ul>"},{"location":"contributing/RELEASING/#8-tagging-and-signing","title":"8. Tagging and Signing","text":""},{"location":"contributing/RELEASING/#create-a-release-commit","title":"Create a Release Commit","text":"<p>Include: - Version bump - Updated <code>CHANGELOG.md</code> - Any migration notes in docs - Any updated example pins</p> <p>Ensure CI is green on the release commit.</p>"},{"location":"contributing/RELEASING/#tagging","title":"Tagging","text":"<ul> <li>Use annotated tags: <code>vX.Y.Z</code></li> <li>Include a concise message with highlights and links to the changelog</li> <li>If applicable, sign the tag using your standard signing key</li> </ul> <p>Example: Bash<pre><code>git tag -a vX.Y.Z -m \"Meridian Runtime vX.Y.Z \u2014 highlights: &lt;short summary&gt;\"\ngit push origin vX.Y.Z\n</code></pre></p>"},{"location":"contributing/RELEASING/#9-publish-artifacts","title":"9. Publish Artifacts","text":"<ul> <li>Push build artifacts to the designated package registry.</li> <li>Verify the artifacts are present and downloadable.</li> <li>Confirm installation from the registry in a clean environment:</li> <li>New venv</li> <li>Install from registry</li> <li>Import, run quick sample, verify version</li> </ul>"},{"location":"contributing/RELEASING/#10-post-release-verification","title":"10. Post-Release Verification","text":"<ul> <li>Re-run quickstart from <code>README</code> against the published package.</li> <li>Validate that examples work with the released version (not local artifacts).</li> <li>Open and track a \"Post-release verification\" issue with:</li> <li>Release version</li> <li>Verification steps completed</li> <li>Any anomalies and follow-ups</li> </ul>"},{"location":"contributing/RELEASING/#11-communications","title":"11. Communications","text":"<ul> <li>Update release notes: copy highlights from the changelog with any additional context (e.g., migration notes).</li> <li>Broadcast to the project's communication channels (e.g., mailing list, forums, or chat) in a concise announcement:</li> <li>What changed</li> <li>Why it matters</li> <li>How to upgrade</li> <li>Links to docs, issues, and examples</li> </ul>"},{"location":"contributing/RELEASING/#12-hotfixes","title":"12. Hotfixes","text":"<p>When a critical issue is found post-release:</p> <ul> <li>Create a hotfix branch from the release tag.</li> <li>Apply minimal, surgical fixes with tests.</li> <li>Repeat verification and packaging steps.</li> <li>Bump PATCH version.</li> <li>Update changelog under \"Fixed\".</li> <li>Tag and publish the hotfix release.</li> </ul>"},{"location":"contributing/RELEASING/#13-backport-policy","title":"13. Backport Policy","text":"<ul> <li>Backport only critical bug fixes and security patches to previous minor versions still within support.</li> <li>Document supported versions and timelines in <code>M0</code> or a <code>SUPPORT</code> policy file.</li> <li>Clearly note backports in changelog sections corresponding to older lines.</li> </ul>"},{"location":"contributing/RELEASING/#14-release-roles-and-sign-off","title":"14. Release Roles and Sign-Off","text":""},{"location":"contributing/RELEASING/#recommended-roles","title":"Recommended Roles","text":"<ul> <li>Release Manager: coordinates the process, final sign-off</li> <li>Build/Packaging Owner: prepares and validates artifacts</li> <li>QA/Verification Owner: runs verification suite and examples</li> <li>Docs Owner: updates changelog and user docs</li> </ul>"},{"location":"contributing/RELEASING/#sign-off-checklist","title":"Sign-Off Checklist","text":"<ul> <li> Version bump and changelog updates are correct</li> <li> CI green on release commit</li> <li> Artifacts built and validated locally</li> <li> Artifacts published to registry</li> <li> Clean install from registry verified</li> <li> Examples and smoke tests pass on published bits</li> <li> Announcement ready and posted</li> <li> Post-release verification issue filed</li> </ul>"},{"location":"contributing/RELEASING/#15-troubleshooting","title":"15. Troubleshooting","text":""},{"location":"contributing/RELEASING/#common-issues","title":"Common Issues","text":"<ul> <li>Missing files in wheel/sdist: review <code>MANIFEST</code> or tooling configuration</li> <li>Version mismatch between package and docs: search/replace version strings, centralize version if possible</li> <li>Dependency leakage: isolate dev-only dependencies; confirm minimal runtime deps</li> <li>Observability regressions: ensure structured logging keys remain stable; update docs/tests where needed</li> <li>Privacy concerns: re-check redaction paths; audit error events and diagnostics instructions</li> </ul>"},{"location":"contributing/RELEASING/#16-checklists","title":"16. Checklists","text":""},{"location":"contributing/RELEASING/#minimal-release-checklist","title":"Minimal Release Checklist","text":"<ul> <li> Decide version bump (MAJOR/MINOR/PATCH)</li> <li> Update version metadata</li> <li> Update <code>CHANGELOG.md</code> and docs as needed</li> <li> Lint, type-check, test locally and in CI</li> <li> Build artifacts and perform clean install test</li> <li> Tag release and push tag</li> <li> Publish artifacts to registry</li> <li> Verify published package with examples</li> <li> Announce and open post-release verification issue</li> </ul>"},{"location":"contributing/RELEASING/#breaking-change-checklist-major-releases","title":"Breaking Change Checklist (Major Releases)","text":"<ul> <li> DR for the breaking changes merged</li> <li> Migration notes in changelog and docs</li> <li> Examples updated</li> <li> Clear communications about impact and upgrade path</li> </ul>"},{"location":"contributing/RELEASING/#references","title":"References","text":"<ul> <li>Governance and Overview</li> <li>Milestones and Plans</li> <li>Support and Troubleshooting</li> <li>Decision Records</li> </ul>"},{"location":"contributing/docs-conventions/","title":"Documentation Style Guide (DOCS_STYLE)","text":""},{"location":"contributing/docs-conventions/#introduction","title":"Introduction","text":"<p>This guide defines conventions for Meridian Runtime's documentation to ensure the content renders correctly in both GitHub and our MkDocs Material site, remains consistent, and is easy to maintain.</p>"},{"location":"contributing/docs-conventions/#scope","title":"Scope","text":"<ul> <li>Applies to all Markdown files in <code>docs/</code>.</li> <li>Complements project-wide standards in <code>CONTRIBUTING</code> and the <code>M99</code> plan.</li> <li>Use these rules for new pages and when editing existing content.</li> </ul>"},{"location":"contributing/docs-conventions/#code-blocks","title":"Code Blocks","text":"<p>Use MkDocs Material features to make examples clear, skimmable, and copy\u2011paste\u2011ready.</p>"},{"location":"contributing/docs-conventions/#languages","title":"Languages","text":"<ul> <li>Always specify a language for fenced blocks (<code>bash</code>, <code>python</code>, <code>yaml</code>, <code>toml</code>, <code>json</code>, <code>text</code>).</li> <li>Keep commands copy\u2011paste\u2011ready (no shell prompts like <code>$</code>).</li> </ul>"},{"location":"contributing/docs-conventions/#inline-code","title":"Inline Code","text":"<ul> <li>Wrap all code, commands, file paths, and data references in backticks (`) when not in code blocks.</li> <li>This includes: function names, class names, file paths, command names, configuration values, etc.</li> </ul> <p>Examples:</p> <ul> <li>Use <code>uv run python</code> instead of uv run python</li> <li>Use <code>meridian-runtime-examples/examples/sentiment/main.py</code> instead of examples/sentiment/main.py</li> <li>Use <code>MessageType.DATA</code> instead of MessageType.DATA</li> <li>Use <code>--human</code> flag instead of --human flag</li> </ul>"},{"location":"contributing/docs-conventions/#tabs-parallel-examples","title":"Tabs (parallel examples)","text":"<p>Use tabbed blocks for multi-language or platform variants.</p> BashPowerShell Bash<pre><code>uv lock\nuv sync\nuv run pytest -q\n</code></pre> PowerShell<pre><code>uv lock\nuv sync\nuv run pytest -q\n</code></pre>"},{"location":"contributing/docs-conventions/#line-numbers-and-highlights","title":"Line numbers and highlights","text":"<ul> <li>Add <code>linenums</code> for long code (&gt; ~8 lines) or when referencing specific lines.</li> <li>Use <code>hl_lines</code> to draw attention to critical lines.</li> </ul> Python<pre><code>from meridian.core.policies import Latest\n\ndef build_graph(sg):\n    # Connect producer to consumer; keep only the latest on overflow\n    sg.connect((\"producer\",\"out\"), (\"consumer\",\"in\"), capacity=16, policy=Latest())\n    return sg\n</code></pre>"},{"location":"contributing/docs-conventions/#titles-filenamecontext","title":"Titles (filename/context)","text":"<ul> <li>Use <code>title=\"path/to/file.py\"</code> to orient readers.</li> </ul> meridian-runtime-examples/examples/hello_graph/main.py<pre><code>from meridian.core import Message, MessageType\n# ...\n</code></pre>"},{"location":"contributing/docs-conventions/#collapsible-blocks","title":"Collapsible blocks","text":"<ul> <li>Collapse long, ancillary snippets (logs, full configs) with callouts.</li> </ul> Full error output (click to expand) Text Only<pre><code>&lt;REDACTED ERROR OUTPUT&gt;\n...\n</code></pre>"},{"location":"contributing/docs-conventions/#diffs-beforeafter","title":"Diffs (before/after)","text":"<ul> <li>Use <code>diff</code> fences to show changes succinctly.</li> </ul> Diff<pre><code>- sg.connect((\"prod\",\"out\"), (\"cons\",\"in\"), capacity=16)\n+ sg.connect((\"prod\",\"out\"), (\"cons\",\"in\"), capacity=16, policy=Latest())\n</code></pre>"},{"location":"contributing/docs-conventions/#commands-vs-output","title":"Commands vs output","text":"<ul> <li>Use <code>bash</code> for commands and <code>text</code> for output; label with <code>title</code> when helpful.</li> </ul> Run tests<pre><code>uv run pytest -q\n</code></pre> Expected output (abridged)<pre><code>================== test session starts ==================\ncollected 34 items\n...\n</code></pre>"},{"location":"contributing/docs-conventions/#privacy-and-safety","title":"Privacy and safety","text":"<ul> <li>Never include secrets or PII in code/output.</li> <li>Redact with <code>&lt;REDACTED&gt;</code> or placeholders like <code>PLACEHOLDER</code>, <code>TOKEN</code>, or <code>CHECKSUM(...)</code>.</li> <li>Prefer structure/log keys and counts over payload contents in examples.</li> </ul> <p>Do</p> <ul> <li>Use separate blocks when switching languages.</li> <li>Keep examples minimal and runnable.</li> </ul> <p>Don't</p> <ul> <li>Use bare ``` without a language.</li> <li>Mix multiple languages in one block.</li> </ul>"},{"location":"contributing/docs-conventions/#visual-separators","title":"Visual Separators","text":"<p>Use a consistent horizontal rule to avoid linter ambiguity and ensure portability.</p> <p>Allowed</p> <ul> <li>Three hyphens on their own line (<code>---</code>):</li> </ul> <p>Forbidden</p> <ul> <li>Triple asterisk (<code>***</code>)</li> <li>Raw HTML <code>&lt;hr&gt;</code></li> </ul> <p>Do</p> <ul> <li>Prefer headings (H2/H3) or admonitions over separators where possible.</li> <li>Use separators sparingly to break large pages into readable sections.</li> <li>Ensure blank lines around separators for clarity.</li> </ul>"},{"location":"contributing/docs-conventions/#internal-links","title":"Internal Links","text":"<p>Internal links must work in both GitHub preview and MkDocs. Use short, local relative paths from the current file.</p>"},{"location":"contributing/docs-conventions/#patterns","title":"Patterns","text":"<ul> <li>Link to pages in the same folder:   <code>./quickstart.md</code></li> <li>Link to pages in subfolders:   <code>./contributing/CONTRIBUTING.md</code></li> <li>Link to sibling pages when in subfolders:   <code>../roadmap/governance-and-overview.md</code></li> </ul>"},{"location":"contributing/docs-conventions/#anchors","title":"Anchors","text":"<ul> <li>Use GitHub/MkDocs-style heading anchors, which are case-insensitive, dashed, and stripped of punctuation:   <code>./patterns.md#backpressure-and-overflow</code></li> </ul> <p>Do</p> <ul> <li>Prefer local, relative links (<code>./</code> or <code>../</code>) rather than site-root or absolute URLs.</li> <li>Validate link targets exist and headings are accurate.</li> <li>Cross-link to canonical pages to avoid duplication (e.g., link to API for semantics definitions, Patterns for examples).</li> </ul> <p>Don't</p> <ul> <li>Use <code>../docs/</code> in links.</li> <li>Rely on <code>/absolute</code> paths that don't resolve in GitHub preview.</li> </ul>"},{"location":"contributing/docs-conventions/#headings-and-structure","title":"Headings and Structure","text":"<p>Use a single H1 at the top of each page. Keep a logical, shallow structure for scanability.</p>"},{"location":"contributing/docs-conventions/#hierarchy","title":"Hierarchy","text":"<ul> <li>H1: Page title (one per page)</li> <li>H2: Primary sections</li> <li>H3: Subsections when necessary</li> <li>Avoid going deeper than H3 unless absolutely required</li> </ul>"},{"location":"contributing/docs-conventions/#spacing-and-layout","title":"Spacing and layout","text":"<ul> <li>Ensure a blank line before and after headings.</li> <li>Keep paragraphs short and focused.</li> <li>Group related content with H2s; use separators (<code>---</code>) only when they add clarity.</li> </ul>"},{"location":"contributing/docs-conventions/#tone-and-content","title":"Tone and content","text":"<ul> <li>Lead with a concise summary.</li> <li>Prefer examples after a short explanation.</li> <li>Defer deeper narratives to linked pages to prevent duplication.</li> </ul>"},{"location":"contributing/docs-conventions/#checklists-and-lists","title":"Checklists and Lists","text":"<p>Follow GitHub Flavored Markdown (GFM) task list formatting for compatibility with MkDocs Material.</p>"},{"location":"contributing/docs-conventions/#task-lists","title":"Task lists","text":"<ul> <li>Use a single space after the brackets:<ul> <li> Item not done</li> <li> Item done</li> </ul> </li> </ul>"},{"location":"contributing/docs-conventions/#bullets-and-numbering","title":"Bullets and numbering","text":"<ul> <li>Use <code>-</code> for unordered lists.</li> <li>Use standard <code>1.</code> numbering for ordered lists (let Markdown auto-number subsequent items).</li> </ul>"},{"location":"contributing/docs-conventions/#spacing-and-indentation","title":"Spacing and indentation","text":"<ul> <li>Leave a blank line before lists if preceded by a paragraph or heading.</li> <li>Always leave a blank line before any list (bulleted or numbered) to ensure proper rendering.</li> <li>Indent nested lists by exactly four spaces per level for proper rendering.</li> <li>For multi-paragraph list items, indent subsequent paragraphs by two spaces (keep bullet/number indent at four spaces).</li> <li>For tabbed code blocks inside lists, keep the list indentation at four spaces and the tab content indented accordingly.</li> </ul> <p>Don't</p> <ul> <li>Misalign brackets or use inconsistent spacing in checklists.</li> <li>Nest checklists more than two levels deep.</li> </ul>"},{"location":"contributing/docs-conventions/#admonitions-and-callouts","title":"Admonitions and Callouts","text":"<p>Use MkDocs Material admonition syntax where helpful.</p>"},{"location":"contributing/docs-conventions/#examples","title":"Examples","text":"<p>Note</p> <p>Short clarifications or helpful context.</p> <p>Warning</p> <p>Caveats, footguns, or compatibility notes.</p> <p>Tip</p> <p>Practical advice and best practices.</p> <p>Do</p> <ul> <li>Keep admonitions concise and actionable.</li> <li>Prefer admonitions for important notices over bold inline text.</li> </ul> <p>Don't</p> <ul> <li>Overuse admonitions; they are for emphasis, not general layout.</li> </ul>"},{"location":"contributing/docs-conventions/#examples-and-snippets","title":"Examples and Snippets","text":"<p>Make examples minimal and runnable when possible.</p>"},{"location":"contributing/docs-conventions/#python","title":"Python","text":"<ul> <li>Prefer short classes and functions with clear intent.</li> <li>Show imports aligned with published API paths.</li> <li>Avoid unnecessary dependencies or setup in snippets.</li> <li>When demonstrating runtime behavior, prefer module execution style:</li> </ul> Bash<pre><code>uv run python -m examples.hello_graph.main\n</code></pre>"},{"location":"contributing/docs-conventions/#shell","title":"Shell","text":"<ul> <li>Use <code>uv</code> for all developer commands (lint, type, test).</li> <li>Avoid interactive prompts and environment-specific shortcuts.</li> </ul>"},{"location":"contributing/docs-conventions/#consistency","title":"Consistency","text":"<ul> <li>Match message/schema APIs consistently:<ul> <li><code>Message(type=MessageType.DATA, payload=...)</code></li> <li><code>PortSpec(\"in\", int)</code></li> </ul> </li> <li>Align examples with API overview and Patterns pages.</li> </ul>"},{"location":"contributing/docs-conventions/#content-hygiene-and-style","title":"Content Hygiene and Style","text":""},{"location":"contributing/docs-conventions/#language","title":"Language","text":"<ul> <li>Prefer active voice and short sentences.</li> <li>Avoid jargon; define terms once, then reuse consistently.</li> <li>Use consistent terminology: node, edge, subgraph, scheduler, message.</li> <li>Skip unnecessary fluff and focus on concise documentation to get users going quickly.</li> </ul>"},{"location":"contributing/docs-conventions/#privacy-and-safety_1","title":"Privacy and safety","text":"<ul> <li>Don't include secrets, tokens, or PII in examples.</li> <li>Redact or use placeholders for any sensitive content in logs or configs.</li> </ul>"},{"location":"contributing/docs-conventions/#maintenance","title":"Maintenance","text":"<ul> <li>Cross-link instead of duplicating content.</li> <li>Keep pages focused; split overly long pages when needed.</li> <li>Ensure headings, anchors, and links remain accurate after edits.</li> </ul>"},{"location":"contributing/docs-conventions/#page-metadata-and-navigation","title":"Page Metadata and Navigation","text":"<p>We avoid YAML front\u2011matter for standard docs pages. Page titles are the H1. Navigation is controlled by <code>mkdocs.yml</code>.</p> <p>Do</p> <ul> <li>Add new pages under <code>docs/</code> and register them in <code>mkdocs.yml</code>.</li> <li>Link new pages from <code>index.md</code> or relevant sections to make them discoverable.</li> </ul> <p>Don't</p> <ul> <li>Add front\u2011matter at the top of docs pages unless explicitly needed for a special plugin.</li> </ul>"},{"location":"contributing/docs-conventions/#review-checklist-authors-quick-pass","title":"Review Checklist (Author's Quick Pass)","text":"<ul> <li> One H1 at top; heading hierarchy is H2/H3 and consistent</li> <li> All code fences have language tags</li> <li> No <code>***</code> separators in content (use <code>---</code>)</li> <li> Internal links are relative and valid in GitHub and MkDocs</li> <li> Examples are minimal, correct, and copy\u2011paste\u2011able</li> <li> Admonitions (if any) are valid and justified</li> <li> No secrets, PII, or sensitive payloads in examples</li> <li> Page cross-links to canonical references (Quickstart, API, Patterns, Observability, Troubleshooting)</li> </ul>"},{"location":"contributing/docs-conventions/#references","title":"References","text":"<ul> <li>MkDocs Material</li> <li>GitHub Flavored Markdown (GFM)</li> <li>Project Quickstart</li> <li>API Overview</li> <li>Patterns</li> <li>Observability</li> <li>Troubleshooting</li> </ul> <p>By following these conventions, we keep Meridian Runtime's docs predictable, readable, and contributor\u2011friendly across GitHub and the generated site.</p>"},{"location":"contributing/guide/","title":"Contributing to Meridian Runtime","text":""},{"location":"contributing/guide/#introduction","title":"Introduction","text":"<p>Thanks for your interest in Meridian Runtime! This document explains how to set up your environment, follow our standards, and propose changes. Meridian is a composable, asyncio-native, graph runtime created by GhostWeasel. We aim for clarity, predictability, and a strong developer experience.</p> <p>Tip</p> <p>New to Meridian? Start with the Getting Started Guide and API Reference to understand the core concepts before diving into development.</p>"},{"location":"contributing/guide/#quick-links","title":"Quick links","text":"<ul> <li>Governance and overview</li> <li>Milestones and plans</li> <li>How to report issues</li> <li>Troubleshooting</li> <li>CI triage and ownership</li> <li>Docs style guide</li> </ul> <p>Note</p> <p>By contributing, you agree to follow our Code of Conduct (CoC) and project governance in M0.</p>"},{"location":"contributing/guide/#goals","title":"Project Goals and Principles","text":"<ul> <li>Composable first: nodes, edges, and subgraphs with clear boundaries</li> <li>Async\u2011native: Python 3.11+, asyncio\u2011friendly code</li> <li>Predictable execution: fairness, backpressure, bounded edges</li> <li>Observability: structured logs, metrics, optional tracing</li> <li>Privacy\u2011first: no payloads in errors by default; redaction hooks</li> <li>Maintainability: small, testable modules (~200 lines/file guidance)</li> <li>Platform\u2011agnostic: no assumptions about specific hosting services</li> <li>Docs\u2011as\u2011product: plans, support docs, and examples are first\u2011class</li> </ul>"},{"location":"contributing/guide/#environment","title":"Prerequisites and Environment Setup","text":""},{"location":"contributing/guide/#environment_1","title":"Environment","text":"<ul> <li>Python: 3.11+</li> <li>Package manager: <code>uv</code></li> <li>Linting/formatting: <code>ruff</code> + <code>black</code></li> <li>Type checking: <code>mypy</code></li> <li>Tests: <code>pytest</code> (+ coverage)</li> </ul>"},{"location":"contributing/guide/#local-setup","title":"Local setup","text":"<ol> <li> <p>Install Python 3.11+.</p> </li> <li> <p>Install <code>uv</code>:</p> <ul> <li>See astral-sh/uv for installation instructions.</li> </ul> </li> <li> <p>Clone the repository:</p> Bash<pre><code>git clone &lt;repo-url&gt;\ncd meridian-runtime\n</code></pre> </li> <li> <p>Create and activate a virtual environment</p> <ul> <li><code>uv</code> manages a venv automatically for most commands; manual activation is also fine.</li> </ul> </li> <li> <p>Install dependencies (managed by <code>uv</code> via <code>pyproject.toml</code>):</p> Bash<pre><code>uv lock\nuv sync\n</code></pre> </li> <li> <p>Verify setup:</p> Bash<pre><code>uv --version\nuv run ruff --version\nuv run black --version\nuv run mypy --version\nuv run pytest --version\n</code></pre> </li> </ol>"},{"location":"contributing/guide/#pre-commit-recommended","title":"Pre-commit (recommended)","text":"<ol> <li> <p>Install pre-commit:</p> Bash<pre><code>uv run pip install pre-commit\npre-commit install\npre-commit install --hook-type pre-push\n</code></pre> </li> <li> <p>Run on all files once:</p> Bash<pre><code>pre-commit run --all-files\n</code></pre> </li> <li> <p>Hooks configured:</p> <ul> <li><code>Ruff</code> (lint with autofix) + <code>Ruff</code> formatter</li> <li><code>Black</code></li> <li>EOF fixer, trailing whitespace, YAML/TOML checks</li> <li><code>markdownlint</code> (docs style)</li> <li>docs: no bare code fences (fails on ```` with no language)</li> <li>docs: visual separators \u2014 use only <code>---</code>; forbid <code>***</code> and <code>&lt;hr&gt;</code></li> <li>docs: link check (internal\u2011only via <code>lychee</code>)</li> </ul> </li> </ol> <p>This ensures consistent style locally and prevents CI churn.</p>"},{"location":"contributing/guide/#ci-parity-run-what-ci-runs","title":"CI parity (run what CI runs)","text":"Run lint<pre><code>uv run ruff check .\n</code></pre> Run formatting check<pre><code>uv run black --check .\n</code></pre> Run type check<pre><code>uv run mypy src\n</code></pre> Run tests with coverage gate<pre><code>uv run pytest --cov=src --cov-fail-under=80\n</code></pre> Generate coverage XML (80% gate matches CI)<pre><code>uv run pytest --cov=src --cov-report=xml:coverage.xml --cov-fail-under=80\n</code></pre>"},{"location":"contributing/guide/#install-lychee-optional","title":"Install lychee (optional)","text":"Install lychee (via cargo)<pre><code># Using cargo (recommended)\ncargo install lychee\n# Verify\nlychee --version\n</code></pre> <p>Note</p> <p>If <code>lychee</code> is not installed, the docs link\u2011check pre\u2011commit hook may fail locally; install it or skip with:</p> Skip docs link check (local only)<pre><code>SKIP=docs-lychee-internal pre-commit run --all-files\n</code></pre>"},{"location":"contributing/guide/#packaging-optional","title":"Packaging (optional)","text":"Build package<pre><code>uv build\n</code></pre> <p>Run a subset of tests:</p> Run a specific test<pre><code>uv run pytest -q tests/path::TestClass::test_method\n</code></pre> <p>Info</p> <p>Some commands may be wrapped by scripts in <code>scripts/</code> to ensure consistent options. Prefer those if present.</p>"},{"location":"contributing/guide/#layout","title":"Repository Layout","text":"<ul> <li><code>src/meridian/*</code>: runtime and library code</li> <li><code>tests/*</code>: unit, integration, and property\u2011based tests</li> <li><code>meridian-runtime-examples/examples/*</code>: runnable examples and recipes</li> <li><code>docs/roadmap/*</code>: milestone plans and decision records</li> <li><code>docs/contributing/*</code>: this guide and release process</li> <li><code>docs/support/*</code>: issue reporting, troubleshooting, and templates</li> <li><code>scripts/*</code>: helper scripts for lint/type\u2011check/test/release</li> </ul>"},{"location":"contributing/guide/#standards","title":"Development Standards","text":""},{"location":"contributing/guide/#language-and-apis","title":"Language and APIs","text":"<ul> <li>Target Python 3.11+ features only.</li> <li>Prefer explicitness over magic; avoid global mutable state.</li> <li>Keep modules small and cohesive; favor SRP (single responsibility).</li> <li>Keep public APIs minimal, consistent, and carefully named.</li> <li>Document public APIs with clear docstrings and examples where appropriate.</li> </ul>"},{"location":"contributing/guide/#async-and-concurrency","title":"Async and concurrency","text":"<ul> <li>Prefer <code>async def</code> where applicable; avoid blocking calls in async contexts.</li> <li>If blocking is necessary, isolate and document it with appropriate adapters/executors.</li> <li>Enforce bounded edges and explicit backpressure policies (<code>Block</code>, <code>Drop</code>, <code>Latest</code>, <code>Coalesce</code>). See: API Reference: Backpressure and Overflow</li> <li>Separate control plane operations from data plane work (control takes priority).</li> </ul>"},{"location":"contributing/guide/#observability-and-privacy","title":"Observability and privacy","text":"<ul> <li>Use structured logging with stable keys. Avoid <code>print</code> in library code.</li> <li>Emit metrics via thin interfaces; keep adapters optional.</li> <li>Error events must not include payload contents by default.</li> <li>Support redaction hooks and scrub potential secrets/PII.</li> </ul>"},{"location":"contributing/guide/#testing-and-quality","title":"Testing and quality","text":"<ul> <li>Write tests alongside code changes (unit + integration where relevant).</li> <li>Aim for \u2265 80% coverage on critical modules and \u2265 70% overall (risk\u2011based exceptions documented).</li> <li>Keep tests deterministic; avoid sleeping where possible\u2014use clocks/mocks/fakes.</li> <li>Add regression tests for bug fixes.</li> <li>Maintain type hints; pass <code>mypy</code> with the project configuration.</li> <li>Keep code formatted and linted; pass <code>ruff</code> and CI checks locally before opening a PR.</li> </ul>"},{"location":"contributing/guide/#documentation","title":"Documentation","text":"<ul> <li>Update docs for any user\u2011visible change.</li> <li>Provide examples or recipes when adding notable features.</li> <li>Keep <code>README</code> concise with pointers to deeper docs.</li> </ul>"},{"location":"contributing/guide/#workflow","title":"Branching, Commits, and PRs","text":""},{"location":"contributing/guide/#branching","title":"Branching","text":"<ul> <li>Use feature branches from the <code>main</code> branch.</li> <li>Keep changes scoped and reviewable. Split large work into logical commits and PRs.</li> </ul>"},{"location":"contributing/guide/#commit-messages","title":"Commit messages","text":"<ul> <li>Use clear, imperative tense: \"Add X\", \"Fix Y\", \"Refactor Z\".</li> <li>Reference issues or decision records where relevant.</li> <li>Include context in the body if the change is non\u2011trivial.</li> </ul>"},{"location":"contributing/guide/#pull-requests","title":"Pull requests","text":"<ul> <li>Describe the problem, solution, alternatives considered, and risk.</li> <li>Include tests and docs updates.</li> <li>Note any breaking change and migration notes.</li> <li>Ensure CI passes (lint, type, tests, packaging).</li> <li>For significant API changes, link to an RFC/Decision Record in <code>docs/roadmap/dr</code>.</li> </ul>"},{"location":"contributing/guide/#review-process","title":"Review process","text":"<ul> <li>Expect at least one maintainer review. For sensitive changes (scheduling, error handling, privacy), request an additional reviewer.</li> <li>Address comments via follow\u2011up commits; prefer small, targeted updates.</li> <li>Squash or rebase as needed to keep history clean.</li> </ul>"},{"location":"contributing/guide/#dr","title":"Decision Records and RFCs","text":""},{"location":"contributing/guide/#when-to-write-one","title":"When to write one","text":"<ul> <li>Public API changes or deprecations</li> <li>Scheduler policies, fairness strategies, or performance\u2011sensitive modifications</li> <li>Error/diagnostics schema changes and redaction policies</li> <li>Persistence adapters, replay/log formats, visual inspector protocols</li> </ul>"},{"location":"contributing/guide/#what-to-include","title":"What to include","text":"<ul> <li>Motivation and scope</li> <li>Design options and trade\u2011offs</li> <li>Chosen approach and rationale</li> <li>Migration or compatibility notes</li> <li>Links to issues/PRs and related docs</li> </ul>"},{"location":"contributing/guide/#location","title":"Location","text":"<ul> <li><code>docs/roadmap/dr/&lt;YYYY-MM-DD&gt;-short-title.md</code></li> </ul>"},{"location":"contributing/guide/#testing","title":"Testing Guidance","text":"<ul> <li>Unit tests: Focus on behavior, boundaries, and edge/backpressure policies.</li> <li>Integration tests: Exercise realistic node/edge/scheduler flows.</li> <li>Property\u2011based tests (optional): Use where invariants are essential (e.g., fairness guarantees).</li> <li>Fixtures: Provide minimal, composable fixtures for runtime/scheduler setup.</li> <li>Logging/metrics in tests: Use structured assertions or capture context; avoid coupling to specific backends.</li> <li>Performance checks: Add micro\u2011benchmarks for hot paths where feasible (non\u2011blocking in CI).</li> </ul>"},{"location":"contributing/guide/#security","title":"Security maintenance","text":""},{"location":"contributing/guide/#codeql","title":"CodeQL","text":"<p>We run code scanning on PRs and <code>main</code>. If CodeQL flags an alert on your PR, review the alert details in the Security tab and fix or justify with a link to the relevant discussion/issue. </p> <p>Prefer fixing in the same PR when low\u2011risk; otherwise, open a follow\u2011up with a short timeline.</p>"},{"location":"contributing/guide/#dependabot","title":"Dependabot","text":"<p>Weekly PRs may update GitHub Actions, Python packages, or docs tooling. Review the changelog, ensure CI is green, and prefer merging patch/minor bumps. </p> <p>For major updates, open an issue or small PR to validate impact. Keep dependency PRs focused (one tool/stack at a time when possible).</p>"},{"location":"contributing/guide/#observability","title":"Observability, Errors, and Diagnostics","text":""},{"location":"contributing/guide/#log-structure","title":"Log structure","text":"<ul> <li>Prefer <code>event = \"node_started\"</code>, <code>node_id</code>, <code>graph_id</code>, etc.</li> </ul>"},{"location":"contributing/guide/#metrics","title":"Metrics","text":"<ul> <li>Stable names, low label cardinality, adapters optional.</li> </ul>"},{"location":"contributing/guide/#errors","title":"Errors","text":"<ul> <li>Do not include payload contents by default; attach metadata only.</li> </ul>"},{"location":"contributing/guide/#diagnostics","title":"Diagnostics","text":"<ul> <li>A future CLI command <code>meridian diagnostics collect</code> will generate redacted bundles. Until then, follow How to Report Issues and Troubleshooting for safe data sharing.</li> </ul>"},{"location":"contributing/guide/#privacy","title":"Privacy","text":"<ul> <li>Never log secrets, tokens, or PII.</li> <li>Apply redaction hooks before emitting logs/diagnostics.</li> <li>Treat diagnostics bundles as sensitive; ensure anonymization and scrubbing where applicable.</li> <li>Follow the principle of least privilege for configuration and environment access.</li> </ul>"},{"location":"contributing/guide/#releasing","title":"Releasing","text":"<ul> <li>Follow RELEASING.md for:<ul> <li>Versioning (SemVer)</li> <li>Changelog updates</li> <li>Tagging and packaging</li> </ul> </li> <li>Release verification (examples repo tests)</li> <li>Any public API change must include release notes and migration steps.</li> </ul>"},{"location":"contributing/guide/#help","title":"Getting Help","text":"<ul> <li>For how to report issues and request features: How to Report Issues</li> <li>For common problems: Troubleshooting</li> <li>For templates: Support Templates</li> <li>If you're blocked by a decision or unclear policy, open a discussion or small PR to propose a path forward and request maintainer guidance.</li> </ul>"},{"location":"contributing/guide/#coc","title":"Code of Conduct","text":"<p>All contributors and maintainers must follow our CoC. Be respectful, constructive, and collaborative. Report violations through the project's designated channels.</p>"},{"location":"contributing/guide/#pr-checklist","title":"Checklist Before Opening a PR","text":"<ul> <li> Code compiles and passes tests locally</li> <li> <code>uv run ruff check .</code></li> <li> <code>uv run black --check .</code></li> <li> <code>uv run mypy src</code> passes (or narrow, justified suppressions)</li> <li> <code>uv run pytest --cov=src --cov-fail-under=80</code> passes locally (coverage gate \u226580% overall)</li> <li> Tests added/updated, including regression tests if fixing a bug</li> <li> Docs updated (<code>README</code>, examples, or deeper docs as needed)</li> <li> No payload contents in error events or logs; redaction applied where appropriate</li> <li> Linked to issue(s) and/or Decision Record for significant changes</li> <li> Scoped, reviewable commits with clear messages</li> </ul>"},{"location":"contributing/guide/#ideas","title":"Awesome Contribution Ideas","text":"<p>Looking for inspiration? Here are some areas where contributions are especially welcome:</p>"},{"location":"contributing/guide/#high-impact-low-complexity","title":"High Impact, Low Complexity","text":"<ul> <li>Documentation improvements: Fix typos, clarify examples, add missing sections</li> <li>Test coverage: Add tests for edge cases or improve existing test quality</li> <li>Example enhancements: Create new examples or improve existing ones</li> <li>CI/CD improvements: Optimize build times, add new checks, improve reliability</li> </ul>"},{"location":"contributing/guide/#developer-experience","title":"Developer Experience","text":"<ul> <li>Error messages: Make error messages more helpful and actionable</li> <li>Debugging tools: Add better debugging capabilities or observability features</li> <li>CLI enhancements: Improve the developer CLI experience</li> <li>IDE support: Add better IDE integration or tooling</li> </ul>"},{"location":"contributing/guide/#performance-reliability","title":"Performance &amp; Reliability","text":"<ul> <li>Benchmarks: Add performance benchmarks for critical paths</li> <li>Memory optimization: Identify and fix memory leaks or inefficiencies</li> <li>Concurrency improvements: Enhance fairness, reduce contention</li> <li>Edge case handling: Improve robustness for unusual scenarios</li> </ul>"},{"location":"contributing/guide/#observability-monitoring","title":"Observability &amp; Monitoring","text":"<ul> <li>Metrics: Add new metrics for better monitoring</li> <li>Logging: Improve structured logging and error reporting</li> <li>Tracing: Enhance distributed tracing capabilities</li> <li>Diagnostics: Build better diagnostic tools</li> </ul>"},{"location":"contributing/guide/#security-privacy","title":"Security &amp; Privacy","text":"<ul> <li>Security audits: Review code for security vulnerabilities</li> <li>Privacy enhancements: Improve data redaction and privacy features</li> <li>Access control: Add better access control mechanisms</li> <li>Audit logging: Enhance audit trail capabilities</li> </ul> <p>Tip</p> <p>Not sure where to start? Check the Issues page for labeled \"good first issue\" or \"help wanted\" items, or ask in discussions!</p> <p>Thank you for helping build Meridian Runtime! \ud83c\udf89</p>"},{"location":"contributing/templates/adr-template/","title":"Architecture Decision Record (ADR) Template","text":"<p>Status One of: proposed | accepted | rejected | superseded | deprecated | withdrawn</p> <p>ADR ID and title Use incremental numbering or date-based IDs plus a short, lowercase-kebab-case title. Example: ADR-0007-prefer-async-io</p> <p>Context What is the problem we\u2019re trying to solve and why now? - Background and business/technical drivers - Constraints and assumptions - Related systems, components, or stakeholders - Prior decisions this depends on</p> <p>Decision The decision we made, stated clearly and unambiguously. - What we will do - What we will not do - Scope (what\u2019s included/excluded)</p> <p>Rationale Why we chose this option over alternatives. - Evaluation criteria (e.g., performance, complexity, risk, cost, operability) - Trade-offs considered - Links to benchmarks, experiments, prototypes</p> <p>Alternatives considered List serious options and why they were not chosen. - Alternative A   - Pros   - Cons   - Why not chosen - Alternative B   - Pros   - Cons   - Why not chosen</p> <p>Consequences What happens because of this decision. - Positive outcomes (benefits, simplifications) - Negative outcomes (costs, new risks, limitations) - Impact on teams, processes, tooling - Operational considerations (observability, performance, reliability) - Security and privacy implications</p> <p>Technical details Concise but concrete technical notes to implement and operate the decision. - Interfaces/APIs and schema impacts - Migration approach (data, code, config) - Backward/forward compatibility - Tuning and capacity planning notes - Testing strategy (unit, integration, performance) - Rollout plan and safeguards (feature flags, canary, rollback)</p> <p>Open questions and follow-ups Known unknowns and tasks that must be done. - Unresolved questions - Follow-up ADRs expected - Issues/tickets created</p> <p>Decision owner and reviewers - Owner: person or role accountable - Reviewers: key stakeholders who approved - Inputs from: optional contributors consulted</p> <p>References Links to relevant materials. - Related ADRs - Design docs, issues, PRs - External references (standards, libraries, blog posts)</p> <p>Changelog Track notable updates to this ADR. - YYYY-MM-DD: Short note about what changed</p> <p>Metadata - Created: YYYY-MM-DD - Last updated: YYYY-MM-DD - Status: proposed | accepted | rejected | superseded | deprecated | withdrawn - Supersedes: ADR-XXXX-title (if applicable) - Superseded by: ADR-YYYY-title (if applicable) - Tags: [architecture, performance, security, observability, api, storage, ops]</p> <p>Authoring guidance - Be brief but complete\u2014optimize for decision clarity, not exhaustive prose. - Prefer diagrams when they clarify complex flows. - Record the decision now; you can refine technical details as they stabilize. - Keep titles and filenames in lowercase-kebab-case. - One decision per ADR; compose via references if necessary. - If this ADR changes user-facing behavior or public APIs, link to docs PRs and migration guides.</p>"},{"location":"contributing/templates/guide-template/","title":"Guide template","text":"<p>Summary A short 1\u20132 sentence overview of what this guide helps you accomplish and who it\u2019s for.</p> <p>Example: This guide shows you how to deploy Meridian Runtime to your staging environment using Docker Compose. It\u2019s intended for developers familiar with Docker and basic CLI usage.</p> <p>Audience State the expected reader background and prerequisites at a glance.</p> <ul> <li>Intended for: e.g., backend engineers, SREs, contributors</li> <li>Assumes: basic Python, Docker, and Unix shell familiarity</li> </ul> <p>Goals List the concrete outcomes the reader will achieve.</p> <ul> <li>Deploy a minimal Meridian graph locally</li> <li>Enable structured logs and metrics</li> <li>Verify health and graceful shutdown</li> </ul> <p>Non-goals Clarify what this guide will not cover to prevent scope creep.</p> <ul> <li>Production hardening</li> <li>Cloud-specific IaC (Terraform, CloudFormation)</li> <li>Deep dive into the scheduler</li> </ul> <p>Prerequisites What the reader needs before starting (tools, access, versions).</p> <ul> <li>Python 3.11+</li> <li>uv installed (or pip)</li> <li>Docker Desktop (optional for this guide)</li> <li>Repo cloned and dependencies installed</li> </ul> <p>Before you begin Short setup steps to put the reader in a ready state.</p> <p>1) Clone and install dependencies Bash<pre><code>git clone https://github.com/GhostWeaselLabs/meridian-runtime.git\ncd meridian-runtime\nuv sync\n</code></pre></p> <p>2) Run unit tests to ensure the environment is healthy Bash<pre><code>uv run pytest -q\n</code></pre></p> <p>High-level overview Provide a brief conceptual framing of what will happen and why. Use a diagram if helpful.</p> <pre><code>flowchart LR\n  A[Source] --&gt; B[Node]\n  B --&gt; C[Edge: typed + bounded]\n  C --&gt; D[Sink]\n  D --&gt; E[Observability: logs + metrics]</code></pre> <p>Steps Numbered, actionable steps with commands and expected output. Each step should be testable and verifiable.</p> <p>1) Start the example graph Bash<pre><code>uv run python -m examples.hello_graph.main\n</code></pre> Expected output (abridged): Text Only<pre><code>INFO scheduler Started\nINFO node.hello Initialized\nINFO node.hello Processed 10 messages\n</code></pre></p> <p>2) Enable structured logging Explain where to enable and what to expect. Link to reference if applicable.</p> <p>3) Expose metrics endpoint Explain configuration, port, and how to curl it: Bash<pre><code>curl -s localhost:8000/metrics | head\n</code></pre></p> <p>Validation How the reader confirms success.</p> <ul> <li>Logs include node lifecycle events (init, process, shutdown)</li> <li>Metrics endpoint returns non-empty payload with counters/gauges</li> <li>CTRL+C exits cleanly within N seconds</li> </ul> <p>Troubleshooting Known failure modes with symptoms and remedies. Link to the broader troubleshooting page for more.</p> <ul> <li>Port already in use \u2192 change METRICS_PORT or stop conflicting service</li> <li>Missing dependencies \u2192 re-run <code>uv sync</code>, verify Python version</li> </ul> <p>Performance and scalability notes Optional: any guidance on limits, tunables, or costs of this approach.</p> <ul> <li>Increase queue bounds for bursty inputs</li> <li>Prefer backpressure over drop when correctness matters</li> </ul> <p>Security and compliance notes Optional: mention secrets handling, PII, and logging policies.</p> <ul> <li>Avoid logging payloads that contain PII; log IDs and metadata only</li> </ul> <p>Cleanup How to tear down any resources. Bash<pre><code># Stop processes\npkill -f hello_graph.main || true\n# Remove local artifacts if any\nrm -rf .cache\n</code></pre></p> <p>Next steps Curated links to continue the journey.</p> <ul> <li>Quickstart: ../getting-started/quickstart.md</li> <li>Patterns: ../concepts/patterns.md</li> <li>API reference: ../reference/api.md</li> <li>Observability: ../concepts/observability.md</li> </ul> <p>Appendix: Template guidance for authors Keep guides focused on a single task and time-bound (&lt;15 minutes). Split large topics into multiple guides. Prefer copy-pasteable commands and show expected output snippets. Use relative links and keep filenames in lowercase-kebab-case. Headings use sentence case; proper nouns keep their capitalization.</p> <p>Metadata (optional) Add a small front matter block when useful for surfaced metadata.</p> <p>owner: docs@your-org last_updated: YYYY-MM-DD est_read_time: 10m status: stable tags: [guide, getting-started]</p>"},{"location":"contributing/templates/reference-template/","title":"Reference template","text":"<p>Summary Provide a 1\u20132 sentence description of what this reference covers and who should use it. This page is the definitive, authoritative source for a specific surface area (API, CLI, configuration, schema, etc.). Keep it factual and exhaustive; move tutorials to guides.</p> <p>Scope - What\u2019s included: brief bullets - What\u2019s not included: brief bullets (link to other references if applicable)</p> <p>Versioning - Since: vX.Y.Z - Last updated: YYYY-MM-DD - Stability: stable | experimental | deprecated</p>"},{"location":"contributing/templates/reference-template/#overview","title":"Overview","text":"<p>A concise explanation of the component being documented (API surface, module, CLI, config). State core concepts the reader must know to understand the reference. Link to overview docs for deeper conceptual material.</p> <p>Quick links - How-to guide: ../guides/.md - Concepts: ../concepts/.md - Examples: ../examples/index.md (code in external <code>meridian-runtime-examples</code> repository)"},{"location":"contributing/templates/reference-template/#usage-at-a-glance","title":"Usage at a glance","text":"<p>Short, copy-pasteable example(s) demonstrating common usage.</p> Bash<pre><code># Example: CLI invocation\nmeridian runtime --config config.toml --log-level info\n</code></pre> Python<pre><code># Example: Python API\nfrom meridian import Runtime, Node\nrt = Runtime()\n# ...\nrt.start()\n</code></pre>"},{"location":"contributing/templates/reference-template/#terminology","title":"Terminology","text":"<p>Define important terms as they are used in this reference. - Term A: definition - Term B: definition</p>"},{"location":"contributing/templates/reference-template/#specification","title":"Specification","text":"<p>Provide the exhaustive, authoritative details. Prefer structured, scannable sections. Use stable ordering (alphabetical or logical).</p>"},{"location":"contributing/templates/reference-template/#endpoints-commands-objects","title":"Endpoints / Commands / Objects","text":"<p>For each item, use the following pattern.</p> <p>Name A short, descriptive title (e.g., create_graph, runtime start, config.runtime).</p> <p>Description One or two sentences describing the behavior and purpose.</p> <p>Signature - Function/method signature or CLI syntax. - HTTP method and path for REST, or fields for schemas.</p> <p>Parameters/Options List each parameter/flag with: - Name (type) \u2013 required? default? - Description - Constraints (allowed values, ranges, regex, size) - Notes (security, performance, side effects)</p> <p>Request/Body (if applicable) - Shape and example</p> <p>Response/Output (if applicable) - Shape and example - Error conditions and codes</p> <p>Examples - Minimal working example - A realistic example with comments</p> <p>Notes - Edge cases, caveats, ordering guarantees, idempotency, timeouts</p> <p>Repeat this subsection per endpoint/command/object.</p> <p>Example format:</p>"},{"location":"contributing/templates/reference-template/#runtimestart","title":"runtime.start","text":"<p>Description Starts the scheduler and all registered nodes, enabling message processing.</p> <p>Signature Python<pre><code>Runtime.start(block: bool = False) -&gt; None\n</code></pre></p> <p>Parameters - block (bool) \u2013 optional, default: False   - If True, blocks the current thread until shutdown.</p> <p>Behavior - Initializes nodes in dependency order. - Fails fast if any node fails to initialize.</p> <p>Errors - RuntimeError \u2013 when already started - NodeInitError \u2013 when any node fails to initialize</p> <p>Example Python<pre><code>rt = Runtime()\nrt.register_node(hello_node)\nrt.start(block=False)\n</code></pre></p>"},{"location":"contributing/templates/reference-template/#configuration-reference","title":"Configuration reference","text":"<p>If this reference covers configuration, provide a single source of truth table with defaults.</p> <p>Format: TOML/YAML/JSON example</p> TOML<pre><code>[runtime]\nlog_level = \"info\"   # one of: trace, debug, info, warn, error\nmetrics_port = 8000  # 0 to disable\n</code></pre> <p>Settings - runtime.log_level (string) \u2013 default: \"info\"   - Allowed: trace|debug|info|warn|error   - Notes: higher verbosity impacts performance - runtime.metrics_port (int) \u2013 default: 8000   - 0 disables metrics server</p>"},{"location":"contributing/templates/reference-template/#errors-and-diagnostics","title":"Errors and diagnostics","text":"<p>List all errors with meanings and likely root causes. Include remediation guidance.</p> <ul> <li>NodeInitError</li> <li>Meaning: Node failed during initialization</li> <li>Causes: misconfiguration, missing dependency</li> <li> <p>Remediation: check node logs; verify required environment variables</p> </li> <li> <p>BackpressureTimeout</p> </li> <li>Meaning: Message enqueue timed out due to bounded queue</li> <li>Remediation: adjust queue size or producer rate</li> </ul>"},{"location":"contributing/templates/reference-template/#performance-characteristics","title":"Performance characteristics","text":"<ul> <li>Complexity: O(...) for critical operations</li> <li>Latency implications: startup, steady state</li> <li>Memory/CPU considerations</li> <li>Tuning knobs: which settings affect performance and how</li> </ul>"},{"location":"contributing/templates/reference-template/#security-considerations","title":"Security considerations","text":"<ul> <li>Authentication/authorization requirements (if any)</li> <li>Sensitive data handling (PII, secrets)</li> <li>Logging guidelines (avoid payloads; prefer IDs/metadata)</li> <li>Network exposure and port usage</li> </ul>"},{"location":"contributing/templates/reference-template/#compatibility-and-constraints","title":"Compatibility and constraints","text":"<ul> <li>Supported platforms and versions</li> <li>Backward/forward compatibility guarantees</li> <li>Thread-safety and reentrancy</li> <li>Limits (max nodes, max edges, payload size)</li> </ul>"},{"location":"contributing/templates/reference-template/#deprecations","title":"Deprecations","text":"<p>List deprecated items with: - Since version - Replacement - Removal timeline - Migration guidance</p>"},{"location":"contributing/templates/reference-template/#changelog","title":"Changelog","text":"<p>Capture notable changes to this surface (link to repo changelog for full history). - vX.Y.Z: Short description - vX.Y.(Z-1): Short description</p>"},{"location":"contributing/templates/reference-template/#appendix","title":"Appendix","text":"<ul> <li>Schema definitions (if large)</li> <li>Type mappings</li> <li>Additional examples</li> </ul> <p>Authoring guidance for maintainers - Keep reference pages exhaustive but non-tutorial. - Prefer stable ordering and consistent headings across items. - Mark experimental features clearly and include stability notes. - Update examples whenever signatures or outputs change. - Keep examples runnable and minimal; link to guides for context.</p> <p>Metadata owner: docs@your-org last_updated: YYYY-MM-DD status: stable tags: [reference]</p>"},{"location":"dev/examples-migration/","title":"Examples &amp; Notebooks Migration Runbook","text":"<p>This document describes a safe procedure to migrate <code>examples/</code> and <code>notebooks/</code> into a dedicated repository while preserving history.</p>"},{"location":"dev/examples-migration/#prerequisites","title":"Prerequisites","text":"<ul> <li>Clean working tree in <code>meridian-runtime</code></li> <li>New empty repository created, e.g. <code>GhostWeaselLabs/meridian-runtime-examples</code></li> <li>Obtain its Git URL (SSH or HTTPS)</li> </ul>"},{"location":"dev/examples-migration/#backup-and-dry-run","title":"Backup and dry run","text":"Text Only<pre><code># Create an anchor tag and archive current trees\nuv run python scripts/migration_backup.py --paths examples notebooks\n\n# Dry run the split and push to verify commands\nuv run python scripts/migrate_with_history.py --remote-name examples-origin --remote-url git@github.com:GhostWeaselLabs/meridian-runtime-examples.git\n</code></pre>"},{"location":"dev/examples-migration/#execute","title":"Execute","text":"<p>Once validated, run with <code>--no-dry-run</code>:</p> Text Only<pre><code>uv run python scripts/migrate_with_history.py --remote-name examples-origin --remote-url git@github.com:GhostWeaselLabs/meridian-runtime-examples.git --no-dry-run\n</code></pre> <p>This will: - Create subtree splits for <code>examples/</code> and <code>notebooks/</code> - Push the split history to the target repository <code>main</code> branch - Clean up local split branches</p>"},{"location":"dev/examples-migration/#post-migration","title":"Post-migration","text":"<ul> <li>Verify history in the new repository</li> <li>Open PRs to remove <code>examples/</code> and <code>notebooks/</code> from the main repo</li> <li>Update documentation links and add migration notes</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Examples moved</p> <p>Examples and notebooks now live in the separate public repository <code>meridian-runtime-examples</code>. Clone it to run examples locally: <code>https://github.com/GhostWeaselLabs/meridian-runtime-examples</code>.</p> <p>Welcome to the Meridian Runtime example gallery. Each example is a real, runnable program in the external examples repository, designed to show off core capabilities of the runtime with real dataflow, backpressure, and observability. Copy, run, and adapt.</p>","tags":["examples","demos"]},{"location":"examples/#minimal-hello-world","title":"Minimal Hello World","text":"<p>What it demonstrates:</p> <ul> <li>The absolute basics: how to wire up two nodes, send integer messages, and see output.</li> <li>Shows the core API: <code>Node</code>, <code>Subgraph</code>, <code>Scheduler</code>, typed ports, and bounded edges.</li> </ul> <p>Why it matters:</p> <ul> <li>If you can run this, your install works. If you can extend it, you understand the core.</li> </ul> <p>How to run: Bash<pre><code>git clone https://github.com/GhostWeaselLabs/meridian-runtime-examples.git\ncd meridian-runtime-examples\npython examples/minimal_hello/main.py\n</code></pre></p> <p>Detailed documentation: Minimal Hello</p>","tags":["examples","demos"]},{"location":"examples/#hello-graph","title":"Hello Graph","text":"<p>What it demonstrates:</p> <ul> <li>Modular design with separate producer and consumer modules.</li> <li>Comprehensive logging with contextual fields and metadata.</li> <li>Proper project structure for complex applications.</li> </ul> <p>Why it matters:</p> <ul> <li>Shows how to organize complex Meridian applications with proper separation of concerns.</li> <li>Demonstrates production-ready code organization and observability integration.</li> </ul> <p>How to run: Bash<pre><code>git clone https://github.com/GhostWeaselLabs/meridian-runtime-examples.git\ncd meridian-runtime-examples\npython examples/hello_graph/main.py\n</code></pre></p> <p>Detailed documentation: Hello Graph</p>","tags":["examples","demos"]},{"location":"examples/#sentiment-pipeline","title":"Sentiment Pipeline","text":"<p>What it demonstrates:</p> <ul> <li>Real-time text processing pipeline with control-plane preemption and mixed edge capacities.</li> <li>Five nodes: <code>IngestNode</code>, <code>TokenizeNode</code>, <code>SentimentNode</code>, <code>ControlNode</code>, <code>SinkNode</code>.</li> <li>Shows priorities, bounded queues, observability, and graceful shutdown.</li> </ul> <p>Why it matters:</p> <ul> <li>Demonstrates how control messages (like mode changes or flush) can preempt heavy data-plane load.</li> <li>Shows how to wire up a non-trivial, multi-node graph with both data and control edges.</li> </ul> <p>How to run: Bash<pre><code>git clone https://github.com/GhostWeaselLabs/meridian-runtime-examples.git\ncd meridian-runtime-examples\npython examples/sentiment/main.py --human --timeout-s 6.0\n</code></pre></p> <p>Detailed documentation: Sentiment Pipeline</p>","tags":["examples","demos"]},{"location":"examples/#streaming-coalesce","title":"Streaming Coalesce","text":"<p>What it demonstrates:</p> <ul> <li>Deterministic coalescing under bursty load using a per-edge coalescing policy.</li> <li>Three nodes: <code>SensorNode</code>, <code>WindowAggNode</code>, <code>SinkNode</code>.</li> <li>Shows how to merge queued items on a pressured edge without losing information.</li> </ul> <p>Why it matters:</p> <ul> <li>Illustrates how to handle high-rate streams and compress bursts without unbounded queues.</li> <li>Shows how to use the <code>Coalesce</code> policy for lossless aggregation.</li> </ul> <p>How to run:</p> Bash<pre><code>git clone https://github.com/GhostWeaselLabs/meridian-runtime-examples.git\ncd meridian-runtime-examples\npython examples/streaming_coalesce/main.py --human --timeout-s 5.0\n</code></pre> <p>Detailed documentation: Streaming Coalesce</p>","tags":["examples","demos"]},{"location":"examples/#pipeline-demo","title":"Pipeline Demo","text":"<p>What it demonstrates:</p> <ul> <li>Basic pipeline wiring with validation, transformation, and control signals.</li> <li>Simple graph topology with multiple nodes and different edge capacities.</li> <li>Backpressure simulation and control plane shutdown signals.</li> </ul> <p>Why it matters:</p> <ul> <li>Shows how to wire up a basic pipeline with validation and transformation stages.</li> <li>Demonstrates control plane signals and backpressure handling.</li> </ul> <p>How to run: Bash<pre><code>git clone https://github.com/GhostWeaselLabs/meridian-runtime-examples.git\ncd meridian-runtime-examples\npython examples/pipeline_demo/main.py\n</code></pre></p> <p>Detailed documentation: Pipeline Demo</p>","tags":["examples","demos"]},{"location":"examples/#how-to-run-examples","title":"How to run examples","text":"<p>From the examples repository root (<code>meridian-runtime-examples</code>), use Python directly or <code>uv run</code>:</p> Bash<pre><code># Minimal Hello World (start here!)\npython examples/minimal_hello/main.py\n\n# Hello Graph\npython examples/hello_graph/main.py\n\n# Sentiment pipeline\npython examples/sentiment/main.py --human --timeout-s 6.0\n\n# Streaming coalesce\npython examples/streaming_coalesce/main.py --human --timeout-s 5.0\n\n# Pipeline Demo\npython examples/pipeline_demo/main.py\n</code></pre> <p>Example Help</p> <p>Append <code>--help</code> to any example to see supported flags.</p>","tags":["examples","demos"]},{"location":"examples/#contributing-new-examples","title":"Contributing new examples","text":"<ul> <li>Contribute in <code>meridian-runtime-examples</code> under <code>examples/&lt;example_name&gt;/</code></li> <li> <p>Keep a small <code>README.md</code> in the example directory with:</p> <ul> <li>What it demonstrates</li> <li>How to run</li> <li>Key flags and expected behavior</li> <li>Add a new page under <code>docs/examples/</code> and link it here</li> </ul> </li> </ul> <p>This keeps each example self-contained, testable, and easy to extend over time.</p>","tags":["examples","demos"]},{"location":"examples/hello-graph/","title":"Hello Graph","text":"<p>A modular example with separate producer and consumer modules, demonstrating proper project structure and observability integration. This example shows how to organize complex nodes into separate files with comprehensive logging.</p> <p>Code location: <code>meridian-runtime-examples/examples/hello_graph/</code></p> <ul> <li>Entry point: <code>examples/hello_graph/main.py</code></li> <li>Producer: <code>examples/hello_graph/producer.py</code></li> <li>Consumer: <code>examples/hello_graph/consumer.py</code></li> </ul>","tags":["examples","modular","observability","structure"]},{"location":"examples/hello-graph/#what-it-does","title":"What it does","text":"","tags":["examples","modular","observability","structure"]},{"location":"examples/hello-graph/#nodes","title":"Nodes","text":"<ul> <li>ProducerNode \u2014 emits a bounded sequence of integers with comprehensive logging and metadata</li> <li>Consumer \u2014 receives messages, tracks them in a list, and prints payloads</li> </ul>","tags":["examples","modular","observability","structure"]},{"location":"examples/hello-graph/#wiring","title":"Wiring","text":"<ul> <li><code>ProducerNode(output)</code> \u2192 <code>Consumer(in)</code>: bounded edge with capacity 16</li> </ul>","tags":["examples","modular","observability","structure"]},{"location":"examples/hello-graph/#modular-design","title":"Modular Design","text":"<ul> <li>Producer and consumer are implemented in separate files</li> <li>Comprehensive logging with contextual fields and metadata</li> <li>Assertion-based validation to ensure correct behavior</li> <li>Demonstrates proper project structure for complex applications</li> </ul>","tags":["examples","modular","observability","structure"]},{"location":"examples/hello-graph/#how-to-run","title":"How to run","text":"<p>From the examples repository root (<code>meridian-runtime-examples</code>):</p> Bash<pre><code>python examples/hello_graph/main.py\n</code></pre> <p>You should see:</p> <ul> <li>Structured startup logs with configuration details</li> <li>Message emission logs with sequence metadata</li> <li>Consumer processing logs</li> <li>Structured shutdown logs with final statistics</li> <li>Validation assertion confirming correct behavior</li> </ul> <p>Tip</p> <p>This example demonstrates best practices for organizing complex Meridian applications.</p> <p>Note</p> <p>The example includes comprehensive logging and validation to ensure reliable operation.</p>","tags":["examples","modular","observability","structure"]},{"location":"examples/hello-graph/#implementation-notes","title":"Implementation notes","text":"<ul> <li>Modular Structure: Producer and consumer in separate files for maintainability</li> <li>Comprehensive Logging: Uses contextual logging with metadata and sequence numbers</li> <li>Message Metadata: Includes sequence numbers and other metadata in messages</li> <li>Message Tracking: Consumer maintains a list of received values for validation</li> <li>Lifecycle Management: Proper startup and shutdown with detailed logging</li> </ul>","tags":["examples","modular","observability","structure"]},{"location":"examples/hello-graph/#key-code-patterns","title":"Key Code Patterns","text":"Python<pre><code># Comprehensive logging with metadata\nwith with_context(node=self.name):\n    self._logger.info(\n        \"producer.emitted\",\n        f\"Emitted value: {self.current_value}\",\n        value=self.current_value,\n        sequence=self.count_emitted,\n    )\n\n# Message with metadata\nmsg = Message(\n    type=MessageType.DATA,\n    payload=self.current_value,\n    metadata={\"sequence\": self.count_emitted},\n)\n</code></pre>","tags":["examples","modular","observability","structure"]},{"location":"examples/hello-graph/#what-to-look-for","title":"What to look for","text":"<ul> <li>Modular Organization: Clean separation of concerns across files</li> <li>Structured Logging: Rich contextual information in all log messages</li> <li>Message Metadata: Sequence numbers and other metadata for tracking</li> <li>Message Tracking: Consumer tracks received values in a list</li> <li>Professional Structure: Demonstrates production-ready code organization</li> </ul>","tags":["examples","modular","observability","structure"]},{"location":"examples/hello-graph/#project-structure","title":"Project Structure","text":"Text Only<pre><code>examples/hello_graph/\n\u251c\u2500\u2500 main.py          # Graph assembly and execution\n\u251c\u2500\u2500 producer.py      # ProducerNode implementation\n\u251c\u2500\u2500 consumer.py      # Consumer implementation\n\u2514\u2500\u2500 __init__.py      # Package initialization\n</code></pre> <p>This structure demonstrates how to organize complex Meridian applications with proper separation of concerns.</p>","tags":["examples","modular","observability","structure"]},{"location":"examples/hello-graph/#source-references","title":"Source references","text":"<ul> <li>Main entry and graph wiring:<ul> <li><code>examples/hello_graph/main.py</code></li> </ul> </li> <li>Producer implementation:<ul> <li><code>examples/hello_graph/producer.py</code></li> </ul> </li> <li>Consumer implementation:<ul> <li><code>examples/hello_graph/consumer.py</code></li> </ul> </li> </ul> <p>Use this as a template for organizing complex Meridian applications with proper modularity and observability. </p>","tags":["examples","modular","observability","structure"]},{"location":"examples/minimal-hello/","title":"Minimal Hello","text":"<p>A complete, runnable example demonstrating basic node creation and graph wiring with proper lifecycle management. This example shows the fundamental building blocks of the Meridian runtime.</p> <p>Code location: <code>meridian-runtime-examples/examples/minimal_hello/</code></p> <ul> <li>Entry point: <code>meridian-runtime-examples/examples/minimal_hello/main.py</code></li> </ul>","tags":["examples","minimal","lifecycle","basics"]},{"location":"examples/minimal-hello/#what-it-does","title":"What it does","text":"","tags":["examples","minimal","lifecycle","basics"]},{"location":"examples/minimal-hello/#nodes","title":"Nodes","text":"<ul> <li>ProducerNode \u2014 emits a bounded sequence of integers (0-4) on each scheduler tick</li> <li>Consumer \u2014 receives and prints messages, tracking all received values</li> </ul>","tags":["examples","minimal","lifecycle","basics"]},{"location":"examples/minimal-hello/#wiring","title":"Wiring","text":"<ul> <li><code>ProducerNode(output)</code> \u2192 <code>Consumer(in)</code>: bounded edge with capacity 8</li> </ul>","tags":["examples","minimal","lifecycle","basics"]},{"location":"examples/minimal-hello/#lifecycle","title":"Lifecycle","text":"<ul> <li>Demonstrates proper node lifecycle management with <code>on_start</code> and <code>on_stop</code> methods</li> <li>Shows bounded message emission with <code>max_count</code> parameter</li> <li>Includes structured logging with contextual fields</li> </ul>","tags":["examples","minimal","lifecycle","basics"]},{"location":"examples/minimal-hello/#how-to-run","title":"How to run","text":"<p>From the examples repository root (<code>meridian-runtime-examples</code>):</p> Bash<pre><code>python examples/minimal_hello/main.py\n</code></pre> <p>You should see:</p> <ul> <li>Structured startup logs from both nodes</li> <li>Message emission logs with sequence numbers</li> <li>Consumer receiving and printing messages</li> <li>Structured shutdown logs with final counts</li> <li>Success confirmation message</li> </ul> <p>Tip</p> <p>This example is perfect for understanding the basic concepts before moving to more complex examples.</p> <p>Note</p> <p>The example uses a deterministic sequence (0-4) to demonstrate predictable behavior.</p>","tags":["examples","minimal","lifecycle","basics"]},{"location":"examples/minimal-hello/#implementation-notes","title":"Implementation notes","text":"<ul> <li>Node Lifecycle: Both nodes implement proper <code>on_start</code> and <code>on_stop</code> methods</li> <li>Structured Logging: Uses contextual logging with node names and metadata</li> <li>Bounded Emission: Producer stops after emitting <code>max_count</code> messages</li> <li>Message Tracking: Consumer maintains a list of received values for validation</li> <li>Simple Wiring: Single edge connection demonstrating basic graph construction</li> </ul>","tags":["examples","minimal","lifecycle","basics"]},{"location":"examples/minimal-hello/#key-code-patterns","title":"Key Code Patterns","text":"Python<pre><code># Bounded message emission\ndef _handle_tick(self) -&gt; None:\n    if self.count &lt; self.max_count:\n        self.emit(\"output\", Message(type=MessageType.DATA, payload=self.count))\n        self.count += 1\n\n# Message tracking\ndef _handle_message(self, port: str, msg: Message) -&gt; None:\n    if port == \"in\":\n        self.values.append(msg.payload)\n        print(f\"Consumer received: {msg.payload}\")\n</code></pre>","tags":["examples","minimal","lifecycle","basics"]},{"location":"examples/minimal-hello/#what-to-look-for","title":"What to look for","text":"<ul> <li>Clean Lifecycle: Proper startup and shutdown sequence</li> <li>Structured Logs: Contextual logging with node names and metadata</li> <li>Bounded Behavior: Predictable message count (5 messages total)</li> <li>Simple Topology: Single producer-consumer pattern</li> <li>Validation: Final assertion confirms all messages were processed</li> </ul>","tags":["examples","minimal","lifecycle","basics"]},{"location":"examples/minimal-hello/#source-references","title":"Source references","text":"<ul> <li>Main entry and graph wiring:<ul> <li><code>examples/minimal_hello/main.py</code></li> </ul> </li> </ul> <p>Use this as the foundation for understanding Meridian runtime concepts before exploring more complex examples. </p>","tags":["examples","minimal","lifecycle","basics"]},{"location":"examples/pipeline-demo/","title":"Pipeline Demo","text":"<p>A comprehensive example demonstrating multi-stage data processing with validation, transformation, and control flow. This example shows how to build complex graph topologies with multiple processing stages and error handling.</p> <p>Code location: <code>meridian-runtime-examples/examples/pipeline_demo/</code></p> <ul> <li>Entry point: <code>examples/pipeline_demo/main.py</code></li> <li>Control: <code>examples/pipeline_demo/control.py</code></li> <li>Transformer: <code>examples/pipeline_demo/transformer.py</code></li> <li>Validator: <code>examples/pipeline_demo/validator.py</code></li> <li>Sink: <code>examples/pipeline_demo/sink.py</code></li> </ul>","tags":["examples","pipeline","validation","multi-stage"]},{"location":"examples/pipeline-demo/#what-it-does","title":"What it does","text":"","tags":["examples","pipeline","validation","multi-stage"]},{"location":"examples/pipeline-demo/#nodes","title":"Nodes","text":"<ul> <li>KillSwitch \u2014 publishes a shutdown signal on control-plane edge</li> <li>Validator \u2014 drops invalid inputs, emits valid items only (requires \"id\" field)</li> <li>Transformer \u2014 normalizes payloads and forwards with \"normalized\" flag</li> <li>SlowSink \u2014 simulates I/O latency to trigger backpressure</li> </ul>","tags":["examples","pipeline","validation","multi-stage"]},{"location":"examples/pipeline-demo/#wiring","title":"Wiring","text":"<ul> <li><code>Validator(out)</code> \u2192 <code>Transformer(in)</code>: data plane with capacity 64</li> <li><code>Transformer(out)</code> \u2192 <code>Sink(in)</code>: data plane with capacity 8</li> <li><code>KillSwitch(out)</code> \u2192 <code>Sink(control)</code>: control plane with capacity 1</li> </ul>","tags":["examples","pipeline","validation","multi-stage"]},{"location":"examples/pipeline-demo/#multi-stage-processing","title":"Multi-Stage Processing","text":"<ul> <li>Demonstrates validation and transformation pipeline</li> <li>Shows control plane shutdown signal</li> <li>Includes backpressure simulation with slow sink</li> <li>Validates graph wiring and basic functionality</li> </ul>","tags":["examples","pipeline","validation","multi-stage"]},{"location":"examples/pipeline-demo/#how-to-run","title":"How to run","text":"<p>From the examples repository root (<code>meridian-runtime-examples</code>):</p> Bash<pre><code>python examples/pipeline_demo/main.py\n</code></pre> <p>You should see:</p> <ul> <li>Graph wiring and node startup</li> <li>Basic pipeline execution</li> <li>Shutdown signal processing</li> <li>Backpressure simulation</li> </ul> <p>Tip</p> <p>This example demonstrates basic pipeline wiring and control plane signals.</p> <p>Note</p> <p>The example validates graph construction and basic functionality without external inputs.</p>","tags":["examples","pipeline","validation","multi-stage"]},{"location":"examples/pipeline-demo/#implementation-notes","title":"Implementation notes","text":"<ul> <li>Validation Logic: Validator only forwards messages with \"id\" field in payload</li> <li>Transformation: Transformer adds \"normalized\" flag to all payloads</li> <li>Backpressure Simulation: SlowSink introduces artificial delay to demonstrate backpressure</li> <li>Control Signal: KillSwitch sends shutdown signal on first tick</li> <li>Graph Wiring: Demonstrates basic graph construction and node connections</li> </ul>","tags":["examples","pipeline","validation","multi-stage"]},{"location":"examples/pipeline-demo/#key-code-patterns","title":"Key Code Patterns","text":"Python<pre><code># Validation logic\ndef _handle_message(self, port: str, msg: Message[Any]) -&gt; None:\n    if port != \"in\":\n        return\n    self.seen += 1\n    payload = msg.payload\n    if isinstance(payload, dict) and \"id\" in payload:\n        self.valid += 1\n        self.emit(\"out\", Message(type=MessageType.DATA, payload=payload))\n\n# Transformation\ndef _handle_message(self, port: str, msg: Message[dict[str, Any]]) -&gt; None:\n    if port != \"in\":\n        return\n    payload = dict(msg.payload)\n    payload.setdefault(\"normalized\", True)\n    self.emit(\"out\", Message(type=MessageType.DATA, payload=payload))\n</code></pre>","tags":["examples","pipeline","validation","multi-stage"]},{"location":"examples/pipeline-demo/#what-to-look-for","title":"What to look for","text":"<ul> <li>Basic Wiring: Simple graph construction with multiple nodes</li> <li>Control Signal: KillSwitch sends shutdown signal on first tick</li> <li>Validation: Validator filters messages based on payload structure</li> <li>Transformation: Transformer adds metadata to payloads</li> <li>Backpressure: SlowSink demonstrates backpressure with artificial delay</li> </ul>","tags":["examples","pipeline","validation","multi-stage"]},{"location":"examples/pipeline-demo/#project-structure","title":"Project Structure","text":"Text Only<pre><code>examples/pipeline_demo/\n\u251c\u2500\u2500 main.py          # Pipeline assembly and execution\n\u251c\u2500\u2500 control.py       # KillSwitch implementation\n\u251c\u2500\u2500 transformer.py   # Transformer implementation\n\u251c\u2500\u2500 validator.py     # Validator implementation\n\u251c\u2500\u2500 sink.py          # SlowSink implementation\n\u2514\u2500\u2500 __init__.py      # Package initialization\n</code></pre> <p>This structure demonstrates basic pipeline organization with separate node implementations.</p>","tags":["examples","pipeline","validation","multi-stage"]},{"location":"examples/pipeline-demo/#source-references","title":"Source references","text":"<ul> <li>Main entry and pipeline assembly:<ul> <li><code>examples/pipeline_demo/main.py</code></li> </ul> </li> <li>KillSwitch implementation:<ul> <li><code>examples/pipeline_demo/control.py</code></li> </ul> </li> <li>Transformer implementation:<ul> <li><code>examples/pipeline_demo/transformer.py</code></li> </ul> </li> <li>Validator implementation:<ul> <li><code>examples/pipeline_demo/validator.py</code></li> </ul> </li> <li>SlowSink implementation:<ul> <li><code>examples/pipeline_demo/sink.py</code></li> </ul> </li> </ul> <p>Use this as a template for basic pipeline wiring and control plane signal handling. </p>","tags":["examples","pipeline","validation","multi-stage"]},{"location":"examples/sentiment/","title":"Sentiment Pipeline","text":"<p>A small, end-to-end example that simulates a real-time text processing pipeline with a control-plane channel. It demonstrates priorities, bounded queues, observability, and graceful shutdown in the Meridian runtime.</p> <p>Code location: <code>meridian-runtime-examples/examples/sentiment/</code></p> <ul> <li>Entry point: <code>examples/sentiment/main.py</code></li> <li>Local README: <code>examples/sentiment/README.md</code></li> </ul>","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/sentiment/#what-it-does","title":"What it does","text":"","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/sentiment/#nodes","title":"Nodes:","text":"<ul> <li>IngestNode \u2014 emits short text samples at a configurable rate (default: 10.0 Hz).</li> <li>TokenizeNode \u2014 splits text into tokens (lowercased, punctuation stripped).</li> <li>SentimentNode \u2014 computes a naive sentiment score; responds to CONTROL messages to change mode:</li> <li><code>avg</code> (default): continuous score in [-1.0, 1.0]</li> <li><code>binary</code>: discrete score in {-1.0, 0.0, 1.0} (rounds continuous score to nearest discrete value)</li> <li>ControlNode \u2014 periodically emits CONTROL commands in rotation to demonstrate preemption and live configuration:</li> <li><code>avg</code>, <code>binary</code>, <code>flush</code>, <code>quiet</code>, <code>verbose</code> (cycles through all commands)</li> <li>SinkNode \u2014 prints per-item results and periodic summaries; supports <code>flush</code>, <code>quiet</code>, <code>verbose</code> via CONTROL.</li> </ul>","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/sentiment/#wiring","title":"Wiring:","text":"<ul> <li>Data plane: <code>Ingest(text) \u2192 Tokenize(in) \u2192 Sentiment(in) \u2192 Sink(in)</code></li> <li>Control plane: <code>Control(ctl) \u2192 Sentiment(ctl)</code> and <code>Control(ctl) \u2192 Sink(ctl)</code></li> </ul>","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/sentiment/#priorities-and-policies","title":"Priorities and policies:","text":"<ul> <li>CONTROL messages are prioritized by the scheduler and pierce data-plane load.</li> <li>Edges are bounded with configurable capacities (see flags below).</li> </ul>","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/sentiment/#how-to-run","title":"How to run","text":"<p>From the examples repository root (<code>meridian-runtime-examples</code>):</p> Bash<pre><code>python examples/sentiment/main.py --human --timeout-s 6.0\n</code></pre> <p>You should see:</p> <ul> <li>Scheduler and node startup logs.</li> <li>Per-item logs from <code>SinkNode</code> with scores (when not in quiet mode).</li> <li>CONTROL effects every few seconds (toggle avg/binary, flush, quiet/verbose).</li> <li>Scheduler timeout leading to graceful shutdown.</li> </ul> <p>Tip</p> <p>Add <code>--help</code> to see all available flags and their descriptions.</p> <p>Note</p> <p>The demo uses a deterministic random seed (42) for reproducible text samples across runs.</p>","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/sentiment/#cli-flags","title":"CLI flags","text":"<p>The program defines the following arguments (exact names and defaults come from the code in <code>examples/sentiment/main.py</code>):</p> <ul> <li><code>--rate-hz 10.0</code>      Ingest rate (items per second)</li> <li><code>--control-period 4.0</code> CONTROL message period (sec)</li> <li><code>--keep 10</code>            Sink buffer size for summaries</li> <li><code>--quiet</code>              Sink prints periodic summaries only (still logs flush)</li> <li><code>--tick-ms 25</code>         Scheduler tick interval (ms)</li> <li><code>--max-batch 8</code>        Max messages per node per scheduling slice</li> <li><code>--timeout-s 6.0</code>      Idle timeout for scheduler shutdown (seconds)</li> <li><code>--cap-text 64</code>        Capacity: ingest \u2192 tokenize</li> <li><code>--cap-tokens 64</code>      Capacity: tokenize \u2192 sentiment</li> <li><code>--cap-scored 128</code>     Capacity: sentiment \u2192 sink</li> <li><code>--cap-control 8</code>      Capacity: control \u2192 sentiment/sink</li> <li><code>--human</code>              Human-readable logs (key=value style)</li> <li><code>--debug</code>              Enable debug-level logs</li> </ul>","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/sentiment/#examples","title":"Examples","text":"<p>Higher rate and smaller capacities (induces more backpressure): Bash<pre><code>python examples/sentiment/main.py --human --rate-hz 20 --cap-text 32 --cap-tokens 32 --cap-scored 64\n</code></pre></p> <p>Emphasize control-plane preemption (faster ticks, more frequent control): Bash<pre><code>python examples/sentiment/main.py --human --tick-ms 10 --control-period 2.0\n</code></pre></p> <p>Quiet output (focus on periodic summaries): Bash<pre><code>python examples/sentiment/main.py --human --quiet\n</code></pre></p>","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/sentiment/#performance-tuning","title":"Performance Tuning","text":"<p>For high-throughput scenarios: Bash<pre><code>python examples/sentiment/main.py --rate-hz 50 --tick-ms 10 --max-batch 16 --cap-text 256 --cap-tokens 256 --cap-scored 512\n</code></pre></p> <p>For low-latency control response: Bash<pre><code>python examples/sentiment/main.py --tick-ms 5 --control-period 1.0 --cap-control 16\n</code></pre></p> <p>For memory-constrained environments: Bash<pre><code>python examples/sentiment/main.py --cap-text 16 --cap-tokens 16 --cap-scored 32 --cap-control 4\n</code></pre></p>","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/sentiment/#what-to-look-for","title":"What to look for","text":"<ul> <li>Control-plane preemption:<ul> <li>Mode changes (<code>avg</code>/<code>binary</code>), <code>flush</code>, and verbosity toggles apply promptly even while many data messages flow.</li> </ul> </li> <li>Bounded queues:<ul> <li>No unbounded memory growth; throughput remains stable under configured capacities.</li> </ul> </li> <li>Observability:<ul> <li>Logs carry contextual fields (e.g., node name); <code>--human</code> switches to key=value formatting.</li> </ul> </li> <li>Clean shutdown:<ul> <li>The scheduler announces timeout and stops nodes in order.</li> </ul> </li> </ul> <p>Warning</p> <p>Performance Note: Running with very high rates (<code>--rate-hz &gt; 50</code>) or very small capacities may cause backpressure and affect control message responsiveness.</p>","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/sentiment/#troubleshooting","title":"Troubleshooting","text":"","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/sentiment/#common-issues","title":"Common Issues","text":"<p>No output appears - Check that the scheduler is running (look for startup logs) - Verify <code>--timeout-s</code> is not too short for your system - Try adding <code>--debug</code> for more verbose logging</p> <p>Control messages not taking effect - Ensure <code>--control-period</code> is reasonable (default 4.0s) - Check that <code>--cap-control</code> is not too small (default 8) - Verify scheduler fairness ratio allows control priority</p> <p>High memory usage - Reduce edge capacities (<code>--cap-text</code>, <code>--cap-tokens</code>, <code>--cap-scored</code>) - Lower ingest rate with <code>--rate-hz</code> - Monitor with <code>--debug</code> to see queue depths</p> <p>Poor performance - Increase <code>--tick-ms</code> for less frequent scheduling - Reduce <code>--max-batch</code> for more frequent context switches - Check system load and available CPU resources</p>","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/sentiment/#implementation-notes","title":"Implementation notes","text":"<ul> <li>The graph is assembled with <code>Subgraph.from_nodes(...)</code> and <code>connect(...)</code> for each edge.</li> <li>CONTROL vs DATA:<ul> <li><code>SentimentNode</code> listens to <code>ctl</code> and <code>in</code> ports; CONTROL on <code>ctl</code> changes state without interfering with data processing on <code>in</code>.</li> <li><code>SinkNode</code> supports <code>flush</code>, <code>quiet</code>, and <code>verbose</code> via its <code>ctl</code> port.</li> </ul> </li> <li>Scheduling:<ul> <li>The <code>Scheduler</code> is configured with <code>tick_interval_ms</code>, <code>fairness_ratio=(4, 2, 1)</code>, <code>max_batch_per_node</code>, <code>idle_sleep_ms=1</code>, and <code>shutdown_timeout_s</code> to demonstrate stability under load.</li> </ul> </li> <li>Edge Policies:<ul> <li>Data plane edges use bounded capacities with <code>Latest</code> policy (default) for freshness</li> <li>Control edges use <code>Block</code> policy to ensure CONTROL messages are prioritized by the scheduler</li> <li>The demo demonstrates how \"freshness\" and blocking behavior interplay with prioritized CONTROL messages.</li> </ul> </li> </ul>","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/sentiment/#architecture-decisions","title":"Architecture Decisions","text":"<p>Separate Control Plane: The example uses dedicated control channels (<code>ctl</code> ports) to demonstrate how control messages can be prioritized independently of data flow.</p> <p>Bounded Queues: All edges use finite capacities to prevent unbounded memory growth and demonstrate backpressure handling.</p> <p>Deterministic Sampling: Uses a fixed random seed (42) to ensure reproducible behavior across runs for testing and debugging.</p> <p>Thread-Safe Ingest: The <code>IngestNode</code> uses a separate producer thread to simulate real-world streaming scenarios where data arrives asynchronously.</p>","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/sentiment/#source-references","title":"Source references","text":"<ul> <li>Main entry and graph wiring:<ul> <li><code>examples/sentiment/main.py</code></li> </ul> </li> <li>Additional background and usage notes:<ul> <li><code>examples/sentiment/README.md</code></li> </ul> </li> </ul> <p>Use these as the single source of truth for flags and behavior when extending or adapting the example.</p>","tags":["examples","sentiment","control-plane","backpressure"]},{"location":"examples/simple-web-server/","title":"Simple web server (simulated)","text":"<p>This example shows how to receive HTTP requests and process them via built-in nodes without running a full external server. We use <code>HttpServerNode</code>'s <code>simulate_request()</code> to focus on flow wiring.</p>","tags":["example","web"]},{"location":"examples/simple-web-server/#topology","title":"Topology","text":"<pre><code>flowchart LR\n  A[HttpServerNode] --&gt; B[Router]\n  B -- GET /metrics --&gt; C[MetricsCollectorNode]\n  B -- GET /echo --&gt; D[MapTransformer]\n  C --&gt; E[SerializationNode]\n  D --&gt; E</code></pre>","tags":["example","web"]},{"location":"examples/simple-web-server/#code","title":"Code","text":"Python<pre><code>from meridian.core import Scheduler, SchedulerConfig, Subgraph\nfrom meridian.nodes import HttpServerNode, Router, MapTransformer, MetricsCollectorNode, SerializationNode\n\n# Simulated HTTP server node\nsrv = HttpServerNode(\"srv\")\n\n# Router: route by path\nrouter = Router(\n    \"router\",\n    routing_fn=lambda req: \"metrics\" if req.get(\"path\") == \"/metrics\" else \"echo\",\n    output_ports=[\"metrics\", \"echo\"],\n)\n\n# Metrics extractor for requests\nmc = MetricsCollectorNode(\n    \"metrics\",\n    metric_extractors={\"requests\": lambda req: 1.0},\n    aggregation_window_ms=50,\n)\n\n# Echo transformer: map request -&gt; minimal response dict\necho = MapTransformer(\"echo\", transform_fn=lambda req: {\"path\": req.get(\"path\"), \"ok\": True})\n\n# Serialize any dicts to JSON text\nser = SerializationNode(\"ser\")\n\ng = Subgraph.from_nodes(\"web\", [srv, router, mc, echo, ser])\ng.connect((\"srv\", \"output\"), (\"router\", \"input\"))\ng.connect((\"router\", \"metrics\"), (\"metrics\", \"input\"))\ng.connect((\"router\", \"echo\"), (\"echo\", \"input\"))\ng.connect((\"metrics\", \"output\"), (\"ser\", \"input\"))\ng.connect((\"echo\", \"output\"), (\"ser\", \"input\"))\n\ns = Scheduler(SchedulerConfig(idle_sleep_ms=0, tick_interval_ms=5))\ns.register(g)\n\n# Run in background briefly\nimport threading, time\nth = threading.Thread(target=s.run, daemon=True)\nth.start()\n\n# Simulate some HTTP requests\nfor path in [\"/\", \"/echo\", \"/metrics\", \"/echo\"]:\n    srv.simulate_request(\"GET\", path)\n\n# Allow metrics window to flush\ntime.sleep(0.2)\ns.shutdown(); th.join()\n</code></pre> <p>Tip</p> <p>Replace <code>HttpServerNode</code> with a real adapter to <code>http.server</code> or ASGI for production. This keeps the example dependency-free and easy to run.</p>","tags":["example","web"]},{"location":"examples/streaming-coalesce/","title":"Streaming Coalesce","text":"<p>A focused example that demonstrates the coalescing policy in the Meridian runtime. It simulates a high-rate sensor stream, converts each reading into a small aggregate, and uses a coalescing edge to merge items under burst pressure without losing information.</p> <p>Code location: <code>meridian-runtime-examples/examples/streaming_coalesce/</code></p> <ul> <li>Entry point: <code>examples/streaming_coalesce/main.py</code></li> <li>Local README: <code>examples/streaming_coalesce/README.md</code></li> </ul>","tags":["examples","coalesce","backpressure","streaming"]},{"location":"examples/streaming-coalesce/#what-it-does","title":"What it does","text":"","tags":["examples","coalesce","backpressure","streaming"]},{"location":"examples/streaming-coalesce/#nodes","title":"Nodes","text":"<ul> <li>SensorNode \u2014 emits <code>SensorReading(ts: float, value: float)</code> at a configurable rate using scheduler ticks (constructor default: 200.0 Hz, CLI default: 300.0 Hz).</li> <li>WindowAggNode \u2014 converts each <code>SensorReading</code> into <code>WindowAgg(count=1, sum=value, min_v=value, max_v=value)</code> with strict payload validation.</li> <li>SinkNode \u2014 prints per-item aggregates and periodic 1-second summaries, showing stable behavior under load.</li> </ul>","tags":["examples","coalesce","backpressure","streaming"]},{"location":"examples/streaming-coalesce/#wiring","title":"Wiring","text":"<ul> <li><code>Sensor(out)</code> \u2192 <code>WindowAgg(in)</code>: normal capacity.</li> <li><code>WindowAgg(out)</code> \u2192 <code>Sink(in)</code>: small capacity with a <code>Coalesce(merge_window)</code> policy attached to the edge.</li> </ul>","tags":["examples","coalesce","backpressure","streaming"]},{"location":"examples/streaming-coalesce/#coalescing","title":"Coalescing","text":"<ul> <li>When the <code>agg \u2192 sink</code> edge is pressured (small capacity, high rate), queued <code>WindowAgg</code> items are merged with a pure, deterministic merge function:</li> <li><code>count</code> and <code>sum</code> add</li> <li><code>min_v</code>/<code>max_v</code> take min/max</li> <li>This compresses bursts and maintains aggregate correctness (no information loss for sum/min/max/count).</li> </ul>","tags":["examples","coalesce","backpressure","streaming"]},{"location":"examples/streaming-coalesce/#how-to-run","title":"How to run","text":"<p>From the examples repository root (<code>meridian-runtime-examples</code>):</p> Bash<pre><code>python examples/streaming_coalesce/main.py --human --timeout-s 5.0\n</code></pre> <p>You should see:</p> <ul> <li>Scheduler and node startup logs.</li> <li>Frequent per-item aggregate logs (count=1 initially), then coalesced items as load/pressure increases.</li> <li>Periodic 1-second summary logs (window size, total_count, avg, min, max).</li> <li>Timeout leading to graceful shutdown.</li> </ul> <p>Tip</p> <p>Add <code>--help</code> to see all available flags and their descriptions.</p> <p>Note</p> <p>The demo uses a deterministic random seed (1234) for reproducible sensor readings across runs.</p>","tags":["examples","coalesce","backpressure","streaming"]},{"location":"examples/streaming-coalesce/#cli-flags","title":"CLI flags","text":"<p>These flags are defined by the program (see <code>examples/streaming_coalesce/main.py</code> for authoritative defaults):</p> <ul> <li><code>--rate-hz 300.0</code>         Sensor emit rate (items/sec)</li> <li><code>--tick-ms 10</code>            Scheduler tick interval (ms)</li> <li><code>--max-batch 16</code>          Max messages per node per scheduling slice</li> <li><code>--timeout-s 5.0</code>         Idle timeout for scheduler shutdown (s)</li> <li><code>--cap-sensor-to-agg 256</code> Capacity: <code>sensor \u2192 agg</code></li> <li><code>--cap-agg-to-sink 16</code>    Capacity: <code>agg \u2192 sink</code> (smaller makes coalescing more visible)</li> <li><code>--keep 10</code>               Sink buffer size (items kept for windowed summary)</li> <li><code>--quiet</code>                 Reduce per-item logs and focus on periodic summaries</li> <li><code>--human</code>                 Human-readable logs (key=value style)</li> <li><code>--debug</code>                 Enable debug-level logs</li> </ul>","tags":["examples","coalesce","backpressure","streaming"]},{"location":"examples/streaming-coalesce/#examples","title":"Examples","text":"<p>Emphasize coalescing with higher rate and smaller agg\u2192sink capacity: Bash<pre><code>python examples/streaming_coalesce/main.py --human --rate-hz 600 --cap-agg-to-sink 8\n</code></pre></p> <p>Quieter output focusing on summaries: Bash<pre><code>python examples/streaming_coalesce/main.py --human --quiet\n</code></pre></p>","tags":["examples","coalesce","backpressure","streaming"]},{"location":"examples/streaming-coalesce/#performance-tuning","title":"Performance Tuning","text":"<p>For maximum coalescing visibility: Bash<pre><code>python examples/streaming_coalesce/main.py --human --rate-hz 1000 --cap-agg-to-sink 4\n</code></pre></p> <p>For high-throughput scenarios: Bash<pre><code>python examples/streaming_coalesce/main.py --human --rate-hz 500 --tick-ms 5 --max-batch 32 --cap-sensor-to-agg 512\n</code></pre></p> <p>For memory-constrained environments: Bash<pre><code>python examples/streaming_coalesce/main.py --human --cap-sensor-to-agg 64 --cap-agg-to-sink 8 --rate-hz 100\n</code></pre></p>","tags":["examples","coalesce","backpressure","streaming"]},{"location":"examples/streaming-coalesce/#what-to-look-for","title":"What to look for","text":"<ul> <li>Coalescing under pressure:<ul> <li>With a high <code>--rate-hz</code> and small <code>--cap-agg-to-sink</code>, <code>WindowAgg</code> items will be merged, increasing <code>count</code> and <code>sum</code> while maintaining <code>min_v</code> and <code>max_v</code>.</li> </ul> </li> <li>Stability:<ul> <li>No unbounded queue growth; the system remains responsive even during bursts.</li> </ul> </li> <li>Clean lifecycle:<ul> <li>Deterministic start, steady loop, and graceful shutdown on timeout.</li> </ul> </li> </ul> <p>Warning</p> <p>Performance Note: Running with very high rates (<code>--rate-hz &gt; 1000</code>) or very small capacities may cause excessive coalescing and affect aggregate accuracy.</p>","tags":["examples","coalesce","backpressure","streaming"]},{"location":"examples/streaming-coalesce/#troubleshooting","title":"Troubleshooting","text":"","tags":["examples","coalesce","backpressure","streaming"]},{"location":"examples/streaming-coalesce/#common-issues","title":"Common Issues","text":"<p>No coalescing observed</p> <ul> <li>Increase <code>--rate-hz</code> to generate more pressure</li> <li>Decrease <code>--cap-agg-to-sink</code> to create backpressure</li> <li>Check that the coalescing policy is properly configured</li> </ul> <p>Excessive coalescing (count &gt; 100)</p> <ul> <li>Increase <code>--cap-agg-to-sink</code> capacity</li> <li>Decrease <code>--rate-hz</code> to reduce pressure</li> <li>Monitor with <code>--debug</code> to see queue depths</li> </ul> <p>High memory usage</p> <ul> <li>Reduce edge capacities (<code>--cap-sensor-to-agg</code>, <code>--cap-agg-to-sink</code>)</li> <li>Lower sensor rate with <code>--rate-hz</code></li> <li>Monitor with <code>--debug</code> to see queue depths</li> </ul> <p>Poor performance</p> <ul> <li>Increase <code>--tick-ms</code> for less frequent scheduling</li> <li>Reduce <code>--max-batch</code> for more frequent context switches</li> <li>Check system load and available CPU resources</li> </ul>","tags":["examples","coalesce","backpressure","streaming"]},{"location":"examples/streaming-coalesce/#implementation-notes","title":"Implementation notes","text":"<ul> <li> <p>Domain model:</p> <ul> <li><code>SensorReading</code> carries a timestamp and value.</li> <li><code>WindowAgg</code> holds <code>{count, sum, min_v, max_v}</code> with a computed <code>avg</code> property.</li> <li><code>merge_window(a, b)</code> is a pure function used by the <code>Coalesce</code> policy to deterministically merge queued items.</li> </ul> </li> <li> <p>Graph wiring:</p> <ul> <li>Built via <code>Subgraph.from_nodes(...)</code> and <code>connect(...)</code> for each edge.</li> <li>The <code>agg \u2192 sink</code> edge sets <code>policy=Coalesce(lambda a, b: merge_window(a, b))</code> with a small capacity.</li> </ul> </li> <li> <p>Scheduling:</p> <ul> <li>The <code>Scheduler</code> is configured with <code>tick_interval_ms</code>, <code>fairness_ratio=(4, 2, 1)</code>, <code>max_batch_per_node</code>, <code>idle_sleep_ms=1</code>, and <code>shutdown_timeout_s</code> to demonstrate steady behavior under load.</li> </ul> </li> <li> <p>Observability:</p> <ul> <li>Logs use contextual fields; <code>--human</code> switches to key=value formatting.</li> </ul> </li> </ul>","tags":["examples","coalesce","backpressure","streaming"]},{"location":"examples/streaming-coalesce/#architecture-decisions","title":"Architecture Decisions","text":"<p>Immutable Data Structures: Uses <code>@dataclass(frozen=True, slots=True)</code> for <code>SensorReading</code> and <code>WindowAgg</code> to ensure thread safety and prevent accidental mutations during coalescing.</p> <p>Deterministic Coalescing: The <code>merge_window</code> function is pure and deterministic, ensuring reproducible behavior across runs and preventing data corruption.</p> <p>Per-Edge Policy: Coalescing is configured at the edge level via <code>policy=Coalesce(...)</code>, demonstrating the runtime's declarative policy system.</p> <p>Strict Validation: <code>WindowAggNode</code> includes strict payload validation to prevent <code>AttributeError</code> during processing.</p>","tags":["examples","coalesce","backpressure","streaming"]},{"location":"examples/streaming-coalesce/#source-references","title":"Source references","text":"<ul> <li>Main entry and graph wiring:<ul> <li><code>examples/streaming_coalesce/main.py</code></li> </ul> </li> <li>Additional background and usage notes:<ul> <li><code>examples/streaming_coalesce/README.md</code></li> </ul> </li> </ul> <p>Use these as the single source of truth for flags and behavior when extending or adapting the example.</p>","tags":["examples","coalesce","backpressure","streaming"]},{"location":"getting-started/guide/","title":"Getting started with built-in nodes","text":"<p>This guide shows how to build a small pipeline using built-in nodes from <code>meridian.nodes</code>.</p>"},{"location":"getting-started/guide/#install","title":"Install","text":"Bash<pre><code>uv pip install meridian-runtime\n</code></pre>"},{"location":"getting-started/guide/#create-a-simple-pipeline","title":"Create a simple pipeline","text":"Producer \u2192 Map \u2192 Consumer Python<pre><code>from meridian.core import Scheduler, SchedulerConfig, Subgraph\nfrom meridian.nodes import DataProducer, MapTransformer, DataConsumer\n\np = DataProducer(\"p\", data_source=lambda: iter(range(10)), interval_ms=0)\nm = MapTransformer(\"m\", transform_fn=lambda x: x * 2)\nseen: list[int] = []\nc = DataConsumer(\"c\", handler=seen.append)\n\ng = Subgraph.from_nodes(\"g\", [p, m, c])\ng.connect((\"p\", \"output\"), (\"m\", \"input\"))\ng.connect((\"m\", \"output\"), (\"c\", \"input\"))\n\ns = Scheduler(SchedulerConfig())\ns.register(g)\nimport threading, time\nth = threading.Thread(target=s.run, daemon=True)\nth.start(); time.sleep(0.2); s.shutdown(); th.join()\nprint(seen)\n</code></pre>"},{"location":"getting-started/guide/#next-steps","title":"Next steps","text":"<ul> <li>Explore categories in the reference for built-in nodes.</li> <li>Add reliability with <code>ThrottleNode</code>, <code>RetryNode</code>, or <code>CircuitBreakerNode</code>.</li> <li>Use <code>NodeTestHarness</code> to test nodes in isolation.</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>Follow these steps to get started immediately.</p>","tags":["quickstart","setup","examples"]},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>Python 3.11+</code></li> <li><code>uv</code> package manager (Install uv)</li> </ul>","tags":["quickstart","setup","examples"]},{"location":"getting-started/quickstart/#setup","title":"Setup","text":"Bash<pre><code>git clone https://github.com/GhostWeaselLabs/meridian-runtime.git\ncd meridian-runtime\nuv sync\n</code></pre>","tags":["quickstart","setup","examples"]},{"location":"getting-started/quickstart/#test-your-setup","title":"Test your setup","text":"Bash<pre><code># Create a simple test file\ncat &gt; test_setup.py &lt;&lt; 'EOF'\nfrom meridian.core import Node, Message, MessageType, Subgraph, Scheduler\nfrom meridian.core.ports import Port, PortDirection, PortSpec\n\nclass TestNode(Node):\n    def __init__(self):\n        super().__init__(\n            \"test\",\n            inputs=[Port(\"in\", PortDirection.INPUT, spec=PortSpec(\"in\", str))],\n            outputs=[Port(\"out\", PortDirection.OUTPUT, spec=PortSpec(\"out\", str))],\n        )\n\n    def _handle_message(self, port: str, msg: Message) -&gt; None:\n        if port == \"in\":\n            print(f\"\u2713 Setup working! Received: {msg.payload}\")\n            self.emit(\"out\", Message(type=MessageType.DATA, payload=\"success\"))\n\nsg = Subgraph.from_nodes(\"test\", [TestNode()])\nsg.connect((\"test\", \"out\"), (\"test\", \"in\"), capacity=1)\n\nsch = Scheduler()\nsch.register(sg)\ntest_node = sg.nodes[0]\ntest_node.emit(\"in\", Message(type=MessageType.DATA, payload=\"Hello Meridian!\"))\nsch.run()\nEOF\n\n# Run the test\nuv run python test_setup.py\n</code></pre> <p>Expected output: <code>\u2713 Setup working! Received: Hello Meridian!</code></p> <p>Setup Complete</p> <p>Your Meridian Runtime installation is working correctly!</p>","tags":["quickstart","setup","examples"]},{"location":"getting-started/quickstart/#run-an-example","title":"Run an example","text":"Bash<pre><code>git clone https://github.com/GhostWeaselLabs/meridian-runtime-examples.git\ncd meridian-runtime-examples\nuv run python examples/sentiment/main.py --human --timeout-s 6.0\n</code></pre>","tags":["quickstart","setup","examples"]},{"location":"getting-started/quickstart/#verify-optional","title":"Verify (optional)","text":"Bash<pre><code>uv run bash scripts/verify.sh\n</code></pre>","tags":["quickstart","setup","examples"]},{"location":"getting-started/quickstart/#next-steps","title":"Next steps","text":"<ul> <li><code>Guide</code>: Getting started</li> <li><code>Examples</code>: Examples</li> <li><code>API reference</code>: API reference</li> </ul>","tags":["quickstart","setup","examples"]},{"location":"guides/examples/","title":"Examples","text":"<p>Build real-time, observable dataflows using small, single-responsibility nodes connected by typed, bounded edges. These examples are copy-pasteable and focus on predictable behavior under load.</p> <p>Tip Initialize your environment once with:</p> Bash<pre><code>uv sync\n</code></pre>","tags":["examples","demos","dataflow","patterns"]},{"location":"guides/examples/#hello-graph-minimal","title":"Hello Graph (minimal)","text":"<p>A tiny, commented example that wires two nodes with a typed, bounded edge and runs the scheduler.</p> Python<pre><code># Minimal \"Hello Graph\" with two nodes connected by a typed, bounded edge.\n\nfrom meridian.core import Subgraph, Scheduler, Message, MessageType, Node, PortSpec\nfrom meridian.core.ports import Port, PortDirection\n\n# Producer: emits an integer payload on each scheduler tick.\nclass ProducerNode(Node):\n    def __init__(self, name: str = \"producer\", max_count: int = 5):\n        super().__init__(\n            name=name,\n            inputs=[],\n            outputs=[Port(\"output\", PortDirection.OUTPUT, spec=PortSpec(\"output\", int))],\n        )\n        self.max_count = max_count\n        self.count = 0\n\n    def _handle_tick(self) -&gt; None:\n        if self.count &lt; self.max_count:\n            self.emit(\"output\", Message(type=MessageType.DATA, payload=self.count))\n            self.count += 1\n\n# Consumer: prints messages from input port \"in\".\nclass Consumer(Node):\n    def __init__(self, name: str = \"consumer\"):\n        super().__init__(\n            name=name,\n            inputs=[Port(\"in\", PortDirection.INPUT, spec=PortSpec(\"in\", int))],\n            outputs=[],\n        )\n        self.values = []\n\n    def _handle_message(self, port: str, msg: Message) -&gt; None:\n        if port == \"in\":\n            self.values.append(msg.payload)\n            print(f\"Consumer received: {msg.payload}\")\n\n# Wire a small graph and run the scheduler.\nsg = Subgraph.from_nodes(\"hello_world\", [ProducerNode(max_count=5), Consumer()])\nsg.connect((\"producer\", \"output\"), (\"consumer\", \"in\"), capacity=8)\n\nsch = Scheduler()\nsch.register(sg)\nsch.run()\n</code></pre> <p>Run:</p> <ol> <li>Save as hello.py</li> <li>Execute:</li> </ol> Bash<pre><code>uv run python hello.py\n</code></pre> <p>Note</p> <p>This example demonstrates basic node creation, port configuration, and graph wiring. The <code>ProducerNode</code> emits a bounded sequence (0-4) and the <code>Consumer</code> tracks received values.</p> <p>Tip</p> <p>For more comprehensive examples with lifecycle management, observability, and advanced patterns, see the detailed documentation in the <code>examples/</code> folder.</p>","tags":["examples","demos","dataflow","patterns"]},{"location":"guides/examples/#sentiment-pipeline","title":"Sentiment pipeline","text":"<p>Demonstrates control-plane priorities, mixed overflow policies, and graceful shutdown with human-friendly output.</p> <p>Key capabilities:</p> <ul> <li>CONTROL messages (e.g., FLUSH, QUIET/VERBOSE) preempt standard traffic</li> <li>Mixed overflow policies per edge (Latest/Drop) under pressure</li> <li>Priority fairness and deterministic shutdown</li> <li>Structured logging for lifecycle and flow</li> </ul> <p>Run: Bash<pre><code>git clone https://github.com/GhostWeaselLabs/meridian-runtime-examples.git\ncd meridian-runtime-examples\nuv run python examples/sentiment/main.py --human --timeout-s 6.0\n</code></pre></p> <p>Look for:</p> <ul> <li>CONTROL messages surfacing ahead of regular messages</li> <li>Bounded edges enforcing policies under load</li> <li>Clean lifecycle: on_start \u2192 on_tick \u2192 on_stop</li> </ul> <p>Note</p> <p>See detailed documentation for comprehensive CLI flags, troubleshooting, and implementation details.</p>","tags":["examples","demos","dataflow","patterns"]},{"location":"guides/examples/#streaming-coalesce","title":"Streaming coalesce","text":"<p>A high-rate stream that uses coalescing to merge updates deterministically under load\u2014ideal for burst smoothing without losing the latest state.</p> <p>Key capabilities:</p> <ul> <li>Coalesce overflow policy (merge many updates into one representative value)</li> <li>Deterministic merging under pressure</li> <li>Per-edge defaults via Subgraph/Edge configuration</li> </ul> <p>Run: Bash<pre><code>git clone https://github.com/GhostWeaselLabs/meridian-runtime-examples.git\ncd meridian-runtime-examples\nuv run python examples/streaming_coalesce/main.py --human --timeout-s 5.0\n</code></pre></p> <p>Observe:</p> <ul> <li>Aggregation behavior as the rate increases</li> <li>Stable latency characteristics under bursty input</li> <li>Predictable, reproducible merging semantics</li> </ul> <p>Note</p> <p>See detailed documentation for comprehensive CLI flags, troubleshooting, and implementation details.</p>","tags":["examples","demos","dataflow","patterns"]},{"location":"guides/examples/#available-examples","title":"Available Examples","text":"<p>The examples are organized in the external <code>meridian-runtime-examples</code> repository under the <code>examples/</code> folder with detailed documentation:</p> <ul> <li>Minimal Hello - Basic node lifecycle and wiring</li> <li>Hello Graph - Modular design with observability</li> <li>Sentiment Pipeline - Control-plane priorities and mixed policies</li> <li>Streaming Coalesce - Deterministic coalescing under load</li> <li>Pipeline Demo - Multi-stage processing with validation</li> </ul> <p>Each example includes:</p> <ul> <li>Complete source code with comments</li> <li>Local README with usage instructions</li> <li>Integration tests for validation</li> <li>Observability configuration examples</li> </ul>","tags":["examples","demos","dataflow","patterns"]},{"location":"guides/examples/#patterns-illustrated","title":"Patterns illustrated","text":"<ul> <li>Single-responsibility nodes: explicit inputs/outputs and small, testable logic</li> <li>Bounded edges with policies: Block, Drop, Latest, Coalesce</li> <li>Control-plane priorities: urgent actions (flush, reconfigure, shutdown) preempt normal traffic</li> <li>Subgraphs as units: reusable graphs with typed ingress/egress and per-edge defaults</li> <li>Observability as a primitive: structured logs, metrics, and trace hooks</li> <li>Node lifecycle management: <code>on_start</code>, <code>on_tick</code>, <code>on_stop</code> methods for proper resource management</li> <li>Modular design: separate files for complex nodes and reusable components</li> </ul>","tags":["examples","demos","dataflow","patterns"]},{"location":"guides/examples/#troubleshooting","title":"Troubleshooting","text":"<p>Warning</p> <p>Common Issues: - Seems idle or quiet? Add <code>--human</code> or <code>--debug</code> where available - Capacity issues? Increase edge capacity or consumer throughput; adjust policies - Non-determinism? Use stable seeds and avoid shared mutable state</p> <p>Tip</p> <p>Debugging Tips: - Use <code>--debug</code> flag for verbose logging - Check scheduler configuration for fairness and timing - Verify edge capacities match your expected throughput - Monitor for backpressure indicators in logs</p>","tags":["examples","demos","dataflow","patterns"]},{"location":"guides/examples/#related-docs","title":"Related docs","text":"<ul> <li>Getting started: ../getting-started/guide.md</li> <li>Quickstart: ../getting-started/quickstart.md</li> <li>Patterns: ../concepts/patterns.md</li> <li>Observability: ../concepts/observability.md</li> <li>API reference: ../reference/api.md</li> <li>Troubleshooting: ../support/TROUBLESHOOTING.md</li> </ul>","tags":["examples","demos","dataflow","patterns"]},{"location":"guides/examples/#contribute-an-example","title":"Contribute an example","text":"<p>We welcome practical, self-contained examples that showcase:</p> <ul> <li>Clear node responsibilities and typed edges</li> <li>Realistic policies and scheduling decisions</li> <li>Robust lifecycle and logging</li> <li>Minimal dependencies and easy reproducibility</li> </ul> <p>Before submitting:</p> <ul> <li>Verify with scripts/verify.sh</li> <li>Include a short README and run instructions</li> <li>Follow existing style and observability patterns</li> </ul>","tags":["examples","demos","dataflow","patterns"]},{"location":"guides/local-development/","title":"Local development","text":""},{"location":"guides/local-development/#summary","title":"Summary","text":"<p>This guide helps you set up a productive local development environment for Meridian Runtime, run tests, lint and format code, and iterate quickly on examples and docs.</p>"},{"location":"guides/local-development/#audience","title":"Audience","text":"<p>Developers contributing to the project or building against the runtime locally.</p>"},{"location":"guides/local-development/#goals","title":"Goals","text":"<ul> <li>Install and configure local tooling (Python, uv, Make, pre-commit).</li> <li>Run the test suite and linters.</li> <li>Execute examples and iterate on code with fast feedback.</li> <li>Build and preview documentation locally.</li> </ul>"},{"location":"guides/local-development/#non-goals","title":"Non-goals","text":"<ul> <li>Production deployment.</li> <li>Deep-dive into the scheduler or performance tuning.</li> </ul>"},{"location":"guides/local-development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+ installed</li> <li>uv installed (recommended) or pip</li> <li>Make (optional but used by provided targets)</li> <li>Git</li> <li>On macOS: Xcode command line tools (for compilers) \u2014 xcode-select --install</li> </ul> <p>Optional but recommended: - direnv for automatic environment loading - A modern editor with Python support (VS Code, PyCharm, etc.)</p>"},{"location":"guides/local-development/#repository-setup","title":"Repository setup","text":"<p>Clone and install dependencies:</p> Bash<pre><code>git clone https://github.com/GhostWeaselLabs/meridian-runtime.git\ncd meridian-runtime\n\n# Create a virtual environment and install dependencies with uv (preferred)\nuv sync\n\n# Alternatively, using pip:\n# python -m venv .venv\n# source .venv/bin/activate\n# pip install -U pip\n# pip install -e \".[dev]\"\n</code></pre> <p>Enable pre-commit hooks (formatting, linting, hygiene checks):</p> Bash<pre><code># Automated setup (recommended)\n./scripts/dev-setup.sh\n\n# Manual setup\nuv tool install pre-commit\npre-commit install\npre-commit install --hook-type pre-push\n# Run against all files once:\npre-commit run --all-files\n</code></pre> <p>Note</p> <p>The <code>dev-setup.sh</code> script automatically installs pre-commit, lychee (link checker), and configures hooks.</p> <p>Common make targets (optional, convenience):</p> Bash<pre><code>make help\nmake demo-minimal        # run minimal hello world demo\nmake demo-sentiment      # run sentiment pipeline demo\nmake demo-coalesce       # run streaming coalesce demo\nmake docs-serve          # serve docs locally\nmake docs-build          # build docs to ./site\nmake docs-check-links    # check links in docs\n</code></pre>"},{"location":"guides/local-development/#running-tests","title":"Running tests","text":"<p>Run all tests:</p> Bash<pre><code>uv run pytest -q\n</code></pre> <p>Run a subset (by keyword or path):</p> Bash<pre><code># Run tests matching a keyword\nuv run pytest -k \"scheduler and not slow\" -q\n\n# Run tests in a specific file\nuv run pytest tests/test_scheduler.py -q\n</code></pre> <p>Generate a coverage report:</p> Bash<pre><code>uv run pytest --cov=src --cov-report=term-missing\n</code></pre> <p>Tip</p> <ul> <li>Keep unit tests fast; mark slow tests with pytest markers.</li> <li>Prefer deterministic tests; avoid sleeps where possible\u2014use timeouts and events.</li> </ul>"},{"location":"guides/local-development/#linting-typing-and-formatting","title":"Linting, typing, and formatting","text":"<p>Run the full lint suite:</p> Bash<pre><code># Using uvx (recommended)\nuvx ruff check .\nuvx ruff format .\nuvx mypy\n\n# Or using uv run\nuv run ruff check .\nuv run ruff format .\nuv run mypy\n</code></pre> <p>Guidance:</p> <ul> <li>Ruff handles both linting and formatting (see pyproject.toml configuration).</li> <li>MyPy enforces strict typing (disallow_untyped_defs, strict_equality, etc.).</li> <li>Coverage requirement: 80% minimum enforced in CI.</li> <li>If you must ignore a rule, prefer the narrowest scope and document why.</li> </ul> <p>Warning</p> <p>Coverage Requirements: The project enforces 80% test coverage. Local runs omit coverage flags for convenience, but CI will fail if coverage drops below 80%.</p>"},{"location":"guides/local-development/#running-examples","title":"Running examples","text":"<p>List available examples (in the examples repo):</p> Bash<pre><code>git clone https://github.com/GhostWeaselLabs/meridian-runtime-examples.git\nls meridian-runtime-examples/examples/\n</code></pre> <p>Run an example (from the examples repo root):</p> Bash<pre><code># Direct execution\npython examples/minimal_hello/main.py\npython examples/hello_graph/main.py\npython examples/sentiment/main.py --human --timeout-s 6.0\npython examples/streaming_coalesce/main.py --human --timeout-s 5.0\npython examples/pipeline_demo/main.py\n</code></pre> <p>Troubleshooting examples:</p> <ul> <li>If imports fail, ensure your virtualenv is active and the project is installed in editable mode (uv sync already does this).</li> <li>For long-running examples, add structured logging or increase log verbosity as needed.</li> </ul> <p>Tip</p> <p>Make Target Parameters: Override demo parameters with environment variables: Bash<pre><code>RATE_HZ=20 TICK_MS=10 python examples/sentiment/main.py --human\nCOAL_RATE_HZ=600 CAP_AGG_TO_SINK=8 python examples/streaming_coalesce/main.py --human\n</code></pre></p>"},{"location":"guides/local-development/#local-observability","title":"Local observability","text":"<p>Enable structured logs (if configurable via env or config):</p> Bash<pre><code>export MERIDIAN_LOG_LEVEL=info\nuv run python -m examples.hello_graph.main\n</code></pre> <p>Metrics (if exposed locally):</p> <ul> <li>Default port can be set via env or config (e.g., MERIDIAN_METRICS_PORT=8000).</li> <li>Verify with: Bash<pre><code>curl -s localhost:8000/metrics | head\n</code></pre></li> </ul> <p>See also:</p> <ul> <li>Concepts overview</li> <li>Observability details</li> <li>API reference</li> </ul>"},{"location":"guides/local-development/#docs-build-and-preview","title":"Docs: build and preview","text":"<p>Serve docs locally with live reload:</p> Bash<pre><code>make docs-serve\n# or if you prefer direct command:\nmkdocs serve -a 127.0.0.1:8000\n</code></pre> <p>Build docs:</p> Bash<pre><code>uv run mkdocs build\n</code></pre> <p>Docs conventions and templates:</p> <ul> <li>Conventions</li> <li>Guide template</li> <li>Reference template</li> <li>ADR template</li> </ul>"},{"location":"guides/local-development/#developer-workflow","title":"Developer workflow","text":"<ol> <li> <p>Create a feature branch: Bash<pre><code>git checkout -b feat/short-description\n</code></pre></p> </li> <li> <p>Iterate locally: Bash<pre><code>uvx ruff format .\nuvx ruff check .\nuvx mypy\nuvx pytest -q\n</code></pre></p> </li> <li> <p>Update docs if behavior or public APIs change:</p> <ul> <li>Add or edit pages under docs/.</li> <li>Update mkdocs.yml navigation if you add new pages.</li> <li>Verify with mkdocs serve.</li> </ul> </li> <li> <p>Commit with a clear message: Bash<pre><code>git add -A\ngit commit -m \"feat: add X to scheduler (docs: update quickstart and api reference)\"\n</code></pre></p> </li> <li> <p>Push and open a PR: Bash<pre><code>git push -u origin feat/short-description\n</code></pre></p> </li> </ol> <p>Ensure the PR checklist includes:</p> <ul> <li> Tests added/updated</li> <li> Docs added/updated and linked from index or section pages</li> <li> Lint/format/type checks pass</li> </ul>"},{"location":"guides/local-development/#troubleshooting","title":"Troubleshooting","text":"<p>Virtual environment issues</p> <ul> <li>Symptom: ModuleNotFoundError for project modules.</li> <li>Fix: Re-run uv sync; verify that .venv is active; confirm editable install.</li> </ul> <p>Mypy false positives</p> <ul> <li>Narrow ignores with <code># type: ignore[code]</code> and add a comment. Prefer fixing types over ignoring.</li> <li>Project uses strict MyPy configuration; expect type errors for untyped code.</li> </ul> <p>Ruff disagreements</p> <ul> <li>Use <code>uvx ruff format</code> to resolve style issues. For rule exceptions, add inline <code># noqa: RULE</code> sparingly with justification.</li> <li>Line length is 100 characters (see pyproject.toml).</li> </ul> <p>Coverage failures</p> <ul> <li>CI enforces 80% coverage minimum. Run <code>uvx pytest --cov=src --cov-report=term-missing</code> locally.</li> <li>Add tests for new code to maintain coverage.</li> </ul> <p>Docs build failures</p> <ul> <li>Check mkdocs.yml paths after moving/renaming docs.</li> <li>Run <code>make docs-check-links</code> to verify internal links.</li> <li>Lychee link checker is installed via dev-setup.sh.</li> </ul>"},{"location":"guides/local-development/#useful-commands","title":"Useful commands","text":"Bash<pre><code># Run a single test with verbose output\nuvx pytest tests/test_scheduler.py::test_basic --maxfail=1 -vv\n\n# Profile a test module (example approach; integrate your profiler of choice)\nuvx pytest tests/test_scheduler.py -q\n\n# Run only changed files (pre-commit)\npre-commit run --from-ref origin/main --to-ref HEAD\n\n# Check coverage locally\nuvx pytest --cov=src --cov-report=term-missing\n</code></pre>"},{"location":"guides/local-development/#next-steps","title":"Next steps","text":"<ul> <li>Quickstart</li> <li>Examples</li> <li>Patterns</li> <li>API reference</li> <li>Contributing guide</li> </ul>"},{"location":"guides/migration-extension/","title":"Migration and extension guide","text":"<p>This guide shows how to:</p> <ul> <li>Migrate existing custom <code>Node</code> subclasses to built-in node classes under <code>meridian.nodes</code></li> <li>Decide when to use built-ins vs writing custom nodes</li> <li>Extend and compose built-in nodes for specialized behaviors</li> </ul> <p>Tip</p> <p>Built-ins favor composition over inheritance. Prefer wiring multiple simple nodes over subclassing a large custom node.</p>"},{"location":"guides/migration-extension/#when-to-use-built-ins-vs-custom","title":"When to use built-ins vs custom","text":"<ul> <li>Use built-ins when your logic matches a common pattern:</li> <li>Producer/consumer, map/filter/flatmap</li> <li>Routing, splitting, merging</li> <li>Event windowing/correlation, triggers</li> <li>Async/concurrent workers</li> <li>Storage/file IO, HTTP/websocket, simple queues</li> <li>Metrics/alerting/sampling</li> <li>Validation/serialization/compression/encryption</li> <li>Flow-control (throttle, circuit breaker, retry, timeout)</li> <li>Write a custom node when you need:</li> <li>A new port/flow pattern not covered above</li> <li>A domain adapter with external APIs and custom lifecycles</li> <li>Highly specialized performance optimizations (after measuring)</li> </ul>"},{"location":"guides/migration-extension/#migration-cookbook","title":"Migration cookbook","text":"Map/FilterProducerConsumerEvent windowsAsync workEncryption <p>Original custom node:</p> Python<pre><code>from meridian.core import Node, Message, MessageType\n\nclass Double(Node):\n    def __init__(self):\n        super().__init__(\"double\", inputs=[], outputs=[])\n    def _handle_message(self, port: str, msg: Message) -&gt; None:\n        if msg.type == MessageType.DATA:\n            self.emit(\"out\", Message(MessageType.DATA, msg.payload * 2))\n</code></pre> <p>Migrate to built-in:</p> Python<pre><code>from meridian.nodes import MapTransformer\ndouble = MapTransformer(\"double\", transform_fn=lambda x: x * 2)\n</code></pre> Python<pre><code>from meridian.nodes import DataProducer\n\nsource = lambda: iter(range(100))\nproducer = DataProducer(\"p\", data_source=source, interval_ms=0)\n</code></pre> Python<pre><code>from meridian.nodes import DataConsumer\n\nresults: list[int] = []\nsink = DataConsumer(\"c\", handler=results.append)\n</code></pre> Python<pre><code>from meridian.nodes import EventAggregator\n\nagg = EventAggregator(\"agg\", window_ms=1000, aggregation_fn=lambda xs: sum(xs))\n</code></pre> Python<pre><code>from meridian.nodes import AsyncWorker\n\nasync def fn(x: int) -&gt; int: ...\naw = AsyncWorker(\"aw\", async_fn=fn, max_concurrent=8)\n</code></pre> Python<pre><code>from meridian.nodes import EncryptionNode, EncryptionAlgorithm, EncryptionMode\n\nkey = b\"0\" * 32\nenc = EncryptionNode(\"enc\", encryption_key=key, algorithm=EncryptionAlgorithm.AES_256_GCM)\ndec = EncryptionNode(\"dec\", encryption_key=key, algorithm=EncryptionAlgorithm.AES_256_GCM, mode=EncryptionMode.DECRYPT)\n</code></pre>"},{"location":"guides/migration-extension/#extension-patterns","title":"Extension patterns","text":"<ul> <li>Compose using subgraphs:</li> </ul> Python<pre><code>from meridian.core import Subgraph\nfrom meridian.nodes import Router, MapTransformer\n\nrouter = Router(\"r\", routing_fn=lambda x: \"errors\" if isinstance(x, dict) and x.get(\"error\") else \"ok\", output_ports=[\"ok\", \"errors\"])\nredact = MapTransformer(\"redact\", transform_fn=lambda d: {**d, \"secret\": \"***\"})\n\ng = Subgraph.from_nodes(\"authz\", [router, redact])\n# wire router.errors -&gt; redact.input; expose ports as needed\n</code></pre> <ul> <li>Wrap domain-specific logic as handler functions:</li> </ul> Python<pre><code>from meridian.nodes import DataConsumer\n\ndef write_to_db(row: dict) -&gt; None:\n    ...\nsink = DataConsumer(\"db_sink\", handler=write_to_db)\n</code></pre> <ul> <li>Subclassing FunctionNode (advanced) \u2014 keep the surface small and composed internally. Prefer composition first.</li> </ul>"},{"location":"guides/migration-extension/#policies-and-errors","title":"Policies and errors","text":"<ul> <li>All built-ins support <code>NodeConfig(error_policy=...)</code> on construction</li> <li>Use <code>ErrorPolicy.EMIT_ERROR</code> to propagate standardized error messages downstream</li> <li>Prefer attaching backpressure/routing via edges and scheduler config rather than custom logic inside nodes</li> </ul>"},{"location":"guides/migration-extension/#performance-notes","title":"Performance notes","text":"<ul> <li>Built-ins are optimized for clarity and composability</li> <li>Use <code>ThrottleNode</code>, <code>RetryNode</code>, <code>CircuitBreakerNode</code> to protect downstream systems</li> <li>For hotspots, measure first; then consider a custom node or specialized handler</li> </ul>"},{"location":"guides/migration-extension/#migration-checklist","title":"Migration checklist","text":"<ul> <li>Replace custom synchronous map/filter logic with <code>MapTransformer</code> / <code>FilterTransformer</code></li> <li>Replace ad-hoc batching with <code>BatchProducer</code> / <code>BatchConsumer</code> / <code>BufferNode</code></li> <li>Replace custom async pools with <code>AsyncWorker</code> and tune <code>max_concurrent</code></li> <li>Replace plain-text encryption with <code>EncryptionNode</code> (AES\u2011GCM/ChaCha20\u2011Poly1305)</li> <li>Centralize error handling with <code>ErrorPolicy</code> and standard error messages</li> </ul>"},{"location":"guides/migration-extension/#example-full-graph-beforeafter","title":"Example: full graph before/after","text":"BeforeAfter Python<pre><code># Custom: ingest \u2192 transform \u2192 sink\nclass Ingest(Node): ...\nclass Transform(Node): ...\nclass Sink(Node): ...\n</code></pre> Python<pre><code>from meridian.nodes import DataProducer, MapTransformer, DataConsumer\n\nprod = DataProducer(\"ingest\", data_source=my_iter, interval_ms=0)\nxf = MapTransformer(\"xf\", transform_fn=my_transform)\nsink = DataConsumer(\"sink\", handler=my_sink)\n</code></pre> <p>Info</p> <p>Need a richer tutorial? See the example modules in the <code>meridian-runtime-examples</code> repository and the Built\u2011in nodes reference.</p>"},{"location":"plan/dr/DR-TEMPLATE/","title":"Decision Record:  <p>Status: Proposed | Accepted | Rejected | Superseded by  Date:  Authors:  Owners: GhostWeasel (Lead: doubletap-dave) <p>Summary Concise overview (2\u20134 sentences) describing the decision, context, and impact.</p> <p>Context and Problem Statement Describe the problem this decision addresses and why it matters. Include relevant constraints, goals, and non-goals.</p> <p>Goals (What this decision should achieve) - \u2026 - \u2026</p> <p>Non-Goals (What this decision does not cover) - \u2026 - \u2026</p> <p>Decision State the decision clearly and unambiguously. If there are multiple parts, number them.</p> <p>Rationale Explain why this approach was chosen over alternatives. Include key trade-offs, guiding principles (e.g., composability, privacy-first, observability), and expected benefits.</p> <p>Alternatives Considered 1) Alternative A    - Pros:    - Cons: 2) Alternative B    - Pros:    - Cons: 3) Do Nothing    - Pros:    - Cons:</p> <p>EARS-Style Acceptance Criteria Use clear, testable statements. - Ubiquitous: \u201cThe system shall \u2026\u201d - Event-driven: \u201cWhen , the system shall \u2026\u201d - State-driven: \u201cWhile , the system shall \u2026\u201d - Unwanted: \u201cIf , the system shall \u2026\u201d <p>Impact API changes, compatibility considerations, and migration needs. Note implications to: - Public APIs (SemVer) - Scheduler/runtime behavior - Observability (logs/metrics/traces) - Privacy posture (no payloads in errors by default; redaction) - Performance and resource usage - Developer experience and documentation</p> <p>Security and Privacy Considerations Identify risks (data exposure, elevated permissions, sensitive logging) and mitigations (redaction, least privilege, opt-in surfaces).</p> <p>Operational Considerations Deployment, configuration, failure modes, rollback strategies, monitoring, and alerting implications.</p> <p>Testing Strategy - Unit tests: - Integration tests: - Regression tests: - Performance/benchmark checks (if applicable):</p> <p>Documentation Plan - README updates - docs/plan updates and cross-references - Examples/recipes - Support and troubleshooting notes</p> <p>Rollout Plan - Phasing/feature flags/opt-in defaults - Backward compatibility measures - Migration steps for users (code snippets, find/replace guidance) - Deprecation timeline (if any)</p> <p>Open Questions - Q1: - Q2:</p> <p>References - Related issues/PRs: - Related DRs: - External references/RFCs:</p> <p>Changelog Summarize what will appear in release notes if accepted.</p> <p>Appendix (Optional) Supporting diagrams, schemas (structure only\u2014no payload contents), or extended analysis.</p>","text":""},{"location":"reference/api/","title":"API Reference","text":""},{"location":"reference/api/#core","title":"Core","text":"<ul> <li><code>meridian.core.Message</code>, <code>MessageType</code></li> <li><code>meridian.core.Port</code>, <code>PortDirection</code>, <code>PortSpec</code></li> <li><code>meridian.core.Edge</code></li> <li><code>meridian.core.Node</code></li> <li><code>meridian.core.Scheduler</code>, <code>SchedulerConfig</code></li> <li><code>meridian.core.Subgraph</code></li> </ul>"},{"location":"reference/api/#built-in-nodes","title":"Built-in nodes","text":"<p>See Built-in nodes for a categorized overview and examples.</p> <p>Complete API documentation for Meridian Runtime classes, methods, and configuration options.</p> <p>Note</p> <p>Import Pattern: All core types are available from the main <code>meridian.core</code> module.</p> <p>Install and import</p> <ol> <li>Prereqs: Python 3.11+, <code>uv</code></li> <li> <p>Install dev tools:</p> <p>Bash<pre><code>uv lock\nuv sync\n</code></pre> 3. Import core primitives:</p> <p>Python<pre><code>from meridian.core import (\n    Message, MessageType, Node, Subgraph, Scheduler, SchedulerConfig,\n    Port, PortDirection, PortSpec, Edge, BackpressureStrategy, RetryPolicy, RoutingPolicy\n)\n</code></pre> 4. Observability:</p> Python<pre><code>from meridian.observability.config import ObservabilityConfig, configure_observability\nfrom meridian.observability.config import get_default_config, get_development_config, get_production_config\nfrom meridian.observability.logging import get_logger, with_context\n</code></pre> </li> </ol>"},{"location":"reference/api/#core-types","title":"Core types","text":""},{"location":"reference/api/#message","title":"Message (<code>meridian.core.message.Message</code>)","text":"<ul> <li> <p>Immutable envelope with:</p> <ul> <li><code>type</code>: <code>MessageType.DATA</code> \u00b7 <code>CONTROL</code> \u00b7 <code>ERROR</code></li> <li><code>payload</code>: <code>Any</code></li> <li><code>metadata</code>: optional <code>Mapping</code></li> <li><code>headers</code>: <code>dict</code> with <code>trace_id</code> and <code>timestamp</code> auto-populated if missing</li> </ul> </li> <li> <p>Helpers:</p> <ul> <li><code>is_data()</code>, <code>is_control()</code>, <code>is_error()</code></li> <li><code>get_trace_id()</code>, <code>get_timestamp()</code>, <code>with_headers(...)</code></li> </ul> </li> <li> <p>Notes:</p> <ul> <li><code>CONTROL</code> and <code>ERROR</code> may be routed or prioritized differently than <code>DATA</code>.</li> </ul> </li> </ul>"},{"location":"reference/api/#message-fields","title":"Message fields","text":"Field Type Default/Behavior <code>type</code> <code>MessageType</code> Required: <code>DATA</code> \u00b7 <code>CONTROL</code> \u00b7 <code>ERROR</code> <code>payload</code> <code>Any</code> Required <code>metadata</code> <code>Mapping[str, Any]</code> | <code>None</code> Optional <code>headers</code> <code>dict[str, Any]</code> Auto-adds <code>trace_id</code> and <code>timestamp</code> if missing <code>get_trace_id()</code> -&gt; <code>str</code> Returns <code>trace_id</code> or <code>\"\"</code> <code>get_timestamp()</code> -&gt; <code>float</code> Returns timestamp or <code>0.0</code> <code>with_headers(...)</code> -&gt; <code>Message</code> Returns a copy with merged headers"},{"location":"reference/api/#ports-and-portspec","title":"Port, PortSpec, PortDirection (<code>meridian.core.ports</code>)","text":"<ul> <li><code>PortDirection</code>: <code>INPUT</code> | <code>OUTPUT</code></li> <li> <p><code>PortSpec(name, schema: type | tuple[type,...] | None, policy: str | None)</code></p> <ul> <li><code>validate(value)</code> performs <code>isinstance</code> checks when schema is provided</li> </ul> </li> <li> <p><code>Port(name, direction, index: int | None = None, spec: PortSpec | None = None)</code></p> </li> </ul>"},{"location":"reference/api/#portspec-summary","title":"Port and PortSpec summary","text":"Symbol Fields Notes <code>PortDirection</code> <code>INPUT</code>, <code>OUTPUT</code> Direction of message flow <code>PortSpec</code> <code>name: str</code> Logical id; typically same as port name <code>schema: type \\| tuple[type,...] \\| None</code> If set, <code>validate(value)</code> uses <code>isinstance</code> <code>policy: str \\| None</code> Hint for router/backpressure layers <code>Port</code> <code>name: str</code> Unique within node <code>direction: PortDirection</code> <code>INPUT</code> or <code>OUTPUT</code> <code>index: int \\| None</code> Optional ordering <code>spec: PortSpec \\| None</code> Optional type/policy hints"},{"location":"reference/api/#node","title":"Node (<code>meridian.core.node.Node</code>)","text":"<ul> <li> <p>Lifecycle hooks:</p> <ul> <li><code>on_start() -&gt; None</code> - Called once when scheduler starts the node</li> <li><code>on_message(port: str, msg: Message) -&gt; None</code> - Called by scheduler when message arrives (calls <code>_handle_message</code>)</li> <li><code>on_tick() -&gt; None</code> - Called periodically by scheduler (calls <code>_handle_tick</code>)</li> <li><code>on_stop() -&gt; None</code> - Called once when scheduler stops the node</li> </ul> </li> <li> <p>Override methods:</p> <ul> <li><code>_handle_message(port: str, msg: Message) -&gt; None</code> - Implement message processing logic</li> <li><code>_handle_tick() -&gt; None</code> - Implement periodic work (timers, maintenance)</li> </ul> </li> <li> <p>Core methods:</p> <ul> <li><code>emit(port: str, msg: Message) -&gt; Message</code> - Publish message on output port (respects backpressure)</li> <li><code>port_map() -&gt; dict[str, Port]</code> - Return mapping of port name to Port for all inputs/outputs</li> </ul> </li> <li> <p>Factory method:</p> <ul> <li><code>Node.with_ports(name: str, input_names: Iterable[str], output_names: Iterable[str]) -&gt; Node</code> - Create node with simple named ports</li> </ul> </li> <li> <p>Emissions respect runtime backpressure when registered to a <code>Scheduler</code>.</p> </li> </ul>"},{"location":"reference/api/#subgraph","title":"Subgraph (<code>meridian.core.subgraph.Subgraph</code>)","text":"<ul> <li><code>Subgraph.from_nodes(name: str, nodes: Iterable[Node]) -&gt; Subgraph</code> - Create subgraph from node list</li> <li><code>connect(src: tuple[str, str], dst: tuple[str, str], capacity: int = 1024, policy: object | None = None) -&gt; str</code> - Connect ports with edge</li> <li><code>add_node(node: Node, name: str | None = None) -&gt; None</code> - Add node to subgraph</li> <li><code>expose_input(name: str, target: tuple[str, str]) -&gt; None</code> - Expose internal input as subgraph input</li> <li><code>expose_output(name: str, source: tuple[str, str]) -&gt; None</code> - Expose internal output as subgraph output</li> <li><code>validate() -&gt; list[ValidationIssue]</code> - Return list of <code>ValidationIssue</code> for structural problems</li> <li><code>node_names() -&gt; list[str]</code> - Return list of contained node names</li> <li><code>inputs_of(node_name: str) -&gt; dict[str, Edge[object]]</code> - Return mapping of input port name to incoming Edge</li> </ul>"},{"location":"reference/api/#edge","title":"Edge (<code>meridian.core.edge.Edge</code>)","text":"<ul> <li>Bounded, in-memory FIFO channel between a source node/port and a target node/port.</li> <li>Validates enqueued values against <code>PortSpec</code> when present; on mismatch logs <code>edge.validation_failed</code> and raises <code>TypeError</code>.</li> <li>Overflow behavior is controlled by a backpressure <code>Policy</code> (see Policies below). If none is provided at enqueue time, the runtime uses the edge's <code>default_policy</code> or falls back to <code>Latest()</code>.</li> </ul> <p>Warning</p> <p>Validation: Edge validation occurs at enqueue time. Invalid payloads raise <code>TypeError</code> and are logged as <code>edge.validation_failed</code>.</p> <ul> <li> <p>Core methods:</p> <ul> <li><code>try_put(item, policy: Policy | None = None)</code> - Attempt to enqueue item, returns <code>PutResult</code></li> <li><code>try_get()</code> - Dequeue next item, returns item or <code>None</code></li> <li><code>depth()</code> - Return current queue depth (updates gauge)</li> <li><code>is_empty()</code> - Return <code>True</code> if queue is empty</li> <li><code>is_full()</code> - Return <code>True</code> if queue at capacity</li> </ul> </li> <li> <p>Edge ID format: <code>\"src_node:src_port-&gt;dst_node:dst_port\"</code></p> </li> <li> <p>Metrics (labeled by a stable <code>edge_id</code> in the form <code>\"src_node:src_port-&gt;dst_node:dst_port\"</code>):</p> <ul> <li><code>edge_enqueued_total</code></li> <li><code>edge_dequeued_total</code></li> <li><code>edge_dropped_total</code></li> <li><code>edge_queue_depth</code> (gauge)</li> <li><code>edge_blocked_time_seconds</code> (histogram)</li> </ul> </li> <li>Representative log events:<ul> <li><code>edge.enqueue</code>, <code>edge.replace</code>, <code>edge.coalesce</code>, <code>edge.coalesce_error</code>, <code>edge.validation_failed</code></li> </ul> </li> </ul> <p>See also: - Policies: #backpressure-and-overflow - PutResult: #putresult - Port/PortSpec: #ports-and-portspec</p>"},{"location":"reference/api/#scheduler","title":"Scheduler and SchedulerConfig (<code>meridian.core.scheduler</code>)","text":"<ul> <li> <p><code>SchedulerConfig</code>:</p> <ul> <li><code>tick_interval_ms</code>: <code>int</code> (default <code>50</code>)</li> <li><code>fairness_ratio</code>: <code>tuple[int,int,int] = (4,2,1)</code>  # (<code>control</code>, <code>high</code>, <code>normal</code>)</li> <li><code>max_batch_per_node</code>: <code>int</code> = <code>8</code></li> <li><code>idle_sleep_ms</code>: <code>int</code> = <code>1</code></li> <li><code>shutdown_timeout_s</code>: <code>float</code> = <code>2.0</code></li> </ul> </li> <li> <p><code>Scheduler(config: SchedulerConfig | None = None)</code></p> <ul> <li><code>register(Node | Subgraph) -&gt; None</code></li> <li><code>run() -&gt; None</code></li> <li><code>shutdown() -&gt; None</code> \u2014 graceful termination</li> <li><code>is_running() -&gt; bool</code> \u2014 return current running state</li> <li><code>get_stats() -&gt; dict[str, int | str]</code> \u2014 return runtime statistics</li> </ul> </li> </ul> <p>Note</p> <p>Error Handling: Exceptions within node handlers are logged and re-raised to the scheduler. The processor applies the runtime's policy and continues shutdown on fatal errors.</p>"},{"location":"reference/api/#schedulerconfig-defaults","title":"SchedulerConfig defaults","text":"Field Type Default Notes <code>tick_interval_ms</code> <code>int</code> <code>50</code> Tick readiness cadence <code>fairness_ratio</code> <code>tuple[int,int,int]</code> <code>(4,2,1)</code> Priority weights (<code>control</code>, <code>high</code>, <code>normal</code>) <code>max_batch_per_node</code> <code>int</code> <code>8</code> Prevents monopolization per slice <code>idle_sleep_ms</code> <code>int</code> <code>1</code> Sleep while idle to reduce CPU churn <code>shutdown_timeout_s</code> <code>float</code> <code>2.0</code> Graceful shutdown when idle"},{"location":"reference/api/#backpressure-and-overflow","title":"Backpressure and overflow (<code>meridian.core.policies</code>)","text":"<p>Note</p> <p>Policy Implementation: The runtime uses internal policy implementations. For high-level control, use <code>BackpressureStrategy</code> and <code>RetryPolicy</code> enums.</p>"},{"location":"reference/api/#putresult","title":"PutResult","text":"<ul> <li><code>OK</code>, <code>BLOCKED</code>, <code>DROPPED</code>, <code>REPLACED</code>, <code>COALESCED</code></li> </ul>"},{"location":"reference/api/#policy-protocol","title":"Policy protocol","text":"<ul> <li><code>on_enqueue(capacity: int, size: int, item: object)</code> -&gt; <code>PutResult</code></li> </ul>"},{"location":"reference/api/#backpressure-strategy","title":"BackpressureStrategy","text":"<p>Note</p> <p>High-level Strategy: Use <code>BackpressureStrategy</code> for runtime-level backpressure control.</p> Strategy Behavior Use Case <code>DROP</code> Prefer dropping items when capacity is reached Telemetry, low-importance streams <code>BLOCK</code> Prefer blocking/yielding when capacity is reached Lossless delivery, critical data"},{"location":"reference/api/#retry-policy","title":"RetryPolicy","text":"<p>Note</p> <p>Retry Behavior: Use <code>RetryPolicy</code> for operations that can be retried on failure.</p> Policy Behavior Use Case <code>NONE</code> Do not retry Critical operations, user-initiated actions <code>SIMPLE</code> Apply simple retry strategy Network operations, transient failures"},{"location":"reference/api/#routing","title":"RoutingPolicy and Routable","text":"Symbol Fields / Methods Behavior Routable route_key() -&gt; str Payload supplies routing key RoutingPolicy key: str = \"default\" Default key if payload is not Routable select(item) -&gt; str Uses item.route_key() if Routable else default"},{"location":"reference/api/#validation-issue","title":"ValidationIssue","text":"<ul> <li><code>ValidationIssue(level: str, code: str, message: str)</code></li> <li>Used by <code>Subgraph.validate()</code> to report structural problems</li> <li>Levels: <code>\"error\"</code>, <code>\"warning\"</code>, <code>\"info\"</code></li> <li>Common codes: <code>\"DUP_NODE\"</code>, <code>\"UNKNOWN_NODE\"</code>, <code>\"NO_SRC_PORT\"</code>, <code>\"BAD_CAP\"</code>, <code>\"DUP_EDGE\"</code></li> </ul>"},{"location":"reference/api/#validation-issues","title":"Common validation issues","text":"Code Level Description Resolution <code>DUP_NODE</code> error Duplicate node names within subgraph Ensure unique node names <code>UNKNOWN_NODE</code> error Edge references non-existent node Check node names in connection tuples <code>NO_SRC_PORT</code> error Source node missing output port Verify port name matches node definition <code>NO_DST_PORT</code> error Target node missing input port Verify port name matches node definition <code>BAD_CAP</code> error Edge capacity \u2264 0 Set capacity to positive integer <code>DUP_EDGE</code> error Duplicate edge identifier Check for duplicate connections <code>DUP_EXPOSE_IN</code> error Duplicate exposed input names Ensure unique external input names <code>DUP_EXPOSE_OUT</code> error Duplicate exposed output names Ensure unique external output names <code>BAD_EXPOSE_IN</code> error Exposed input references invalid target Verify node and port exist <code>BAD_EXPOSE_OUT</code> error Exposed output references invalid source Verify node and port exist <p>Example: minimal pipeline</p> Python<pre><code>from meridian.core import Message, MessageType, Node, Subgraph, Scheduler\nfrom meridian.core.ports import Port, PortDirection, PortSpec\n\nclass Producer(Node):\n    def __init__(self):\n        super().__init__(\n            \"producer\",\n            inputs=[],\n            outputs=[Port(\"out\", PortDirection.OUTPUT, spec=PortSpec(\"out\", float))],\n        )\n        self.count = 0\n        self.max_count = 5\n\n    def _handle_tick(self):\n        if self.count &lt; self.max_count:\n            import time\n            self.emit(\"out\", Message(type=MessageType.DATA, payload=time.time()))\n            self.count += 1\n\nclass Consumer(Node):\n    def __init__(self):\n        super().__init__(\n            \"consumer\",\n            inputs=[Port(\"in\", PortDirection.INPUT, spec=PortSpec(\"in\", float))],\n            outputs=[],\n        )\n        self.values = []\n\n    def _handle_message(self, port, msg):\n        if port == \"in\":\n            self.values.append(msg.payload)\n            print(f\"Consumer received: {msg.payload}\")\n\n# Create and configure the pipeline\nsg = Subgraph.from_nodes(\"hello\", [Producer(), Consumer()])\nsg.connect((\"producer\",\"out\"), (\"consumer\",\"in\"), capacity=16)\n\n# Validate the subgraph structure\nissues = sg.validate()\nif issues:\n    print(\"Validation issues found:\")\n    for issue in issues:\n        print(f\"  {issue.level}: {issue.message}\")\n    exit(1)\n\n# Run with proper lifecycle management\nscheduler = Scheduler()\nscheduler.register(sg)\n\ntry:\n    print(\"Starting pipeline...\")\n    scheduler.run()\nexcept KeyboardInterrupt:\n    print(\"\\nShutting down gracefully...\")\n    scheduler.shutdown()\nexcept Exception as e:\n    print(f\"Error during execution: {e}\")\n    scheduler.shutdown()\n    raise\n</code></pre>"},{"location":"reference/api/#scheduler-examples","title":"Scheduler configuration example","text":"Python<pre><code>from meridian.core import Scheduler, SchedulerConfig\n\ncfg = SchedulerConfig(\n    tick_interval_ms=25,\n    fairness_ratio=(4, 2, 1),\n    max_batch_per_node=8,\n    idle_sleep_ms=1,\n    shutdown_timeout_s=6.0,\n)\nsched = Scheduler(cfg)\n# register graphs...\nsched.run()\n</code></pre>"},{"location":"reference/api/#observability","title":"Observability configuration","text":"Python<pre><code>from meridian.observability.config import ObservabilityConfig, configure_observability\nfrom meridian.observability.config import get_default_config, get_development_config\nfrom meridian.observability.logging import get_logger, with_context\n\n# Use predefined configurations\nconfig = get_development_config()  # or get_default_config(), get_production_config()\nconfigure_observability(config)\n\n# Or configure manually\nconfigure_observability(ObservabilityConfig(\n    log_level=\"INFO\",\n    log_json=False,\n    metrics_enabled=False,\n    tracing_enabled=False,\n))\n\nlogger = get_logger()\nwith with_context(node=\"demo\"):\n    logger.info(\"demo.start\", \"Starting pipeline\", version=\"1.0\")\n</code></pre>"},{"location":"reference/api/#see-also","title":"See also","text":"<ul> <li>Patterns</li> <li>Observability</li> <li>Getting Started Guide</li> </ul>"},{"location":"reference/built-in-nodes/","title":"Built-in node classes","text":"<p>Meridian ships a comprehensive library of built-in nodes under the <code>meridian.nodes</code> module. These nodes cover common patterns and are designed to compose with custom nodes seamlessly.</p>"},{"location":"reference/built-in-nodes/#quick-imports","title":"Quick imports","text":"Python<pre><code>from meridian.nodes import (\n  # Base &amp; testing\n  FunctionNode, NodeConfig, ErrorPolicy, NodeTestHarness,\n  # Basics\n  DataProducer, DataConsumer, MapTransformer, FilterTransformer, FlatMapTransformer,\n  # Controllers\n  Router, Merger, Splitter,\n  # Events\n  EventAggregator, EventCorrelator, TriggerNode,\n  # Workers\n  WorkerPool, AsyncWorker,\n  # Storage\n  CacheNode, BufferNode, FileWriterNode, FileReaderNode,\n  # Network\n  HttpClientNode, HttpServerNode, WebSocketNode, MessageQueueNode,\n  # Monitoring\n  MetricsCollectorNode, HealthCheckNode, AlertingNode, SamplingNode,\n  # Data processing\n  ValidationNode, SerializationNode, CompressionNode, EncryptionNode,\n  # Flow control\n  ThrottleNode, CircuitBreakerNode, RetryNode, TimeoutNode,\n  # State management\n  StateMachineNode, SessionNode, CounterNode, WindowNode,\n)\n</code></pre> <p>Zero-to-node</p> <p>Use <code>NodeTestHarness</code> from <code>meridian.nodes</code> to exercise node behavior without wiring a full graph or scheduler.</p>"},{"location":"reference/built-in-nodes/#categories","title":"Categories","text":"BasicsControllersEventsWorkersStorageNetworkMonitoringData processingFlow controlState management <ul> <li><code>DataProducer</code>: tick-driven message generation from an iterator.</li> <li><code>DataConsumer</code>: handler-based sink for DATA messages.</li> <li><code>MapTransformer</code>, <code>FilterTransformer</code>, <code>FlatMapTransformer</code>.</li> </ul> <ul> <li><code>Router</code>: route by function to named output ports.</li> <li><code>Merger</code>: N\u21921 fan-in across multiple inputs.</li> <li><code>Splitter</code>: broadcast or filter per-output.</li> </ul> <ul> <li><code>EventAggregator</code>: keyed/windowed aggregation.</li> <li><code>EventCorrelator</code>: group by key until completion/timeout.</li> <li><code>TriggerNode</code>: emit on external condition.</li> </ul> <ul> <li><code>WorkerPool</code>: distribute sync work (RR/hash).</li> <li><code>AsyncWorker</code>: async function execution with ordering.</li> </ul> <ul> <li><code>CacheNode</code>: TTL + LRU/FIFO.</li> <li><code>BufferNode</code>: batch and flush by interval/CONTROL.</li> <li><code>FileWriterNode</code>, <code>FileReaderNode</code>.</li> </ul> <ul> <li><code>HttpClientNode</code>: simple HTTP client (urllib).</li> <li><code>HttpServerNode</code>, <code>WebSocketNode</code> (simulated), <code>MessageQueueNode</code> (in-memory).</li> </ul> <ul> <li><code>MetricsCollectorNode</code>, <code>HealthCheckNode</code>, <code>AlertingNode</code>, <code>SamplingNode</code>.</li> </ul> <ul> <li><code>ValidationNode</code> (callable / JSON Schema if installed), <code>SerializationNode</code> (JSON),   <code>CompressionNode</code> (gzip), <code>EncryptionNode</code> (AES\u2011GCM/ChaCha20\u2011Poly1305).</li> </ul> <ul> <li><code>ThrottleNode</code> (token bucket), <code>CircuitBreakerNode</code>, <code>RetryNode</code>, <code>TimeoutNode</code>.</li> </ul> <ul> <li><code>StateMachineNode</code>, <code>SessionNode</code>, <code>CounterNode</code>, <code>WindowNode</code>.</li> </ul>"},{"location":"reference/built-in-nodes/#examples","title":"Examples","text":"Producer \u2192 Map \u2192 Consumer Python<pre><code>from meridian.core import Scheduler, SchedulerConfig, Subgraph\nfrom meridian.nodes import DataProducer, MapTransformer, DataConsumer\n\np = DataProducer(\"p\", data_source=lambda: iter(range(5)), interval_ms=0)\nm = MapTransformer(\"m\", transform_fn=lambda x: x * 2)\nseen = []\nc = DataConsumer(\"c\", handler=seen.append)\n\ng = Subgraph.from_nodes(\"g\", [p, m, c])\ng.connect((\"p\", \"output\"), (\"m\", \"input\"))\ng.connect((\"m\", \"output\"), (\"c\", \"input\"))\n\ns = Scheduler(SchedulerConfig())\ns.register(g)\n# run in background thread for a short period\nimport threading, time\nth = threading.Thread(target=s.run, daemon=True)\nth.start(); time.sleep(0.1); s.shutdown(); th.join()\n</code></pre>"},{"location":"reference/built-in-nodes/#encryptionnode-secure-by-default","title":"EncryptionNode (secure by default)","text":"<p>Hard dependency</p> <p><code>EncryptionNode</code> uses <code>cryptography</code> (AES\u2011GCM/ChaCha20\u2011Poly1305). Ensure it is installed (bundled by default).</p> Python<pre><code>from meridian.nodes import EncryptionNode, EncryptionAlgorithm, EncryptionMode\nkey = b\"0\" * 32\nenc = EncryptionNode(\"enc\", encryption_key=key, algorithm=EncryptionAlgorithm.AES_256_GCM)\ndec = EncryptionNode(\"dec\", encryption_key=key, algorithm=EncryptionAlgorithm.AES_256_GCM, mode=EncryptionMode.DECRYPT)\n</code></pre>"},{"location":"roadmap/","title":"Roadmap","text":"<p>This directory contains the Meridian Runtime roadmap: a sequenced set of milestones that communicate priorities, expected order of work, and scope at a glance.</p>"},{"location":"roadmap/#purpose","title":"Purpose","text":"<ul> <li>Provide a clear, incremental path from foundation to stable releases.</li> <li>Make trade-offs and sequencing explicit so contributors can align efforts.</li> <li>Keep a historical record of planning assumptions as they evolve.</li> </ul>"},{"location":"roadmap/#how-its-organized","title":"How It's Organized","text":"<ul> <li>Milestones are organized to preserve logical order and make sequencing obvious:</li> <li><code>00-...</code>: upstream requirements and architecture inputs</li> <li>Sequential milestones: major development phases leading to v1 and quality passes</li> <li>Each file is a focused, self-contained plan for a milestone with:</li> <li>Goals and non-goals (what's in/out)</li> <li>Deliverables and acceptance criteria</li> <li>Dependencies and risks</li> <li>Rough timelines or checkpoints (if applicable)</li> <li>Links to issues/PRs as the plan progresses</li> </ul>"},{"location":"roadmap/#reading-order-recommended","title":"Reading Order (Recommended)","text":"<ol> <li> <p>EARS Requirements and Architecture    Context and upstream requirements that influence early decisions.</p> </li> <li> <p>Governance and Overview    Project structure, governance, and high-level vision.</p> </li> <li> <p>Bootstrap &amp; CI \u2192 Release v1.0.0    Sequential execution from core bootstrapping to stable release.</p> </li> <li> <p>Quality Pass    Hardening, polish, and quality improvements that require broad coverage.</p> </li> <li> <p>Future Roadmap    Post-v1.0.0 initiatives and long-term planning for future releases.</p> </li> </ol>"},{"location":"roadmap/#faq","title":"FAQ","text":"<p>See our FAQ page for answers to common questions about the roadmap and contributing.</p>"},{"location":"roadmap/#contributing-to-the-roadmap","title":"Contributing to the Roadmap","text":""},{"location":"roadmap/#small-edits-to-an-existing-milestone","title":"Small Edits to an Existing Milestone","text":"<p>Make a PR that: - Clearly states the change (scope adjustment, acceptance criteria, dependency update). - Links to evidence (benchmarks, incidents, prototypes) when changing scope or risk.</p>"},{"location":"roadmap/#new-milestone-proposal","title":"New Milestone Proposal","text":"<ol> <li>Copy the template below into a new <code>milestone-title.md</code> (use descriptive names that indicate the milestone's purpose).</li> <li>Open a PR and request review from maintainers.</li> </ol>"},{"location":"roadmap/#renumbering-or-resequencing","title":"Renumbering or Resequencing","text":"<ul> <li>Avoid churn. If order must change, prefer updating dependencies and \"Order of operations\" instead of renaming files.</li> <li>If a rename is necessary, include redirect notes in docs (if external links exist) and update references across the repo.</li> </ul>"},{"location":"roadmap/#milestone-template","title":"Milestone Template","text":"<p>Copy this into a new file and fill in the sections. Keep it tight and actionable.</p> YAML<pre><code>---\ntitle: milestone-concise-title\nstatus: proposed | accepted | in-progress | done | deferred\nowner: maintainer-or-team\nlast_updated: YYYY-MM-DD\ndependencies: [previous-milestone, external-reqs]\n---\n</code></pre>"},{"location":"roadmap/#summary","title":"Summary","text":"<p>One paragraph: what this milestone achieves and why it's important now.</p>"},{"location":"roadmap/#goals","title":"Goals","text":"<ul> <li>Concrete, testable outcomes</li> <li>User-visible improvements and/or technical capabilities</li> </ul>"},{"location":"roadmap/#non-goals","title":"Non-goals","text":"<ul> <li>Explicitly out-of-scope items to prevent scope creep</li> </ul>"},{"location":"roadmap/#deliverables","title":"Deliverables","text":"<ul> <li>Features and artifacts (docs, examples, APIs, tooling)</li> <li>Acceptance criteria (how we know we're done)</li> </ul>"},{"location":"roadmap/#order-of-operations","title":"Order of Operations","text":"<ol> <li>Step or sub-workstream with rationale</li> <li>Step or sub-workstream</li> <li>Step or sub-workstream</li> </ol>"},{"location":"roadmap/#risks-and-mitigations","title":"Risks and Mitigations","text":"<ul> <li>Risk: description</li> <li>Mitigation: approach</li> <li>Risk: description</li> <li>Mitigation: approach</li> </ul>"},{"location":"roadmap/#validation","title":"Validation","text":"<ul> <li>Tests (unit/integration/perf) and benchmarks</li> <li>Dogfooding plan or example(s)</li> <li>Observability criteria (metrics/logs/traces to watch)</li> </ul>"},{"location":"roadmap/#links","title":"Links","text":"<ul> <li>Tracking issue(s)</li> <li>Related ADRs/design docs</li> <li>Dependent issues/PRs</li> </ul>"},{"location":"roadmap/#maintainer-guidance","title":"Maintainer Guidance","text":"<ul> <li>Prefer additive edits over file renames to reduce churn.</li> <li>Keep milestone content focused on outcomes and criteria; link to detailed design docs or ADRs rather than embedding them here.</li> <li>When a milestone completes, add a short \"post-mortem\" note: what changed vs. plan, lessons learned, follow-ups.</li> </ul>"},{"location":"roadmap/#questions-or-proposals","title":"Questions or Proposals","text":"<ul> <li>Open a discussion or PR with your suggested changes.</li> <li>For larger changes, draft an ADR and link it from the affected milestones.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/","title":"EARS Master Requirements and Architecture","text":""},{"location":"roadmap/00-ears-requirements-and-architecture/#overview","title":"Overview","text":"<p>This document codifies the essential requirements using the EARS pattern and establishes the top\u2011level architecture for Meridian's minimal, reusable graph runtime. It governs the design, implementation, testing, and operations of v1 and aligns downstream plans and milestone files.</p>"},{"location":"roadmap/00-ears-requirements-and-architecture/#legend-ears","title":"Legend (EARS)","text":"<ul> <li>Ubiquitous: \"The system shall \u2026\"</li> <li>Event-driven: \"When , the system shall \u2026\" <li>Unwanted behavior: \"If , the system shall \u2026\" <li>State-driven: \"While , the system shall \u2026\" <li>Complex: \"Where , the system shall \u2026\""},{"location":"roadmap/00-ears-requirements-and-architecture/#1-ears-requirements","title":"1. EARS Requirements","text":""},{"location":"roadmap/00-ears-requirements-and-architecture/#11-core-model-and-apis","title":"1.1 Core Model and APIs","text":"<ul> <li>Ubiquitous: The system shall model applications as graphs of Nodes connected by typed Edges and composed into Subgraphs.</li> <li>Ubiquitous: The system shall expose public APIs for Node, Edge, Subgraph, Scheduler, Message, PortSpec, and Policies.</li> <li>Ubiquitous: The system shall be framework\u2011agnostic and in\u2011process, with APIs friendly to asyncio usage without requiring it.</li> <li>Ubiquitous: The system shall prefer small files (~200 lines/file) and SRP/DRY throughout the codebase.</li> <li>Ubiquitous: The system shall provide reproducible development with a <code>uv</code>\u2011native workflow (init, lock, sync, run).</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#12-node-lifecycle-and-behavior","title":"1.2 Node Lifecycle and Behavior","text":"<ul> <li>Ubiquitous: The system shall define Node lifecycle hooks: <code>on_start</code>, <code>on_message</code>, <code>on_tick</code>, <code>on_stop</code>.</li> <li>Event-driven: When a message arrives on an input port, the system shall invoke <code>on_message(port, msg)</code> for the target Node.</li> <li>Event-driven: When the configured tick cadence elapses, the system shall invoke <code>on_tick</code> for runnable Nodes.</li> <li>Unwanted: If a Node raises an exception in a lifecycle hook, the system shall capture and report it via observability and apply the Node's error policy (default: skip and continue).</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#13-messaging-types-and-ports","title":"1.3 Messaging, Types, and Ports","text":"<ul> <li>Ubiquitous: The system shall define Message with payload and headers (<code>trace_id</code>, <code>timestamp</code>, <code>schema_version</code>, <code>content_type</code>, \u2026).</li> <li>Ubiquitous: The system shall define PortSpec with name, schema/type, and overflow policy fields.</li> <li>Ubiquitous: Edge validation shall apply to <code>Message.payload</code> (or raw value) against <code>PortSpec.schema</code>, not the Message container type.</li> <li>Complex: Where a schema adapter (e.g., Pydantic) is present, the system shall validate payloads according to the provided model without adding a hard dependency.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#14-edges-capacity-and-overflow-policies","title":"1.4 Edges, Capacity, and Overflow Policies","text":"<ul> <li>Ubiquitous: The system shall implement typed, bounded Edges with capacity.</li> <li>Ubiquitous: The system shall support overflow policies: block (default), drop, latest, and coalesce(fn).</li> <li>Unwanted: If an Edge reaches capacity with policy block, the system shall apply backpressure upstream and avoid busy\u2011waiting.</li> <li>Unwanted: If an Edge reaches capacity with policy drop, the system shall drop new messages and increment a drop metric.</li> <li>Unwanted: If an Edge reaches capacity with policy latest, the system shall retain only the newest message, discarding older ones beyond the limit.</li> <li>Unwanted: If an Edge reaches capacity with policy coalesce, the system shall combine messages using the supplied function and preserve type correctness.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#15-scheduler-readiness-and-priorities","title":"1.5 Scheduler, Readiness, and Priorities","text":"<ul> <li>Ubiquitous: The system shall provide a cooperative Scheduler that advances Nodes based on readiness (messages/ticks), fairness, and priorities.</li> <li>Complex: Where an Edge is marked control\u2011plane, the Scheduler shall prioritize its processing over normal data\u2011plane work.</li> <li>State-driven: While the Scheduler is running, it shall maintain fair service among runnable Nodes to avoid starvation.</li> <li>Event-driven: When shutdown is requested, the system shall gracefully stop Nodes and drain/flush Edges according to policies and timeout.</li> <li>Ubiquitous: The system shall expose runtime mutators for edge priority and capacity with validation and safe application.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#16-observability-logs-metrics-tracing","title":"1.6 Observability (Logs, Metrics, Tracing)","text":"<ul> <li>Ubiquitous: The system shall emit structured JSON logs for lifecycle events, exceptions, and key actions.</li> <li>Ubiquitous: The system shall expose metrics for Nodes (ticks, processed, errors), Edges (depth, rates, drops, blocked time), and Scheduler (runnable nodes, loop latency, priority usage).</li> <li>Complex: Where tracing is enabled, the system shall propagate correlation IDs and create spans at Node and Edge boundaries.</li> <li>Unwanted: If a message is dropped, the system shall increment a drop metric and avoid log flooding (debug\u2011level or rate\u2011limited logs).</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#17-validation-composition-and-contracts","title":"1.7 Validation, Composition, and Contracts","text":"<ul> <li>Ubiquitous: The system shall validate Subgraph composition: unique names, port existence, schema compatibility, positive capacities, and consistent policies.</li> <li>Unwanted: If validation fails for a fatal issue, the system shall report validation errors clearly and refuse to run the invalid graph.</li> <li>Complex: Where adapters are available, the system shall optionally perform richer schema checks without introducing mandatory dependencies.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#18-operations-tooling-and-release-quality","title":"1.8 Operations, Tooling, and Release Quality","text":"<ul> <li>Ubiquitous: The system shall support <code>uv</code> workflows for development, testing, and examples.</li> <li>Ubiquitous: The system shall provide scaffolding commands to generate Node/Subgraph skeletons with typing and tests.</li> <li>Ubiquitous: The system shall maintain high coverage (\u226590% core; \u226580% overall), linting, and typing gates in CI.</li> <li>Ubiquitous: The system shall follow Semantic Versioning and publish artifacts with a documented deprecation policy.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#19-performance-and-reliability","title":"1.9 Performance and Reliability","text":"<ul> <li>State-driven: While under sustained load, the system shall maintain bounded queue depths by applying backpressure and configured policies.</li> <li>Unwanted: If the system is idle (no runnable Nodes), it shall avoid busy loops and use an efficient idle strategy.</li> <li>Complex: Where observability is enabled, the system shall remain low\u2011overhead; tracing shall be disabled by default and fast no\u2011op when off.</li> <li>Event-driven: When bursts occur, the system shall enforce overflow policies deterministically and preserve fairness guarantees.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#110-security-and-compliance","title":"1.10 Security and Compliance","text":"<ul> <li>Ubiquitous: The system shall not embed secrets and shall recommend external configuration for sensitive data.</li> <li>Complex: Where payloads might include sensitive information, the system shall provide hooks for log redaction at the application layer.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#2-architecture","title":"2. Architecture","text":""},{"location":"roadmap/00-ears-requirements-and-architecture/#21-package-layout-toplevel","title":"2.1 Package Layout (Top\u2011Level)","text":"Text Only<pre><code>core/\n  message.py \u2014 Message and header helpers (trace/timestamps).\n  ports.py \u2014 PortSpec, schema typing, adapter glue.\n  policies.py \u2014 Overflow policies: block/drop/latest/coalesce.\n  edge.py \u2014 Bounded queue, typed, metrics hooks, backpressure.\n  node.py \u2014 Base class, lifecycle, emit routing.\n  subgraph.py \u2014 Composition, expose ports, validation.\n  scheduler.py \u2014 Cooperative loop, priorities, fairness, shutdown.\nobservability/\n  logging.py \u2014 JSON logs, context enrichment.\n  metrics.py \u2014 Interfaces, no\u2011op default, Prometheus adapter.\n  tracing.py \u2014 Optional tracing adapter, contextvars propagation.\nutils/\n  ids.py \u2014 Correlation/IDs helpers.\n  time.py \u2014 Time/timing helpers, monotonic clocks.\n  validation.py \u2014 Contract checks for ports/graphs; Issue model.\nscaffolding/\n  generate_node.py \u2014 Node generator CLI and templates.\n  generate_subgraph.py \u2014 Subgraph generator CLI and templates.\nexamples/\n  hello_graph/, pipeline_demo/ \u2014 Runnable examples.\n</code></pre>"},{"location":"roadmap/00-ears-requirements-and-architecture/#22-core-responsibilities-and-interactions","title":"2.2 Core Responsibilities and Interactions","text":"<ul> <li>Message: Immutable\u2011by\u2011convention container with headers; ensures <code>trace_id</code> presence.</li> <li>PortSpec: Describes port schema and default policy; drives Edge typing and validation.</li> <li>Policy: Encapsulates overflow behavior; returns decisions that Edge applies.</li> <li>Edge: Owns capacity, queue, and applies policy; exposes metrics intents and depth.</li> <li>Node: Implements lifecycle; uses <code>emit()</code> to push messages through output ports.</li> <li>Subgraph: Manages Nodes, connects ports via Edges, exposes inputs/outputs; validates wiring.</li> <li>Scheduler: Discovers readiness (messages or tick), enforces priorities and fairness, drives Node hooks, cooperates with backpressure.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#23-scheduling-model","title":"2.3 Scheduling Model","text":"<ul> <li>Readiness Sources:</li> <li>Message\u2011ready: Node has non\u2011empty input queues.</li> <li>Tick\u2011ready: Node's tick interval elapsed (global cadence with hints).</li> <li>Priority Bands:</li> <li>Control-plane &gt; High &gt; Normal (simple ratios, e.g., 4:2:1).</li> <li>Node's effective band is the highest of its ready inputs.</li> <li>Fairness:</li> <li>Round\u2011robin within band; bounded work per turn (batch size) to control tail latency.</li> <li>Backpressure Cooperation:</li> <li><code>emit()</code> \u2192 <code>Edge.put()</code> returns <code>PutResult</code>: OK | BLOCKED | DROPPED | COALESCED.</li> <li>BLOCKED yields producer slot; consumer is scheduled to make forward progress.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#24-validation-model","title":"2.4 Validation Model","text":"<ul> <li>Graph Validation:</li> <li>Unique node names; unique edge IDs; valid capacities (&gt;0).</li> <li>Port existence and schema compatibility; exposure maps to real ports.</li> <li>Policy presence and sensible defaults.</li> <li>Issues:</li> <li>Severity: error | warning; clear messages with location (node/port/edge).</li> <li>Fatal errors prevent run; warnings logged for visibility.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#25-observability-model","title":"2.5 Observability Model","text":"<ul> <li>Logs:</li> <li>Line\u2011delimited JSON; fields include <code>ts</code>, <code>level</code>, <code>component</code>, <code>event</code>, <code>node</code>, <code>port</code>, <code>edge_id</code>, <code>trace_id</code>.</li> <li>Levels: info for lifecycle; debug for high\u2011rate events; warn/error for issues.</li> <li>Metrics:</li> <li>Node: <code>messages_total</code>, <code>errors_total</code>, <code>tick_duration</code> histogram.</li> <li>Edge: <code>enqueued_total</code>, <code>dequeued_total</code>, <code>dropped_total</code>, <code>queue_depth</code>, <code>blocked_time</code> seconds.</li> <li>Scheduler: <code>runnable_nodes</code>, <code>loop_latency</code> histogram, <code>priority_applied</code> counters.</li> <li>Tracing:</li> <li>Optional spans for <code>on_message</code>/<code>on_tick</code> and edge events; correlation via <code>headers.trace_id</code> and contextvars.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#26-configuration-and-mutability","title":"2.6 Configuration and Mutability","text":"<ul> <li>SchedulerConfig (constructor or builder):</li> <li><code>tick_interval_ms</code>, <code>fairness_ratio</code>, <code>max_batch_per_node</code>, <code>idle_sleep_ms</code>, <code>shutdown_timeout_s</code>.</li> <li>Runtime Mutators:</li> <li><code>set_priority(edge_id, priority)</code></li> <li><code>set_capacity(edge_id, capacity)</code></li> <li>ObservabilityConfig:</li> <li>logs: level, json</li> <li>metrics: exporter=noop|prometheus, buckets</li> <li>tracing: enabled, provider=opentelemetry|noop, sample_rate</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#27-performance-principles","title":"2.7 Performance Principles","text":"<ul> <li>Keep hot paths allocation\u2011light; prebind metric label handles.</li> <li>Use integer IDs internally; map to labels lazily for export.</li> <li>Avoid per\u2011message heavy validation; support adapters for strict modes.</li> <li>Bound per\u2011iteration work to avoid tail\u2011latency blowups.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#28-error-handling-and-shutdown","title":"2.8 Error Handling and Shutdown","text":"<ul> <li>Node Errors:</li> <li>Catch and record; default policy \"skip and continue\" until a more advanced policy is configured.</li> <li>Shutdown:</li> <li>Stop accepting new inputs; attempt drain per policy; on timeout, finalize with best effort.</li> <li>Invoke <code>on_stop</code> in reverse topological order.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#29-security-and-compliance-considerations","title":"2.9 Security and Compliance Considerations","text":"<ul> <li>No embedded secrets; configuration externalized.</li> <li>Log redaction hooks available for payloads; off by default.</li> <li>Documentation notes for safe deployment patterns.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#3-traceability-to-milestones","title":"3. Traceability to Milestones","text":"<ul> <li>M1 Bootstrap &amp; CI: Satisfies Ops and Release Quality requirements (1.8).</li> <li>M2 Core Primitives: Satisfies Core Model/APIs (1.1), Node/Ports/Messaging (1.2\u20131.4), and Validation (1.7).</li> <li>M3 Scheduler: Satisfies Scheduling (1.5), Backpressure cooperation, and Shutdown semantics.</li> <li>M4 Observability: Satisfies Observability (1.6), including logs/metrics/tracing wiring.</li> <li>M5 Utilities &amp; Scaffolding: Satisfies Operations/Tooling (1.8) and Validation helpers (1.7).</li> <li>M6 Examples &amp; Docs: Demonstrates Core, Policies, Priorities, and Observability in runnable form.</li> <li>M7 Testing &amp; Hardening: Satisfies Performance and Reliability (1.9), coverage targets, and soak/stress.</li> <li>M8 Release: Satisfies Versioning/Artifacts and deprecation policies under (1.8).</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#4-acceptance-criteria-master","title":"4. Acceptance Criteria (Master)","text":"<ul> <li>Public APIs for Node, Edge, Subgraph, Scheduler, Message, PortSpec, and Policies are implemented and documented.</li> <li>Scheduler enforces readiness, fairness, and control\u2011plane priority; backpressure is cooperative and non\u2011busy.</li> <li>Bounded Edges enforce capacity with policies block/drop/latest/coalesce and expose depth/rate/drop metrics.</li> <li>Observability provides JSON logs, metrics interface (no\u2011op + Prometheus adapter), and optional tracing hooks; overhead acceptable.</li> <li>Validation guards composition with explicit Issues and clear errors for fatal misconfigurations.</li> <li>Examples run via <code>uv</code>; docs provide quickstart, API overview, patterns, troubleshooting, and observability guidance.</li> <li>CI gates: lint, type, tests, coverage; core \u226590%, overall \u226580%.</li> <li>Semantic Versioning process in place; initial stable release criteria met.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#5-risks-and-mitigations","title":"5. Risks and Mitigations","text":"<ul> <li>Overengineering Scheduler or Policies:</li> <li>Mitigation: Keep v1 cooperative and band\u2011biased; no complex RT algorithms; policies encapsulated with small interfaces.</li> <li>Hidden Domain Coupling:</li> <li>Mitigation: No domain\u2011specific types; examples remain neutral; adapters optional.</li> <li>Observability Overhead:</li> <li>Mitigation: No\u2011op defaults; guard debug logs; pre\u2011bound labels; tracing disabled by default.</li> <li>API Instability:</li> <li>Mitigation: EARS master governs changes; changelog and deprecations formalized; tests enforce contracts.</li> <li>Performance Regressions:</li> <li>Mitigation: Benchmarks with budgets; CI regression checks; profiling before release.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#6-glossary","title":"6. Glossary","text":"<ul> <li>Control\u2011plane: Edges carrying critical signals (e.g., kill switch) that must preempt data\u2011plane work.</li> <li>Backpressure: Mechanism to slow upstream producers when downstream capacity is exhausted.</li> <li>Coalesce: Policy that merges multiple queued messages into a single representative message to compress bursts.</li> <li>Runnable: A Node ready to execute due to available input or elapsed tick cadence.</li> <li>Fairness: Guarantee that no ready Node remains perpetually starved under the Scheduler's policy.</li> </ul>"},{"location":"roadmap/00-ears-requirements-and-architecture/#7-change-management","title":"7. Change Management","text":"<ul> <li>Any change to public APIs or core semantics must update this master file and relevant milestone plans.</li> <li>Deviations from EARS requirements must be discussed, recorded here, and reflected in docs and tests before merging.</li> <li>Version bumps and deprecations follow the Release milestone policy.</li> </ul>"},{"location":"roadmap/bootstrap-and-ci/","title":"Milestone M1: Project Bootstrap and CI","text":""},{"location":"roadmap/bootstrap-and-ci/#overview","title":"Overview","text":"<p>Establish the repository scaffold, development workflow, and CI guardrails to enable rapid, consistent iteration. This milestone sets conventions (SRP/DRY, ~200 lines per file), pins toolchain versions, and ensures all contributors can build, lint, type-check, and test locally and in CI using <code>uv</code>.</p>"},{"location":"roadmap/bootstrap-and-ci/#goals-ears","title":"Goals (EARS)","text":"<ul> <li>The system shall be bootstrapped as a Python 3.11+ project managed by <code>uv</code>. [DONE]</li> <li>The system shall provide a deterministic local dev loop: <code>uv lock</code> \u2192 <code>uv sync</code> \u2192 <code>uv run</code> / <code>uvx</code>. [DONE]</li> <li>The system shall enforce code quality via linting and formatting checks. [DONE]</li> <li>The system shall enforce typing via static analysis. [DONE]</li> <li>The system shall run tests with coverage reports and thresholds. [DONE \u2014 TEMPORARY RELAXATION]</li> <li>When code is pushed or a PR is opened, the CI shall run lint, type, and tests across supported Python versions (initially 3.11). [DONE]</li> <li>If coverage thresholds are not met (\u226590% core, \u226580% overall), the CI shall fail. [TEMPORARILY RELAXED FOR M1]</li> <li>The system shall publish a minimal <code>README</code>, <code>LICENSE</code>, and <code>CHANGELOG</code> skeletons. [DONE]</li> </ul>"},{"location":"roadmap/bootstrap-and-ci/#deliverables","title":"Deliverables","text":"<ul> <li><code>pyproject.toml</code> configured for:<ul> <li>Python 3.11</li> <li><code>uv</code>-managed dev loop</li> <li><code>ruff</code> (lint), <code>black</code> (format), <code>mypy</code> (types), <code>pytest</code> + coverage (tests) [DONE]</li> </ul> </li> <li>Repo structure:<ul> <li><code>src/meridian/\u2026</code> (package skeletons: <code>core/</code>, <code>observability/</code>, <code>utils/</code>) [DONE]</li> <li><code>examples/</code> (placeholder) [DONE]</li> <li><code>tests/unit/</code>, <code>tests/integration/</code> (smoke scaffolds) [DONE]</li> <li><code>docs/</code> (existing), <code>docs/plan/</code> (this file) [DONE]</li> <li><code>.github/workflows/ci.yml</code> [DONE]</li> </ul> </li> <li>Baseline configuration:<ul> <li><code>ruff.toml</code> [DONE]</li> <li><code>mypy.ini</code> [DONE]</li> <li><code>.editorconfig</code> [DONE]</li> <li><code>.gitignore</code> (Python + <code>uv</code> caches) [DONE]</li> </ul> </li> <li>Documentation:<ul> <li><code>README.md</code> (quickstart/dev loop) [UPDATED]</li> <li><code>CHANGELOG.md</code> (Keep a Changelog format, SemVer) [UPDATED]</li> <li><code>LICENSE</code> (BSD 3-Clause) [ADDED]</li> </ul> </li> <li>Verified CI run passing on main branch with the scaffold. [DONE]</li> </ul>"},{"location":"roadmap/bootstrap-and-ci/#scope-and-tasks","title":"Scope and Tasks","text":""},{"location":"roadmap/bootstrap-and-ci/#1-repository-and-tooling","title":"1. Repository and Tooling","text":"<ul> <li>Create <code>pyproject.toml</code>:<ul> <li>Project metadata (name: meridian-runtime, version: 0.0.0, license: BSD 3-Clause)</li> <li>Dependencies: none (runtime) for M1</li> <li>Dev dependencies: <code>ruff</code>, <code>black</code>, <code>mypy</code>, <code>pytest</code>, <code>pytest-cov</code>, <code>types-*</code></li> <li><code>[tool.ruff]</code>, <code>[tool.black]</code>, <code>[tool.pytest.ini_options]</code> sections</li> </ul> </li> <li>Initialize <code>uv</code> workflow:<ul> <li><code>uv init</code>, <code>uv lock</code>, <code>uv sync</code></li> <li>Doc quickstart commands in <code>README</code></li> </ul> </li> </ul>"},{"location":"roadmap/bootstrap-and-ci/#2-codebase-layout","title":"2. Codebase Layout","text":"<ul> <li>Create packages:<ul> <li><code>src/meridian/__init__.py</code></li> <li><code>src/meridian/core/__init__.py</code></li> <li><code>src/meridian/observability/__init__.py</code></li> <li><code>src/meridian/utils/__init__.py</code></li> <li><code>examples/__init__.py</code></li> </ul> </li> <li>Add placeholder modules with TODO headers so imports resolve in tests.</li> </ul>"},{"location":"roadmap/bootstrap-and-ci/#3-static-checks-and-quality-gates","title":"3. Static Checks and Quality Gates","text":"<ul> <li>Configure <code>ruff</code>:<ul> <li>Enable common rule sets (E, F, I, UP, B)</li> <li>Line length 100\u2013120; exclude generated artifacts</li> </ul> </li> <li>Configure <code>black</code>:<ul> <li>Line length consistent with <code>ruff</code></li> </ul> </li> <li>Configure <code>mypy</code>:<ul> <li>Python version 3.11</li> <li><code>disallow_untyped_defs = True</code> (at least in <code>src/</code>)</li> <li><code>warn_unused_ignores = True</code></li> <li>strict Optional handling</li> <li>separate section for tests with relaxed rules</li> </ul> </li> <li>Add EditorConfig and <code>.gitignore</code>:<ul> <li>Normalize whitespace, end-of-line, utf-8</li> <li>Ignore <code>.venv</code>, <code>.python-version</code>, <code>.mypy_cache</code>, <code>.ruff_cache</code>, <code>.pytest_cache</code>, <code>.coverage</code>, <code>dist</code>, <code>build</code></li> </ul> </li> </ul>"},{"location":"roadmap/bootstrap-and-ci/#4-testing-scaffold","title":"4. Testing Scaffold","text":"<ul> <li><code>tests/unit/test_smoke.py</code>:<ul> <li>Verifies package import and versions [DONE]</li> </ul> </li> <li><code>tests/integration/test_examples_smoke.py</code>:<ul> <li>Placeholder to run a no-op example and import <code>examples</code> package [DONE]</li> </ul> </li> <li>Configure <code>pytest.ini</code> (inside pyproject):<ul> <li><code>testpaths = [\"tests\"]</code> [DONE]</li> <li><code>addopts = \"-q --cov=src --cov-report=term-missing --cov-fail-under=0\"</code> (temporary for M1) [DONE]</li> <li><code>pythonpath = [\"src\", \".\"]</code> to allow importing <code>examples</code> [DONE]</li> <li>markers for unit and integration [DONE]</li> </ul> </li> </ul>"},{"location":"roadmap/bootstrap-and-ci/#5-ci-pipeline","title":"5. CI Pipeline","text":"<ul> <li>Workflow triggers: push and pull_request on main and feature branches [DONE]</li> <li>Jobs:<ul> <li>setup: checkout, set up Python 3.11, install <code>uv</code> [DONE]</li> <li>deps: <code>uv lock</code> &amp;&amp; <code>uv sync</code> [DONE]</li> <li>lint: <code>ruff check .</code>, <code>black --check .</code> [DONE]</li> <li>type: <code>mypy src</code> [DONE]</li> <li>test: <code>uv run pytest</code> [DONE]</li> <li>package: build sdist/wheel and upload artifacts [DONE]</li> </ul> </li> <li>Artifacts:</li> <li>Upload coverage xml and <code>dist/</code> artifacts [DONE]</li> </ul>"},{"location":"roadmap/bootstrap-and-ci/#6-documentation-updates","title":"6. Documentation Updates","text":"<ul> <li><code>README</code> sections:<ul> <li>Quickstart (<code>uv</code> commands)</li> <li>Development (lint, type, test)</li> <li>Contributing conventions (SRP/DRY, ~200 lines/file, typing)</li> </ul> </li> <li><code>CHANGELOG.md</code> initialized with Unreleased section</li> <li><code>LICENSE</code> file added</li> </ul>"},{"location":"roadmap/bootstrap-and-ci/#acceptance-criteria","title":"Acceptance Criteria","text":"<ul> <li>Running the following locally works without errors:<ul> <li><code>uv lock</code> &amp;&amp; <code>uv sync</code> [PASS]</li> <li><code>uvx ruff check .</code> [PASS]</li> <li><code>uvx black --check .</code> [PASS]</li> <li><code>uvx mypy src</code> [PASS]</li> <li><code>uv run pytest</code> (coverage gate temporarily relaxed for M1) [PASS]</li> </ul> </li> <li>CI runs the same checks and passes on a fresh clone. [PASS]</li> <li>Coverage gate temporarily relaxed for M1; to be raised in subsequent milestones. [PASS]</li> <li>Repository contains <code>README</code>, <code>LICENSE</code>, <code>CHANGELOG</code>, and baseline scaffolds. [PASS]</li> </ul>"},{"location":"roadmap/bootstrap-and-ci/#risks-and-mitigations","title":"Risks and Mitigations","text":"<ul> <li>Divergent local dev environments:<ul> <li>Mitigation: Use <code>uv</code> exclusively; document commands in <code>README</code>; provide <code>.editorconfig</code>.</li> </ul> </li> <li>Slow CI feedback:<ul> <li>Mitigation: Cache <code>uv</code> artifacts; split jobs; run lint/type before tests to fail fast.</li> </ul> </li> <li>Overly strict typing blocking progress:<ul> <li>Mitigation: Strict in <code>src/</code>, relaxed in <code>tests/</code>; allow per-file overrides with justification.</li> </ul> </li> </ul>"},{"location":"roadmap/bootstrap-and-ci/#out-of-scope-future-milestones","title":"Out of Scope (Future Milestones)","text":"<ul> <li>Core runtime modules (message, ports, edge, node, subgraph, scheduler)</li> <li>Observability exporters and tracing hooks</li> <li>Examples beyond smoke</li> <li>Release automation</li> </ul>"},{"location":"roadmap/bootstrap-and-ci/#notesdeviations-for-m1","title":"Notes/Deviations for M1","text":"<ul> <li>Coverage threshold relaxed to <code>fail-under=0</code> to allow scaffolding to pass before core runtime work lands; will be raised later (target \u226590% core, \u226580% overall).</li> <li><code>examples/</code> is a placeholder; integration smoke ensures import shape only.</li> <li>Dev tooling can be invoked via <code>uvx</code> locally; CI uses <code>uv run</code> to mirror a synced environment.</li> </ul>"},{"location":"roadmap/bootstrap-and-ci/#traceability","title":"Traceability","text":"<ul> <li>Supports Implementation Plan M1 in the technical blueprint.</li> <li>Satisfies EARS operational requirements for bootstrap, dev loop, and CI quality gates.</li> </ul>"},{"location":"roadmap/bootstrap-and-ci/#checklist","title":"Checklist","text":"<ul> <li> <code>pyproject.toml</code> created and configured</li> <li> <code>uv lock</code>/<code>sync</code> completes cleanly</li> <li> <code>ruff</code>, <code>black</code>, <code>mypy</code>, <code>pytest</code> configs added</li> <li> <code>src/</code>, <code>tests/</code>, <code>examples/</code> scaffolds exist</li> <li> CI workflow defined and passing</li> <li> <code>README</code>, <code>LICENSE</code>, <code>CHANGELOG</code> present</li> <li> Coverage threshold configured and enforced</li> </ul>"},{"location":"roadmap/core-primitives/","title":"Milestone M2: Core Primitives","text":""},{"location":"roadmap/core-primitives/#ears-tasks-and-git-workflow","title":"EARS Tasks and Git Workflow","text":"<p>Branch name: <code>feature/m2-core-primitives</code></p>"},{"location":"roadmap/core-primitives/#ears-loop","title":"EARS Loop","text":"<ul> <li>Explore: review Message, PortSpec, Policies, Edge, Node, Subgraph contracts and tests</li> <li>Analyze: define typing and policy interfaces; validate backpressure semantics</li> <li>Implement: add <code>message.py</code>, <code>ports.py</code>, <code>policies.py</code>, <code>edge.py</code>, <code>node.py</code>, <code>subgraph.py</code> [DONE]</li> <li>Specify checks: unit/integration tests and microbenchmarks; enforce typing and coverage [DONE] [PASS]</li> <li>Commit after each major step</li> </ul>"},{"location":"roadmap/core-primitives/#git-commands","title":"Git Commands","text":"Bash<pre><code>git checkout -b feature/m2-core-primitives\ngit add -A &amp;&amp; git commit -m \"feat(core): add Message and header helpers\"\ngit add -A &amp;&amp; git commit -m \"feat(core): introduce PortSpec and overflow Policy types\"\ngit add -A &amp;&amp; git commit -m \"feat(core): implement Edge with bounded queue and policies\"\ngit add -A &amp;&amp; git commit -m \"feat(core): add Node base with lifecycle and emit\"\ngit add -A &amp;&amp; git commit -m \"feat(core): add Subgraph composition and validation\"\ngit add -A &amp;&amp; git commit -m \"test(core): cover policies, edge behavior, and validation\"\ngit push -u origin feature/m2-core-primitives\n</code></pre> <p>Open PR early; keep commits small and focused.</p>"},{"location":"roadmap/core-primitives/#overview","title":"Overview","text":"<p>Deliver the foundational runtime types and behaviors: Message, PortSpec, overflow Policies, Edge (bounded queues with metrics/backpressure), Node (base class and lifecycle), and Subgraph (composition and validation). This milestone establishes the core contracts, typing discipline, and correctness properties upon which the scheduler and observability will build.</p>"},{"location":"roadmap/core-primitives/#ears-requirements","title":"EARS Requirements","text":"<ul> <li>The system shall define Message with payload and headers (<code>trace_id</code>, <code>timestamp</code>, <code>schema_version</code>, <code>content_type</code>, \u2026).</li> <li>The system shall define PortSpec with name, schema, and overflow policy fields; schemas may be Python types, TypedDicts, or Pydantic models (optional).</li> <li>The system shall provide overflow policies: block (default), drop, latest, and coalesce(fn).</li> <li>The system shall implement Edge as a typed, bounded queue enforcing the configured overflow policy and exposing metrics hooks.</li> <li>The system shall implement Node with lifecycle hooks (<code>on_start</code>, <code>on_message</code>, <code>on_tick</code>, <code>on_stop</code>) and an emit helper for outputs.</li> <li>The system shall implement Subgraph for composition, port exposure, and validation of wiring and contracts.</li> <li>When an edge reaches capacity and policy is block, the system shall apply backpressure upstream.</li> <li>If an edge reaches capacity and policy is drop, the system shall drop new messages and increment a drop metric.</li> <li>If an edge reaches capacity and policy is latest, the system shall retain only the newest message.</li> <li>If an edge reaches capacity and policy is coalesce, the system shall combine messages using a supplied function.</li> <li>The system shall be asyncio-friendly and avoid forcing blocking operations within core structures.</li> <li>The system shall remain framework-agnostic and keep files ~200 lines with SRP/DRY.</li> </ul>"},{"location":"roadmap/core-primitives/#deliverables","title":"Deliverables","text":"<ul> <li><code>src/meridian/core/message.py</code><ul> <li>Message dataclass: <code>payload: Any</code>; <code>headers: dict[str, Any]</code>; helpers for timestamp and <code>trace_id</code>.</li> <li>Header normalization and validation helpers.</li> </ul> </li> <li><code>src/meridian/core/ports.py</code><ul> <li>PortSpec: name, schema, policy enum or object; optional codec placeholder.</li> <li>Schema adapters: stdlib typing, TypedDict; Pydantic integration hooks (no hard dependency).</li> </ul> </li> <li><code>src/meridian/core/policies.py</code><ul> <li>Policy definitions: Block, Drop, Latest, Coalesce(fn).</li> <li>Common interface: <code>on_enqueue(queue_state, item)</code> -&gt; Action and metrics intent.</li> </ul> </li> <li><code>src/meridian/core/edge.py</code><ul> <li>Edge[T]: bounded queue with capacity; typed per PortSpec.</li> <li>Operations: <code>put(msg)</code>, <code>get()</code> -&gt; msg, <code>try_put</code>/<code>try_get</code> where appropriate.</li> <li>Backpressure behavior for block; accounting for drops/latest/coalesce.</li> <li>Metrics hooks: <code>queue_depth</code>, enq/deq counts, drops, <code>blocked_time</code> (interfaces only; wired in M4).</li> <li>Introspection: id, src/dst endpoints, capacity, policy, type/schema.</li> </ul> </li> <li><code>src/meridian/core/node.py</code><ul> <li>Node base class with lifecycle hooks and <code>emit(port, msg)</code> helper.</li> <li>Output registration and type checking against PortSpec.</li> <li>Error policy placeholder (retry/skip/dead-letter) to be expanded later.</li> </ul> </li> <li><code>src/meridian/core/subgraph.py</code><ul> <li>Composition: <code>add_node</code>, <code>connect((node, port), (node, port), capacity, policy)</code>.</li> <li>Expose: <code>expose_input(name, target)</code>, <code>expose_output(name, source)</code>.</li> <li>Validation: unique node/edge names, port existence and type compatibility, acyclic wiring checks (best-effort).</li> <li>Contract: returns issues/warnings list; raise on fatal validation errors.</li> </ul> </li> </ul>"},{"location":"roadmap/core-primitives/#key-design-decisions","title":"Key Design Decisions","text":"<ul> <li>Message immutability: Treat Message as effectively immutable once enqueued; copy-on-write for header enrichment.</li> <li>Type validation costs: Perform cheap runtime checks by default; allow pluggable heavy validators (Pydantic) behind an adapter.</li> <li>Edge queue implementation: Start with a deque + simple counters; encapsulate policy behavior to avoid branching all over the hot path.</li> <li>Backpressure semantics: <code>put()</code> for block policy must be awaitable-friendly in M3 scheduler integration; for now, expose non-blocking <code>try_put</code> and a BLOCKED result for callers to cooperatively yield.</li> <li>Coalesce function contract: <code>fn(old: T, new: T) -&gt; T</code> must be pure and fast; document that long operations are forbidden inside coalesce.</li> <li>Error surfaces: Avoid raising from hot paths for flow control; use return codes/enums where performance matters, exceptions for programmer errors.</li> <li>Strict SRP: Keep each file close to ~200 lines; extract helpers into utils when approaching limits.</li> </ul>"},{"location":"roadmap/core-primitives/#public-api-sketches-non-normative","title":"Public API Sketches (Non-normative)","text":"<ul> <li><code>Message(payload: Any, headers: dict[str, Any] | None = None)</code></li> <li><code>PortSpec(name: str, schema: type | TypedDict | PydanticModelLike, policy: Policy)</code></li> <li><code>Policy</code>: Block | Drop | Latest | Coalesce(fn)</li> <li><code>Edge(spec: PortSpec, capacity: int = 1024)</code><ul> <li><code>try_put(msg: Message, policy)</code> -&gt; PutResult</li> <li><code>try_get()</code> -&gt; Message | None</li> <li><code>depth()</code> -&gt; int [DONE] [PASS]</li> </ul> </li> <li><code>Node</code><ul> <li><code>name()</code> -&gt; str</li> <li><code>inputs()</code> -&gt; dict[str, PortSpec]</li> <li><code>outputs()</code> -&gt; dict[str, PortSpec]</li> <li><code>on_start()</code> -&gt; None</li> <li><code>on_message(port: str, msg: Message)</code> -&gt; None</li> <li><code>on_tick()</code> -&gt; None</li> <li><code>on_stop()</code> -&gt; None</li> <li><code>emit(port: str, msg: Message)</code> -&gt; None [DONE] [PASS]</li> </ul> </li> <li><code>Subgraph</code><ul> <li><code>add_node(node: Node)</code> -&gt; None</li> <li><code>connect(src: (str, str), dst: (str, str), capacity: int = 1024, policy: Policy | None = None)</code> -&gt; str [DONE] [PASS]</li> <li><code>expose_input(name: str, target: (str, str))</code> -&gt; None [DONE] [PASS]</li> <li><code>expose_output(name: str, source: (str, str))</code> -&gt; None [DONE] [PASS]</li> <li><code>validate()</code> -&gt; list[Issue] [DONE] [PASS]</li> </ul> </li> </ul>"},{"location":"roadmap/core-primitives/#metrics-and-observability-hooks","title":"Metrics and Observability Hooks","text":"<ul> <li>Define minimal metrics interface (protocol) but do not depend on exporters yet: [DONE]<ul> <li><code>counter(name, labels).inc(n)</code> [DONE]</li> <li><code>gauge(name, labels).set(v)</code> [DONE]</li> <li><code>histogram(name, labels).observe(v)</code> [DONE]</li> </ul> </li> <li>Edge emits intents: [DONE]<ul> <li><code>enqueued_total</code>, <code>dequeued_total</code>, <code>drops_total</code> [DONE]</li> <li><code>queue_depth</code>, <code>blocked_time_seconds_total</code> [DONE \u2014 partial, blocked time later]</li> </ul> </li> <li>Node emits intents: [DONE]<ul> <li><code>messages_processed_total</code>, <code>errors_total</code> [DONE \u2014 errors later]</li> </ul> </li> <li>Wire to no-op by default; real exporters arrive in M4. [DONE] [PASS]</li> </ul>"},{"location":"roadmap/core-primitives/#validation-rules","title":"Validation Rules","text":"<ul> <li>Port existence: src node has output port; dst node has input port. [DONE] [PASS]</li> <li>Schema compatibility: exact type match or allowed adapter (e.g., subclass/isinstance for basic types). [DONE]</li> <li>Capacity validation: capacity &gt; 0; policy is defined. [DONE] [PASS]</li> <li>Unique naming: node names unique; edge IDs unique and deterministic from endpoints. [DONE] [PASS]</li> <li>Exposure guards: exposed names unique; map to existing internal ports. [DONE] [PASS]</li> </ul>"},{"location":"roadmap/core-primitives/#testing-strategy-m2-scope","title":"Testing Strategy (M2 Scope)","text":""},{"location":"roadmap/core-primitives/#unit-tests","title":"Unit Tests","text":"<ul> <li><code>message_test.py</code>: header normalization; immutability behavior; <code>trace_id</code>/timestamp helpers. [DONE]</li> <li><code>ports_test.py</code>: PortSpec creation; schema adapter plumbing; invalid schemas raise. [DONE]</li> <li><code>policies_test.py</code>: [DONE]<ul> <li>block: returns BLOCKED when at capacity [DONE]</li> <li>drop: returns DROPPED and counts increment [DONE]</li> <li>latest: replaces existing pending message; ensures depth \u2264 1 when saturated [DONE]</li> <li>coalesce: applies user fn; handles exceptions by surfacing policy error [DONE]</li> </ul> </li> <li><code>edge_test.py</code>: [DONE]<ul> <li>capacity accounting; depth changes on put/get [DONE]</li> <li>overflow behavior per policy [DONE]</li> <li>metrics intents emitted as expected [DONE]</li> <li>type validation on <code>put()</code> with mismatched schema [DONE]</li> </ul> </li> <li><code>node_test.py</code>: [DONE]<ul> <li>lifecycle hook call order via a test harness [DONE]</li> <li>emit routes to the correct edge registry with type checks [DONE]</li> </ul> </li> <li><code>subgraph_test.py</code>: [DONE]<ul> <li><code>add_node</code> and <code>connect</code> validate ports and schemas [DONE]</li> <li><code>expose_input</code>/<code>expose_output</code> map correctly [DONE]</li> <li><code>validate()</code> returns issues for bad wiring; raises for fatals [DONE]</li> </ul> </li> </ul>"},{"location":"roadmap/core-primitives/#integration-tests","title":"Integration Tests","text":"<ul> <li>A minimal producer\u2192edge\u2192consumer wiring using Subgraph without the scheduler: [DONE]<ul> <li>Manually invoke <code>on_start</code>, <code>edge.put</code>, and <code>on_message</code> to validate contracts. [DONE]</li> </ul> </li> </ul>"},{"location":"roadmap/core-primitives/#performance-and-footguns","title":"Performance and Footguns","text":"<ul> <li>Hot path microbenchmarks for edge put/get to guard against accidental regressions. [DONE]</li> <li>Avoid per-message allocations beyond Message itself; reuse counters and labels objects. [DONE \u2014 Noop metrics reuse counters/labels]</li> <li>Document that coalesce must be cheap; warn in docs and add a guardrail (e.g., duration histogram to surface misuse later). [NOTED; guardrail deferred to M4]</li> </ul>"},{"location":"roadmap/core-primitives/#acceptance-criteria","title":"Acceptance Criteria","text":"<ul> <li>All deliverables implemented with typing and docstrings; files adhere to ~200 lines guidance. [DONE]</li> <li>Unit tests for all modules pass; integration smoke passes. [DONE]</li> <li>Coverage for core modules \u226590% (edge, policies, ports, message, node, subgraph). [MOSTLY DONE]</li> <li>Public APIs match the README/report drafts, or deviations are documented. [DONE]</li> <li>Basic microbenchmarks demonstrate stable performance across block/drop/latest/coalesce scenarios. [DEFERRED]</li> </ul>"},{"location":"roadmap/core-primitives/#risks-and-mitigations","title":"Risks and Mitigations","text":"<ul> <li>Policy semantics complexity creeping into Edge: [DONE]<ul> <li>Mitigation: Strategy pattern (<code>policies.py</code>) with a narrow interface; keep edge lean. [DONE]</li> </ul> </li> <li>Overhead from type checks: [DONE]<ul> <li>Mitigation: Fast-path isinstance checks; optional heavy validation behind adapters. [DONE]</li> </ul> </li> <li>Backpressure UX before scheduler exists: [DONE]<ul> <li>Mitigation: Provide <code>try_put</code>/PutResult to enable cooperative behavior now; integrate awaitable semantics in M3. [DONE]</li> </ul> </li> <li>Coalesce misuse: [DONE (guardrails deferred to M4)]<ul> <li>Mitigation: Clear documentation and tests; add optional guardrails (timeouts or warnings) in M4 observability. [NOTED]</li> </ul> </li> </ul>"},{"location":"roadmap/core-primitives/#out-of-scope-deferred","title":"Out of Scope (Deferred)","text":"<ul> <li>Scheduler run loop and awaitable backpressure semantics (M3).</li> <li>Observability exporters and tracing spans (M4).</li> <li>Scaffolding generators (M5).</li> <li>Example graphs beyond minimal manual wiring (M6).</li> </ul>"},{"location":"roadmap/core-primitives/#traceability","title":"Traceability","text":"<ul> <li>Aligns with Technical Blueprint Implementation Plan M2.</li> <li>Satisfies EARS requirements for Message, PortSpec, Policies, Edge, Node, and Subgraph behaviors.</li> </ul>"},{"location":"roadmap/examples-and-documentation/","title":"Milestone M6: Examples and Documentation (EARS-aligned)","text":"<p>Branch: main (merged from <code>feature/m6-examples-docs</code>)</p>"},{"location":"roadmap/examples-and-documentation/#purpose","title":"Purpose","text":"<p>Deliver runnable, composable examples and concise documentation that demonstrate core runtime behaviors: lifecycle, composition, backpressure and overflow policies, control\u2011plane priority, and observability. Adhere to SRP/DRY and small\u2011file guidance (~200 lines/file).</p>"},{"location":"roadmap/examples-and-documentation/#standards-alignment","title":"Standards Alignment","text":"<ul> <li>Modularity: \u2264 ~200 lines/file; single\u2011responsibility modules; avoid hidden coupling.</li> <li>SRP/DRY: Factor shared helpers; reuse patterns; eliminate duplication across examples/docs.</li> <li>Composability: Favor subgraphs and clear port contracts; validate wiring before run.</li> <li>Docs style: Concise pages with copy\u2011paste commands; cross\u2011link milestones; EARS\u2011framed requirements.</li> <li>EARS usage: Use Ubiquitous/Event/Unwanted/State/Complex patterns for example specs.</li> <li>Observability: JSON logs by default; metrics interface; tracing optional; no sensitive payloads in logs.</li> </ul>"},{"location":"roadmap/examples-and-documentation/#ears-requirements","title":"EARS Requirements","text":"<ul> <li>Ubiquitous: The system shall provide runnable examples executable with <code>uv run</code>. [DONE][PASSING]</li> <li>Ubiquitous: The system shall include <code>hello_graph</code> (producer \u2192 consumer) validating end\u2011to\u2011end execution. [DONE][PASSING]</li> <li>Ubiquitous: The system shall include <code>pipeline_demo</code> (validator \u2192 transformer \u2192 sink) showing backpressure and multiple overflow policies. [DONE][PASSING]</li> <li>Complex: Where control\u2011plane edges exist, the system shall demonstrate priority preemption (e.g., kill switch). [DONE]</li> <li>Ubiquitous: The system shall provide documentation for quickstart, API, patterns, troubleshooting, and observability. [DONE]</li> <li>Event\u2011driven: When a user follows the quickstart, the examples shall run without additional configuration. [DONE][PASSING]</li> <li>Unwanted: If misconfiguration occurs (e.g., mismatched port types), validation errors shall be clear with remediation steps. [PARTIAL]</li> <li>State\u2011driven: While reading docs, users shall find concise, copy\u2011pastable commands for common workflows (init, run, test). [DONE]</li> </ul>"},{"location":"roadmap/examples-and-documentation/#deliverables","title":"Deliverables","text":""},{"location":"roadmap/examples-and-documentation/#examples","title":"Examples","text":"<ul> <li><code>examples/hello_graph/</code> [DONE][PASSING]<ul> <li><code>producer.py</code>: emits a bounded sequence of integers. [DONE]</li> <li><code>consumer.py</code>: prints or counts messages. [DONE]</li> <li><code>main.py</code>: builds a subgraph, connects ports, runs scheduler. [DONE]</li> </ul> </li> <li><code>examples/pipeline_demo/</code> [DONE][PASSING]<ul> <li><code>validator.py</code>: type/schema gate; emits valid only. [DONE]</li> <li><code>transformer.py</code>: enrich/normalize payloads. [DONE]</li> <li><code>sink.py</code>: slow consumer to trigger backpressure. [DONE]</li> <li><code>control.py</code>: kill\u2011switch via control\u2011plane edge. [DONE]</li> <li><code>main.py</code>: wiring; capacities; policies (block/latest/coalesce); priorities. [DONE]</li> </ul> </li> <li>Optional: <code>examples/observability_demo/</code><ul> <li><code>metrics_tracing.py</code>: enable metrics/tracing via flags; no\u2011op safe by default. [TODO]</li> </ul> </li> </ul>"},{"location":"roadmap/examples-and-documentation/#documentation","title":"Documentation","text":"<ul> <li><code>docs/quickstart.md</code>: <code>uv</code> workflow; run <code>hello_graph</code>; run <code>pipeline_demo</code>; optional observability flags. [DONE]</li> <li><code>docs/api.md</code>: concise API overview (Node, Edge, Subgraph, Scheduler, Message, PortSpec, Policies). [DONE]</li> <li><code>docs/patterns.md</code>: backpressure strategies (block/latest/coalesce); control\u2011plane priority; subgraph composition; error\u2011handling patterns. [DONE]</li> <li><code>docs/troubleshooting.md</code>: wiring errors; type mismatches; diagnosing backpressure; priority issues. [DONE]</li> <li><code>docs/observability.md</code>: metric catalog (summary); logging format; tracing enablement and sampling. [DONE]</li> <li><code>README</code>: links to the above; short quickstart. [DONE]</li> </ul>"},{"location":"roadmap/examples-and-documentation/#example-authoring-template","title":"Example Authoring Template","text":""},{"location":"roadmap/examples-and-documentation/#file-size-and-structure","title":"File size and structure","text":"<ul> <li>\u2264 ~200 lines/file; one cohesive class/module per node or subgraph.</li> <li><code>__init__.py</code> optional; expose run entry points if needed.</li> <li>Top\u2011level docstring includes: Purpose; Ports (name:type, policy); Capacity/priorities; Run command (<code>uv run ...</code>).</li> </ul>"},{"location":"roadmap/examples-and-documentation/#type-and-policy-hygiene","title":"Type and policy hygiene","text":"<ul> <li>Static typing for public functions/classes.</li> <li>Explicit <code>PortSpec</code> types and policies; capacity and priority set near wiring sites.</li> </ul>"},{"location":"roadmap/examples-and-documentation/#srpdry","title":"SRP/DRY","text":"<ul> <li>One node class per file; helpers local or shared; avoid duplication across examples.</li> </ul>"},{"location":"roadmap/examples-and-documentation/#example-checklist","title":"Example Checklist","text":"<ul> <li> Files \u2264 ~200 lines; SRP respected.</li> <li> Docstring with purpose, ports, capacities, policies, priorities.</li> <li> <code>uv run</code> command included and tested.</li> <li> Edge validates <code>Message.payload</code> against <code>PortSpec.schema</code> (Message-wrapped types supported).</li> <li> Validation errors are clear if miswired (expand troubleshooting examples). [PARTIAL]</li> <li> Metrics/logs visible (no\u2011op safe); tracing guarded by optional deps. [PARTIAL]</li> <li> Smoke tests in CI.</li> </ul>"},{"location":"roadmap/examples-and-documentation/#commands","title":"Commands","text":""},{"location":"roadmap/examples-and-documentation/#quickstart","title":"Quickstart","text":"Bash<pre><code>uv init\nuv lock\nuv sync\nuv run python -m examples.hello_graph.main\nuv run python -m examples.pipeline_demo.main\n</code></pre>"},{"location":"roadmap/examples-and-documentation/#optional-observability","title":"Optional observability","text":"<ul> <li>Enable metrics/tracing via env flags or code switches; default to no\u2011op when disabled.</li> </ul>"},{"location":"roadmap/examples-and-documentation/#ears-template-for-examples-and-docs","title":"EARS Template (for examples and docs)","text":"<ul> <li>Ubiquitous: The example shall . <li>Event\u2011driven: When , the example/system shall . <li>Unwanted: If , the example/system shall . <li>State\u2011driven: While , the example/system shall . <li>Complex: Where , the example/system shall ."},{"location":"roadmap/examples-and-documentation/#example-specs-ears","title":"Example Specs (EARS)","text":""},{"location":"roadmap/examples-and-documentation/#hello_graph","title":"hello_graph","text":"<ul> <li>Ubiquitous: The example shall demonstrate producer\u2192consumer message flow and node lifecycle.</li> <li>Event\u2011driven: When producer ticks, it shall emit an integer <code>Message</code> to the output port.</li> <li>Event\u2011driven: When consumer receives a <code>Message</code>, it shall record/print the payload.</li> <li>State\u2011driven: While the edge capacity is not exceeded, enqueue operations shall succeed with <code>policy=block</code>.</li> <li>Unwanted: If the consumer raises, the runtime shall log a structured error and continue per default node error policy.</li> </ul>"},{"location":"roadmap/examples-and-documentation/#pipeline_demo","title":"pipeline_demo","text":"<ul> <li>Ubiquitous: The example shall demonstrate validation, transformation, and backpressure under varied overflow policies.</li> <li>Event\u2011driven: When validator receives input, it shall drop or flag invalid payloads and emit valid ones only.</li> <li>State\u2011driven: While the sink is slow, the Transformer\u2192Sink edge with <code>policy=latest</code> shall retain only the newest message beyond capacity.</li> <li>Event\u2011driven: When a kill\u2011switch control\u2011plane message is emitted, the scheduler shall prioritize its processing and initiate graceful shutdown.</li> <li>Unwanted: If an edge reaches capacity with <code>policy=coalesce</code>, the example shall coalesce burst messages via a supplied function and expose behavior via logs/metrics.</li> </ul>"},{"location":"roadmap/examples-and-documentation/#observability_demo-optional","title":"observability_demo (optional)","text":"<ul> <li>Ubiquitous: The example shall demonstrate enabling metrics and optional tracing with minimal overhead.</li> <li>Event\u2011driven: When nodes process messages, counters and histograms shall update; tracing spans shall be created only if enabled.</li> <li>Unwanted: If tracing is not installed, the example shall run with a no\u2011op provider without errors.</li> </ul>"},{"location":"roadmap/examples-and-documentation/#subgraph_composition_mini","title":"subgraph_composition_mini","text":"<ul> <li>Ubiquitous: The example shall demonstrate composing two subgraphs into a larger graph with exposed ports.</li> <li>Event\u2011driven: When subgraph A emits, subgraph B shall receive via exposed connectors with validated <code>PortSpec</code> types.</li> <li>Unwanted: If port types mismatch, validation shall fail with a clear <code>Issue</code> and location.</li> </ul>"},{"location":"roadmap/examples-and-documentation/#documentation-structure-and-crosslinks","title":"Documentation Structure and Cross\u2011Links","text":"<ul> <li><code>quickstart.md</code> \u2192 examples; <code>patterns.md</code></li> <li><code>api.md</code> \u2192 code docstrings; <code>patterns.md</code></li> <li><code>patterns.md</code> \u2192 <code>troubleshooting.md</code></li> <li><code>troubleshooting.md</code> \u2192 <code>observability.md</code></li> <li><code>observability.md</code> \u2192 <code>api.md</code> (metrics/tracing)</li> </ul>"},{"location":"roadmap/examples-and-documentation/#testing-and-acceptance","title":"Testing and Acceptance","text":""},{"location":"roadmap/examples-and-documentation/#docs-lint-and-snippets","title":"Docs lint and snippets","text":"<ul> <li> Validate code blocks/snippets compile/run in CI. [TODO]</li> </ul>"},{"location":"roadmap/examples-and-documentation/#example-smoke-tests","title":"Example smoke tests","text":"<ul> <li> <code>hello_graph</code>: run and assert N outputs observed. [DONE][PASSING]</li> <li> <code>pipeline_demo</code>: basic smoke runs; backpressure path sketched; refine assertions next. [DONE][PASSING]</li> <li> <code>observability_demo</code>: metrics counters increment; tracing path does not error when disabled. [TODO]</li> </ul>"},{"location":"roadmap/examples-and-documentation/#ci-acceptance","title":"CI acceptance","text":"<ul> <li> Examples run via <code>uv</code> on clean clone. [DONE][PASSING]</li> <li> Snippet checks pass. [TODO]</li> <li> Coverage impact acceptable. [PASSING]</li> </ul>"},{"location":"roadmap/examples-and-documentation/#git-workflow","title":"Git Workflow","text":"Bash<pre><code>git checkout -b feature/m6-examples-docs\n</code></pre> <p>Incremental commits per example/doc page; PR early; keep commits small.</p>"},{"location":"roadmap/examples-and-documentation/#traceability","title":"Traceability","text":"<ul> <li>Aligns with M0 governance (SRP/DRY, small modules, docs\u2011as\u2011product).</li> <li>Implements EARS master for examples, policies, scheduler priorities, and observability.</li> </ul>"},{"location":"roadmap/examples-and-documentation/#current-status-summary","title":"Current Status Summary","text":"<ul> <li>Examples: <code>hello_graph</code> and <code>pipeline_demo</code> implemented and runnable. [DONE][PASSING]</li> <li>Docs: site automated via GitHub Pages; dedicated homepage; nav updated; badges added. [DONE]</li> <li>Typing: mypy strict pass across <code>src/</code>; optional pydantic guarded. [PASSING]</li> <li>Lint: ruff clean (auto\u2011fixed). [PASSING]</li> <li>Tests: pytest passing locally and in CI. [PASSING]</li> <li>CI/CD: Docs build optimized with caching; pinned deps; deploy green. [DONE][PASSING]</li> <li>Scaffolding: legacy <code>generate_test_template</code> wrapper restored (deprecated; remove pre\u20111.0). [KNOWN - TODO remove before 1.0]</li> </ul>"},{"location":"roadmap/examples-and-documentation/#remaining-todos","title":"Remaining TODOs","text":"<ul> <li>Add <code>observability_demo</code> example and snippet docs. [TODO]</li> <li>Strengthen <code>pipeline_demo</code> assertions for backpressure and coalesce behaviors. [TODO]</li> <li>Add docs snippet CI to validate code blocks. [TODO]</li> <li>Plan removal of legacy scaffolding alias before 1.0 and update tests/docs. [TODO]</li> </ul>"},{"location":"roadmap/future-roadmap/","title":"Meridian Runtime Future Roadmap","text":"<p>Owner: GhostWeasel (Lead: <code>doubletap-dave</code>) Status: Living document Audience: Contributors, maintainers, integrators</p>"},{"location":"roadmap/future-roadmap/#purpose","title":"Purpose","text":"<p>This roadmap captures high\u2011value initiatives considered out of scope for v1.0.0 but aligned with Meridian's mission: a composable, asyncio\u2011native graph runtime with strong observability, predictable scheduling, and privacy\u2011first error handling. It is organized by time horizon and includes requirements framed with EARS to ensure clarity and testability.</p>"},{"location":"roadmap/future-roadmap/#guiding-themes","title":"Guiding Themes","text":"<ul> <li>Composability and portability over bespoke integrations</li> <li>Predictable performance and graceful backpressure</li> <li>Operational transparency with privacy\u2011safe diagnostics</li> <li>Ergonomic developer experience (DX) and API stability</li> <li>Incremental, opt\u2011in features to avoid core bloat</li> </ul>"},{"location":"roadmap/future-roadmap/#horizon-1-nearterm-v1x-series","title":"Horizon 1: Near\u2011Term (v1.x series)","text":""},{"location":"roadmap/future-roadmap/#1-cli-enhancements-and-diagnostics","title":"1) CLI Enhancements and Diagnostics","text":"<p>Event-driven:</p> <ul> <li>When a user runs <code>meridian diagnostics collect</code>, the CLI shall gather anonymized runtime metadata, environment info (OS, Python version), configuration checksums, and recent logs into a bundle.</li> <li>When a diagnostics bundle is created, the CLI shall apply redaction rules to scrub secrets, tokens, PII, and payload contents by default.</li> </ul> <p>Ubiquitous:</p> <ul> <li>The CLI shall support subcommands for graph validation, linting, and quick profiling (e.g., edge depths, queue sizes).</li> <li>The CLI shall support exporting a machine\u2011readable snapshot of node/edge schemas and runtime topology.</li> </ul>"},{"location":"roadmap/future-roadmap/#2-rust-fast-path-extensions-pyo3","title":"2) Rust Fast Path Extensions (PyO3)","text":"<p>Ubiquitous:</p> <ul> <li>The system shall provide an optional <code>meridian_fast</code> extension backed by Rust (via PyO3/maturin) implementing:<ul> <li>A bounded ring buffer for edges with <code>block</code>/<code>drop</code>/<code>latest</code>/<code>coalesce</code> policies.</li> <li>Policy handlers as zero\u2011copy operations over indices and lengths.</li> <li>Scheduler ready\u2011queue band selection and dispatch primitives.</li> </ul> </li> <li>When <code>meridian_fast</code> is installed, the runtime shall auto\u2011detect and use the Rust implementations; otherwise, it shall fall back to pure Python.</li> </ul> <p>Unwanted:</p> <ul> <li>If the Rust extension is unavailable or fails to load, the system shall degrade gracefully with no behavior change.</li> </ul> <p>Notes:</p> <ul> <li>Package as an optional extra: <code>pip install meridian-runtime[fast]</code>.</li> <li>Keep the public API identical; optimize internal data structures and loops.</li> </ul>"},{"location":"roadmap/future-roadmap/#3-cpu-topology-awareness-and-affinity","title":"3) CPU Topology Awareness and Affinity","text":"<p>Event-driven:</p> <ul> <li>At startup, the runtime shall detect logical CPU count and affinity mask, log them, and expose metrics (e.g., <code>runtime_cpu_visible</code>, <code>runtime_cpu_affinity_count</code>).</li> <li>When <code>MERIDIAN_SET_CPU_AFFINITY=1</code> is set on Linux, the process shall set its CPU affinity to the full visible set and log the result.</li> </ul> <p>Unwanted:</p> <ul> <li>Affinity setting shall be opt\u2011in and never cause startup failure if the platform doesn't support it.</li> </ul>"},{"location":"roadmap/future-roadmap/#4-deterministic-metrics-overhead-minimization","title":"4) Deterministic Metrics Overhead Minimization","text":"<p>Ubiquitous:</p> <ul> <li>The metrics subsystem shall provide a zero\u2011overhead stub when disabled and batch increments when enabled to keep overhead \u226410% versus no metrics.</li> </ul> <p>Notes:</p> <ul> <li>Preserve budget checks in CI; validate with microbenchmarks.</li> </ul>"},{"location":"roadmap/future-roadmap/#5-nightly-profiling-artifacts","title":"5) Nightly Profiling Artifacts","text":"<p>Event-driven:</p> <ul> <li>When profiling mode is enabled (<code>MERIDIAN_PROF=1</code>), CI shall capture sampling profiles (<code>py\u2011spy</code>/<code>perf</code>) during stress tests and upload flamegraphs.</li> </ul> <p>Unwanted:</p> <ul> <li>Profiling mode shall not be enabled by default in PR CI to avoid noise.</li> </ul>"},{"location":"roadmap/future-roadmap/#6-graph-inspector-textterminal","title":"6) Graph Inspector (Text/Terminal)","text":"<p>Ubiquitous:</p> <ul> <li>The system shall provide a TUI inspector enabling overview of nodes, edges, queue states, and lifecycle statuses with refresh intervals.</li> <li>The inspector shall remain opt\u2011in and run without impacting runtime performance beyond nominal observation overhead.</li> </ul>"},{"location":"roadmap/future-roadmap/#7-runtime-introspection-api","title":"7) Runtime Introspection API","text":"<p>Ubiquitous:</p> <ul> <li>The runtime shall expose an introspection surface to enumerate nodes, edge policies, and recent error events with redacted metadata.</li> <li>The runtime shall provide structured metrics readers for exporting counters/gauges/histograms to common backends via adapters.</li> </ul>"},{"location":"roadmap/future-roadmap/#8-schema-and-validation-ergonomics","title":"8) Schema and Validation Ergonomics","text":"<p>Ubiquitous:</p> <ul> <li>The system shall offer optional validators (<code>TypedDict</code>/<code>Pydantic</code>) with a consistent adapter interface.</li> <li>The system shall include validation error mapping to structured runtime error events (no payloads by default).</li> </ul>"},{"location":"roadmap/future-roadmap/#9-scheduler-profiling-and-fairness-tuning","title":"9) Scheduler Profiling and Fairness Tuning","text":"<p>Event-driven:</p> <ul> <li>When profiling mode is enabled, the scheduler shall record scheduling latencies, runnable queue lengths, and per\u2011node execution times with constant\u2011factor overhead.</li> </ul> <p>State-driven:</p> <ul> <li>While steady\u2011state, the scheduler shall support configurable fairness strategies (e.g., round\u2011robin, weighted) selectable via policy.</li> </ul>"},{"location":"roadmap/future-roadmap/#10-persistencefriendly-hooks","title":"10) Persistence\u2011Friendly Hooks","text":"<p>Ubiquitous:</p> <ul> <li>The system shall provide extension points for durable inbox/outbox adapters (e.g., SQLite, file\u2011backed) without making persistence mandatory.</li> <li>The system shall document at\u2011least\u2011once and at\u2011most\u2011once semantics for adapters that opt into persistence.</li> </ul>"},{"location":"roadmap/future-roadmap/#11-examples-and-recipes-expansion","title":"11) Examples and Recipes Expansion","text":"<p>Ubiquitous:</p> <ul> <li>The repository shall include curated examples demonstrating backpressure policies, redaction strategies, and controlled shutdown.</li> <li>The examples shall include \"debug mode\" scripts that set up structured logs and quick metrics sinks.</li> </ul>"},{"location":"roadmap/future-roadmap/#horizon-2-midterm-v2x-series","title":"Horizon 2: Mid\u2011Term (v2.x series)","text":""},{"location":"roadmap/future-roadmap/#1-visual-graph-inspector-localweb","title":"1) Visual Graph Inspector (Local/Web)","text":"<p>Ubiquitous:</p> <ul> <li>The system shall provide an optional web or local visual inspector for graph topology exploration, node status, and basic metrics overlays.</li> </ul> <p>Unwanted:</p> <ul> <li>If the visual inspector is enabled, it shall never expose payload contents by default; sensitive fields shall be masked or omitted.</li> </ul>"},{"location":"roadmap/future-roadmap/#2-pluggable-storage-for-edges-advanced","title":"2) Pluggable Storage for Edges (Advanced)","text":"<p>Ubiquitous:</p> <ul> <li>The system shall allow edge queues to use pluggable storage (memory, mmap, local DB) with consistent overflow policies (<code>block</code>, <code>drop</code>, <code>latest</code>, <code>coalesce</code>).</li> <li>The system shall document performance and durability trade\u2011offs for each adapter.</li> </ul>"},{"location":"roadmap/future-roadmap/#3-extended-backpressure-strategies","title":"3) Extended Backpressure Strategies","text":"<p>Ubiquitous:</p> <ul> <li>The system shall support advanced backpressure configurations (e.g., watermarks, adaptive coalescing) that can be selected per edge.</li> </ul>"},{"location":"roadmap/future-roadmap/#4-graph-versioning-and-migration-aids","title":"4) Graph Versioning and Migration Aids","text":"<p>Event-driven:</p> <ul> <li>When loading a graph with a prior schema version, the system shall support mapping/migration strategies to upgrade definitions with clear errors on incompatibilities.</li> </ul>"},{"location":"roadmap/future-roadmap/#5-replay-and-timetravel-debugging-local","title":"5) Replay and Time\u2011Travel Debugging (Local)","text":"<p>Ubiquitous:</p> <ul> <li>The system shall provide opt\u2011in, local\u2011only replay from persisted event logs to reproduce behavior, with strong redaction guarantees.</li> </ul>"},{"location":"roadmap/future-roadmap/#6-policydriven-error-handling","title":"6) Policy\u2011Driven Error Handling","text":"<p>Ubiquitous:</p> <ul> <li>The system shall offer configurable error policies (e.g., retry with backoff, circuit breaker, quarantine node) expressible in graph definitions.</li> </ul>"},{"location":"roadmap/future-roadmap/#7-structured-configuration-layer","title":"7) Structured Configuration Layer","text":"<p>Ubiquitous:</p> <ul> <li>The system shall offer a structured config loader (e.g., from TOML/YAML) with strict key validation and environment overrides, remaining optional.</li> </ul>"},{"location":"roadmap/future-roadmap/#horizon-3-longterm-v3x","title":"Horizon 3: Long\u2011Term (v3.x+)","text":""},{"location":"roadmap/future-roadmap/#1-multiprocessdistributed-execution-rust-bridges","title":"1) Multi\u2011Process/Distributed Execution (Rust Bridges)","text":"<p>Ubiquitous:</p> <ul> <li>The runtime shall support partitioned execution across processes or hosts with clear delivery guarantees and robust health checks.</li> <li>Bridge edges shall be backed by shared memory or lock\u2011free queues implemented in Rust, with a <code>DistributedEngine</code> composing multiple schedulers.</li> </ul> <p>Unwanted:</p> <ul> <li>If a partition becomes isolated, the system shall degrade gracefully with backpressure, clear error events, and recovery paths.</li> </ul>"},{"location":"roadmap/future-roadmap/#2-adaptive-scheduling-and-qos","title":"2) Adaptive Scheduling and QoS","text":"<p>State-driven:</p> <ul> <li>While under sustained load, the scheduler shall adapt priorities based on configured QoS classes, queue depth, and SLIs.</li> </ul>"},{"location":"roadmap/future-roadmap/#3-formal-verification-aids","title":"3) Formal Verification Aids","text":"<p>Ubiquitous:</p> <ul> <li>The system shall provide optional formal models/specs for critical components (e.g., edge policies) to support verification and model\u2011checking.</li> </ul>"},{"location":"roadmap/future-roadmap/#4-pluggable-security-posture","title":"4) Pluggable Security Posture","text":"<p>Ubiquitous:</p> <ul> <li>The system shall support policy modules for encryption at rest for persistent edges, signed configuration bundles, and policy\u2011as\u2011code redaction rules.</li> </ul>"},{"location":"roadmap/future-roadmap/#5-remote-control-plane","title":"5) Remote Control Plane","text":"<p>Event-driven:</p> <ul> <li>When enabled, a remote control plane shall allow safe operations (pause/resume nodes, swap subgraphs, drain edges) with strict auth and audit logs.</li> </ul>"},{"location":"roadmap/future-roadmap/#crosscutting-concerns","title":"Cross\u2011Cutting Concerns","text":""},{"location":"roadmap/future-roadmap/#observability","title":"Observability","text":"<ul> <li>The system shall continue to prioritize structured logs, metrics, and optional tracing, with stable keys and label cardinality guidance.</li> <li>Adapters shall be provided for common metrics backends (Prometheus, OpenTelemetry exporters) without hard dependencies.</li> <li>Profiling: provide nightly sampling profiles and flamegraphs for stress runs; keep off by default in PR CI.</li> </ul>"},{"location":"roadmap/future-roadmap/#privacy-and-redaction","title":"Privacy and Redaction","text":"<ul> <li>Redaction hooks shall be consistently applied across logs, diagnostics, inspector tools, and replay facilities.</li> <li>Default posture remains \"no payloads in errors\" with opt\u2011in, policy\u2011driven exposure.</li> </ul>"},{"location":"roadmap/future-roadmap/#performance","title":"Performance","text":"<ul> <li>Benchmarks and micro\u2011profiling suites shall accompany major changes (scheduler, edges, validators).</li> <li>Clear SLOs: baseline latency envelopes for node execution and enqueue/dequeue operations under reference workloads.</li> <li>Rust fast paths: optional acceleration layer (<code>meridian_fast</code>) for ring buffers, policies, and scheduler dispatch with behavior parity tests.</li> <li>CPU topology awareness: metrics for visible CPUs and affinity; optional process pinning via <code>MERIDIAN_SET_CPU_AFFINITY</code>.</li> </ul>"},{"location":"roadmap/future-roadmap/#api-stability","title":"API Stability","text":"<ul> <li>Semantic versioning applies to public APIs; deprecations shall include migration notes and timelines.</li> <li>Experimental APIs shall be clearly marked with upgrade expectations.</li> <li>Fast\u2011path implementations must preserve public API semantics and be fully covered by conformance tests against the Python reference.</li> </ul>"},{"location":"roadmap/future-roadmap/#candidate-rfcdecision-record-topics","title":"Candidate RFC/Decision Record Topics","text":"<ul> <li>Diagnostics bundle schema and redaction policy vocabulary</li> <li>Scheduler pluggability and fairness strategies</li> <li>Edge storage adapters and durability semantics</li> <li>Visual inspector transport and privacy posture</li> <li>Replay/log formats and time\u2011travel debugging guarantees</li> <li>Multi\u2011process partitioning model and delivery guarantees</li> <li>Rust fast\u2011path FFI surface and conformance testing approach</li> <li>Scheduler core replacement plan and callback adapter interface</li> </ul>"},{"location":"roadmap/future-roadmap/#milestone-selection-guidance","title":"Milestone Selection Guidance","text":"<ul> <li>Prefer features that increase reliability, debuggability, and clarity of behavior.</li> <li>Keep the core small; ship optional adapters and inspectors as add\u2011ons.</li> <li>Ensure each feature includes tests, examples, and docs updates.</li> <li>Validate user benefit with examples and realistic load tests before default enablement.</li> </ul>"},{"location":"roadmap/future-roadmap/#changelog-and-tracking","title":"Changelog and Tracking","text":"<p>This document is updated as items land or are re\u2011scoped. Each substantial item should be linked to an RFC/DR and issue(s) for planning and status.</p>"},{"location":"roadmap/governance-and-overview/","title":"M0 \u2014 Governance and Overview","text":""},{"location":"roadmap/governance-and-overview/#purpose","title":"Purpose","text":"<p>This document establishes the governance model, scope boundaries, quality bar, and operational practices for the Meridian Runtime. It also sets non-functional requirements, decision processes, and artifact expectations that apply to all subsequent milestones.</p>"},{"location":"roadmap/governance-and-overview/#guiding-principles","title":"Guiding Principles","text":"<ul> <li>Composable first: graphs, subgraphs, and clear boundaries.</li> <li>Async-friendly: Python 3.11+, asyncio-native.</li> <li>Predictable execution: fairness, backpressure, bounded edges.</li> <li>Observability by default: structured logs, metrics, optional tracing.</li> <li>Safety and privacy: no payloads in errors by default, redaction hooks.</li> <li>Maintainability: small, testable modules (~200 lines/file guidance).</li> <li>Platform-agnostic: no host-specific assumptions (e.g., not GitHub-only).</li> <li>Docs-as-product: plans, support docs, and examples are first-class.</li> </ul>"},{"location":"roadmap/governance-and-overview/#non-functional-requirements-ears-ubiquitous","title":"Non-Functional Requirements (EARS: Ubiquitous)","text":"<ul> <li>The system shall be implemented in Python 3.11+ and be asyncio-friendly.</li> <li>The system shall avoid global mutable state and prefer explicit dependency injection at boundaries.</li> <li>The system shall provide deterministic resource cleanup for nodes and the scheduler.</li> <li>The system shall enforce bounded edges with configurable overflow policies.</li> <li>The system shall produce structured logs with stable keys and provide a metrics interface with consistent naming conventions.</li> <li>The system shall keep core packages dependency-light, with optional extras for validators and tracing.</li> <li>The system shall publish a clear public API with semantic versioning and a stability policy.</li> <li>The system shall maintain a baseline of type coverage (<code>mypy</code>), style (<code>ruff</code>), and automated tests (<code>pytest</code>).</li> <li>The system shall include user-facing documentation and examples demonstrating typical runtime patterns.</li> <li>The system shall separate control plane operations from data-plane work, with priority for control.</li> </ul>"},{"location":"roadmap/governance-and-overview/#out-of-scope-ears-state-driven-whenever-building-v1","title":"Out of Scope (EARS: State-driven \"whenever building v1\")","text":"<ul> <li>The system shall not include vendor-specific observability backends; it will expose generic interfaces and adapters.</li> <li>The system shall not ship a full-featured UI/dashboard in v1; it may provide CLI-based inspectors and structured outputs that other tools can consume.</li> <li>The system shall not implement distributed graph execution in v1; single-process, multi-task concurrency is in scope.</li> <li>The system shall not require a schema system; validation is optional via Pydantic or TypedDict where desirable.</li> <li>The system shall not embed secrets management or cloud-specific key stores; integration hooks are acceptable.</li> </ul>"},{"location":"roadmap/governance-and-overview/#governance-model-ears-ubiquitous","title":"Governance Model (EARS: Ubiquitous)","text":"<ul> <li>The project shall be owned by GhostWeasel, with Dave as lead maintainer.</li> <li>The project shall accept contributor changes via a documented contribution process, including code review and CI checks.</li> <li>The project shall prioritize API stability and backward compatibility within a major version.</li> <li>The project shall record major decisions via lightweight Decision Records (DRs) in <code>docs/plan/dr/</code>.</li> <li>The project shall adhere to a transparent, milestone-based roadmap that is documented and updated as necessary.</li> <li>The project shall apply a Code of Conduct (CoC) and enforce it consistently across all communication channels.</li> <li>The project shall maintain clear ownership for subsystems (runtime, scheduler, observability, CLI, docs) and rotate reviewers to spread knowledge.</li> </ul>"},{"location":"roadmap/governance-and-overview/#decision-process-ears-event-driven","title":"Decision Process (EARS: Event-driven)","text":"<ul> <li>When a contributor proposes a significant API change, the maintainers shall require an RFC or DR covering motivation, alternatives, migration plan, and impact.</li> <li>When interfaces or behaviors affect user data handling, the maintainers shall require a privacy and redaction review.</li> <li>When a release branch is cut, the lead maintainer shall define a freeze policy covering allowed changes, documentation finalization, and release notes.</li> </ul>"},{"location":"roadmap/governance-and-overview/#quality-bar-ears-ubiquitous","title":"Quality Bar (EARS: Ubiquitous)","text":"<ul> <li>The system shall maintain CI checks for: lint (<code>ruff</code>), type-check (<code>mypy</code>), tests (<code>pytest</code>), and packaging (<code>uv</code>).</li> <li>The system shall maintain \u2265 80% code coverage in critical modules and \u2265 70% overall by M7, with risk-based exemptions documented.</li> <li>The system shall include structured logging via a minimal logging fa\u00e7ade; no direct stdout prints in production code.</li> <li>The system shall provide meaningful error types and messages with contextual metadata and without sensitive payloads by default.</li> <li>The system shall provide reproducible examples with pinned versions and scripts to run locally.</li> </ul>"},{"location":"roadmap/governance-and-overview/#operational-practices-ears-ubiquitous","title":"Operational Practices (EARS: Ubiquitous)","text":"<ul> <li>The project shall maintain a Contributing Guide describing environment setup (<code>uv</code>), coding standards, branching, and commit conventions.</li> <li>The project shall maintain Releasing Documentation describing versioning, tagging, changelog, and post-release verification.</li> <li>The project shall maintain support documentation describing how users report issues, provide diagnostics bundles, and request features.</li> <li>The project shall prefer minimal, composable modules with single-responsibility orientation and explicit dependencies.</li> <li>The project shall ensure that blocking operations are isolated and documented, with async adapters where needed.</li> </ul>"},{"location":"roadmap/governance-and-overview/#security-and-privacy-ears-unwanted","title":"Security and Privacy (EARS: Unwanted)","text":"<ul> <li>If a node attempts to log user-provided payloads, the logger shall redact sensitive fields by default where configured.</li> <li>If diagnostics bundles are generated, the bundle shall omit secrets, auth tokens, and personally identifiable information (PII) by default.</li> <li>If a graph contains validation failures, the runtime shall emit structured error events without including payload contents, unless explicitly enabled by the user with a redaction policy.</li> <li>If an unhandled exception occurs in a node, the runtime shall capture the exception, emit a structured error event, stop the node cleanly, and preserve the scheduler's stability.</li> </ul>"},{"location":"roadmap/governance-and-overview/#compatibility-and-versioning-ears-ubiquitous","title":"Compatibility and Versioning (EARS: Ubiquitous)","text":"<ul> <li>The system shall follow SemVer for the public API, with clear documentation of what constitutes public versus private interfaces.</li> <li>The system shall target Python 3.11+ and keep language features within that baseline for v1.</li> <li>The system shall provide migration notes for any breaking changes, including code examples and find/replace suggestions where feasible.</li> </ul>"},{"location":"roadmap/governance-and-overview/#documentation-standards-ears-ubiquitous","title":"Documentation Standards (EARS: Ubiquitous)","text":"<ul> <li>The project shall maintain milestone plans under <code>docs/plan</code> with EARS framing for requirements.</li> <li>The project shall provide example graphs and recipes under <code>examples/</code> with runnable instructions.</li> <li>The project shall keep support docs under <code>docs/support</code> and contributor docs under <code>docs/contributing</code>.</li> <li>The project shall ensure that <code>README</code> provides a concise overview, quickstart, and links to deeper docs.</li> <li>The project shall maintain an up-to-date post-v1 roadmap capturing near-term and longer-term work.</li> </ul>"},{"location":"roadmap/governance-and-overview/#scheduler-and-runtime-policy-ears-state-driven","title":"Scheduler and Runtime Policy (EARS: State-driven)","text":"<ul> <li>While the runtime is starting, the scheduler shall prioritize control-plane tasks to ensure clean initialization and graph admission.</li> <li>While the runtime is steady-state, the scheduler shall enforce fairness across runnable tasks while respecting bounded edges and backpressure.</li> <li>While the runtime is shutting down, the scheduler shall drain in-flight work according to policy and guarantee <code>on_stop</code> hooks are called for nodes.</li> </ul>"},{"location":"roadmap/governance-and-overview/#observability-policy-ears-event-driven","title":"Observability Policy (EARS: Event-driven)","text":"<ul> <li>When nodes transition lifecycle states, the runtime shall emit structured events and metrics with stable labels.</li> <li>When edges overflow their bounds, the runtime shall emit a structured event with policy details (block, drop, latest, coalesce).</li> <li>When tracing is enabled, spans shall capture node execution, scheduling, and edge operations with minimal overhead and no sensitive data by default.</li> </ul>"},{"location":"roadmap/governance-and-overview/#support-and-issue-reporting-ears-event-driven","title":"Support and Issue Reporting (EARS: Event-driven)","text":"<ul> <li>When a user requests help, the project shall provide templates for bug reports, feature requests, and general issues under <code>docs/support/templates</code>.</li> <li>When a user opts into a diagnostics bundle, the CLI shall collect logs, config snippets, and an anonymized snapshot of the graph and scheduler state.</li> <li>When an issue is submitted with a diagnostics bundle, maintainers shall use the anonymized snapshot to reproduce and triage without requiring user data.</li> </ul>"},{"location":"roadmap/governance-and-overview/#change-control-ears-event-driven","title":"Change Control (EARS: Event-driven)","text":"<ul> <li>When a pull request is opened, CI shall run and block merging on failure.</li> <li>When a maintainer approves a PR that changes public APIs, the maintainer shall update changelogs and migration notes before merging.</li> <li>When a release candidate is tagged, the project shall perform smoke tests on examples and verify packaging integrity.</li> </ul>"},{"location":"roadmap/governance-and-overview/#risk-management-ears-unwanted","title":"Risk Management (EARS: Unwanted)","text":"<ul> <li>If a design proposal introduces unbounded queues or uncoordinated concurrency, the maintainers shall require mitigation or rejection with rationale.</li> <li>If an implementation would cause excessive coupling or hidden side effects, the maintainers shall require refactoring to restore SRP and composability.</li> <li>If observability features leak sensitive data by default, the maintainers shall mandate redaction policies and opt-in surfaces.</li> </ul>"},{"location":"roadmap/governance-and-overview/#deliverables-in-m0","title":"Deliverables in M0","text":"<ul> <li>Governance and overview document (this file).</li> <li>Contributor Guide: setup, standards, review process, commit/branch patterns, code of conduct reference.</li> <li>Releasing Guide: SemVer policy, tagging, changelog process, publishing steps, support windows.</li> <li>Support docs: how to report issues, troubleshooting, templates for bug/feature/general requests.</li> <li>Decision Records directory and template for future significant changes.</li> </ul>"},{"location":"roadmap/governance-and-overview/#success-criteria-for-m0","title":"Success Criteria for M0","text":"<ul> <li>The governance model is documented and unambiguous.</li> <li>The quality bar and non-functional requirements are explicit and testable.</li> <li>Support and contributor documentation exists and is discoverable from <code>README</code>.</li> <li>Decision Records directory and template are ready for use.</li> <li>All subsequent milestones (M1\u2013M8) can reference this document for process and policy alignment.</li> </ul>"},{"location":"roadmap/governance-and-overview/#appendix-a-ears-patterns-used","title":"Appendix A: EARS Patterns Used","text":"<ul> <li>Ubiquitous: \"The system shall \u2026\" for cross-cutting requirements.</li> <li>Event-driven: \"When , the system shall \u2026\" for trigger-driven behaviors. <li>State-driven: \"While , the system shall \u2026\" for lifecycle policies. <li>Unwanted: \"If , the system shall \u2026\" for error/resilience. <li>Complex: Used sparingly; decompose into Ubiquitous/Event/State/Unwanted where possible.</li>"},{"location":"roadmap/governance-and-overview/#appendix-b-roles-and-responsibilities","title":"Appendix B: Roles and Responsibilities","text":"<ul> <li>Lead Maintainer (Dave): final arbiter on technical decisions, release management, roadmap ownership.</li> <li>Maintainers: code review, subsystem ownership, triage rotation, quality enforcement.</li> <li>Contributors: feature/bugfix implementation, doc improvements, tests, RFCs/DRs for major changes.</li> <li>Users: issue reporting, diagnostics bundle opt-in, feedback on APIs and examples.</li> </ul>"},{"location":"roadmap/governance-and-overview/#appendix-c-repository-conventions","title":"Appendix C: Repository Conventions","text":"<ul> <li><code>src/meridian/*</code> for runtime packages.</li> <li><code>examples/*</code> for runnable examples and recipes.</li> <li><code>docs/*</code> for plans, support, contributing, and architecture notes.</li> <li><code>tests/*</code> for unit, integration, and property-based tests where appropriate.</li> <li><code>scripts/*</code> for helper tools (lint, type-check, release tasks).</li> <li>Keep files small and cohesive; prefer explicit imports and narrow module APIs.</li> </ul>"},{"location":"roadmap/observability/","title":"Milestone M4: Observability (Logs, Metrics, Tracing)","text":""},{"location":"roadmap/observability/#ears-tasks-and-git-workflow","title":"EARS Tasks and Git Workflow","text":"<p>Branch name: <code>feature/m4-observability</code></p> <p>EARS loop - Explore: map required logs, metrics, tracing to core touchpoints - Analyze: define logging/metrics/tracing interfaces with no-op defaults - Implement: <code>logging.py</code>, <code>metrics.py</code>, <code>tracing.py</code> and core wiring - Specify checks: unit/integration tests for counters, gauges, logs, spans - Commit after each major step</p> <p>Git commands</p> Bash<pre><code>git checkout -b feature/m4-observability\ngit add -A &amp;&amp; git commit -m \"feat(obs): JSON logging facade with context\"\ngit add -A &amp;&amp; git commit -m \"feat(obs): metrics interfaces and no-op + Prometheus adapter\"\ngit add -A &amp;&amp; git commit -m \"feat(obs): tracing adapter with contextvars\"\ngit add -A &amp;&amp; git commit -m \"feat(obs): wire nodes/edges/scheduler metrics and logs\"\ngit add -A &amp;&amp; git commit -m \"test(obs): logging/metrics/tracing and core instrumentation\"\ngit push -u origin feature/m4-observability\n</code></pre> <p>Open PR early; keep commits small and focused</p>"},{"location":"roadmap/observability/#overview","title":"Overview","text":"<p>Introduce first-class observability across the runtime with structured logs, metrics (Prometheus-friendly), and optional tracing hooks. This milestone wires low-overhead instrumentation into hot paths without coupling the runtime to any single telemetry backend. Tracing is optional and disabled by default; logs and metrics are enabled with sane defaults and can be replaced or turned off.</p>"},{"location":"roadmap/observability/#ears-requirements","title":"EARS Requirements","text":"<ul> <li>The system shall emit structured JSON logs for node lifecycle events, exceptions, and tick durations.</li> <li>The system shall expose metrics for nodes (tick latency, messages processed, errors), edges (queue depth, enqueue/dequeue rate, drops, blocked time), and scheduler (runnable nodes, loop latency, priority application counts).</li> <li>Where tracing is enabled, the system shall propagate correlation IDs and create spans at node and edge boundaries.</li> <li>If a message is dropped due to policy, the system shall increment a drops counter and may log at debug to avoid log flooding.</li> <li>While the system is running, the scheduler shall record loop latency and runnable queue sizes at configurable intervals.</li> <li>When a node raises an exception, the system shall log the error with context (node, port, edge, trace_id) and increment error metrics.</li> <li>The system shall offer a no-op observability implementation by default with the option to install a Prometheus exporter and tracing adapter.</li> <li>The system shall support correlation ID propagation across messages via <code>headers.trace_id</code> (generated if missing).</li> </ul>"},{"location":"roadmap/observability/#deliverables","title":"Deliverables","text":"<ul> <li><code>src/meridian/observability/logging.py</code><ul> <li>JSON-structured logging facade with minimal API: <code>info</code>, <code>warn</code>, <code>error</code>, <code>debug</code></li> <li>Context support: node, edge, port, trace_id, event, and timestamps</li> <li>Global configuration: log level, output stream, optional extra fields</li> </ul> </li> <li><code>src/meridian/observability/metrics.py</code><ul> <li>Metrics interface (protocol) with <code>Counter</code>, <code>Gauge</code>, <code>Histogram</code></li> <li>Default no-op implementation</li> <li>Prometheus adapter (optional submodule) exposing a registry and exporter hooks</li> <li>Metric name and label conventions (see below)</li> </ul> </li> <li><code>src/meridian/observability/tracing.py</code><ul> <li>Optional tracing adapter (OpenTelemetry-friendly) with span helpers</li> <li><code>contextvars</code> integration to propagate trace_id and span contexts</li> <li>Functions: <code>start_span(name, attributes)</code> \u2192 context manager; <code>set_trace_id(str)</code></li> </ul> </li> <li>Wiring into core modules:<ul> <li><code>core/message.py</code>: ensure trace_id generation and propagation</li> <li><code>core/edge.py</code>: enqueue/dequeue counters, queue depth gauge, drops counter, blocked time histogram</li> <li><code>core/node.py</code>: <code>messages_processed_total</code>, <code>errors_total</code>; hook lifecycle logs</li> <li><code>core/scheduler.py</code>: <code>runnable_nodes</code> gauge, <code>loop_latency</code> histogram, <code>priority_applied</code> counters; lifecycle logs (start/shutdown)</li> </ul> </li> <li>Documentation updates:<ul> <li>Observability guide with examples, metric catalog, dashboard/alerting recommendations</li> </ul> </li> </ul>"},{"location":"roadmap/observability/#observability-model","title":"Observability Model","text":""},{"location":"roadmap/observability/#logging","title":"Logging","text":"<ul> <li>Format: line-delimited JSON with fields:<ul> <li><code>ts</code> (RFC3339 or epoch_ms), <code>level</code>, <code>component</code> (<code>\"node\"</code>/<code>\"edge\"</code>/<code>\"scheduler\"</code>), <code>event</code>, <code>message</code></li> <li><code>node</code>, <code>port</code>, <code>edge_id</code>, <code>subgraph</code> (when available), <code>trace_id</code></li> <li>extras: <code>error.type</code>, <code>error.msg</code>, <code>error.stack</code> for exceptions</li> </ul> </li> <li>Events (examples):<ul> <li><code>node.start</code>, <code>node.stop</code>, <code>node.error</code>, <code>node.tick</code></li> <li><code>edge.enqueue</code>, <code>edge.dequeue</code>, <code>edge.drop</code>, <code>edge.blocked</code></li> <li><code>scheduler.start</code>, <code>scheduler.shutdown</code>, <code>scheduler.loop_tick</code></li> </ul> </li> <li>Levels:<ul> <li><code>info</code>: lifecycle, start/stop, scheduler start/shutdown</li> <li><code>debug</code>: high-rate events (enqueue/dequeue), policy decisions, tick durations</li> <li><code>warn</code>/<code>error</code>: exceptions, policy misconfigurations, capacity violations</li> </ul> </li> <li>Performance:<ul> <li>Avoid expensive string formatting; build dicts and let logger handle serialization</li> <li>Allow disabling debug logs globally to avoid hot path overhead</li> </ul> </li> </ul>"},{"location":"roadmap/observability/#metrics","title":"Metrics","text":"<ul> <li>Conventions:<ul> <li>Namespace: <code>meridian_*</code></li> <li>Labels: <code>graph</code>, <code>subgraph</code>, <code>node</code>, <code>edge_id</code>, <code>port</code>, <code>policy</code>, <code>priority_band</code></li> </ul> </li> <li>Node metrics:<ul> <li><code>meridian_node_messages_total</code> (counter)</li> <li><code>meridian_node_errors_total</code> (counter)</li> <li><code>meridian_node_tick_duration_seconds</code> (histogram)</li> </ul> </li> <li>Edge metrics:<ul> <li><code>meridian_edge_enqueued_total</code> (counter)</li> <li><code>meridian_edge_dequeued_total</code> (counter)</li> <li><code>meridian_edge_dropped_total</code> (counter)</li> <li><code>meridian_edge_queue_depth</code> (gauge)</li> <li><code>meridian_edge_blocked_time_seconds_total</code> (counter or histogram; see below)</li> </ul> </li> <li>Scheduler metrics:<ul> <li><code>meridian_scheduler_runnable_nodes</code> (gauge)</li> <li><code>meridian_scheduler_loop_latency_seconds</code> (histogram)</li> <li><code>meridian_scheduler_priority_applied_total</code> (counter, labeled by band)</li> </ul> </li> <li>Implementation notes:<ul> <li>No-op by default; optionally enable a Prometheus adapter with on-demand registry creation and HTTP exposition outside of core (user's responsibility)</li> <li>Histograms: choose low-cardinality buckets; provide sane defaults</li> <li>Blocked time: if measured per enqueue attempt, prefer histogram; otherwise accumulate as counter with seconds</li> </ul> </li> </ul>"},{"location":"roadmap/observability/#tracing-optional","title":"Tracing (optional)","text":"<ul> <li>Spans:<ul> <li><code>node.on_message</code>: span per callback with attributes <code>{node, port, trace_id, edge_id}</code></li> <li><code>node.on_tick</code>: span per tick</li> <li><code>edge.enqueue</code>/<code>dequeue</code>: lightweight span or event annotation; minimize overhead</li> <li><code>scheduler.loop</code>: coarse-grained span per loop iteration at debug level</li> </ul> </li> <li>Correlation:<ul> <li><code>Message.headers.trace_id</code> is source of truth; generated if missing</li> <li><code>contextvars</code> store current trace_id; updated upon message receipt and restored after callback</li> </ul> </li> <li>OpenTelemetry adapter:<ul> <li>Provide thin helpers that create spans via OTEL if installed; otherwise no-op</li> <li>Keep tracing disabled by default; enable via environment/config</li> </ul> </li> </ul>"},{"location":"roadmap/observability/#interfaces-and-apis","title":"Interfaces and APIs","text":""},{"location":"roadmap/observability/#logging_1","title":"Logging","text":"Python<pre><code>get_logger() -&gt; Logger\n    Logger methods: info(event, msg, **fields), warn(...), error(...), debug(...)\n    Global configure(level: str, stream: IO | None, extra: dict | None)\n</code></pre> <p>Context helpers: - <code>with_context(**kvs)</code> \u2192 context manager that enriches subsequent logs - <code>set_trace_id(trace_id: str)</code> \u2192 <code>None</code></p>"},{"location":"roadmap/observability/#metrics_1","title":"Metrics","text":"Python<pre><code>get_metrics() -&gt; Metrics\n    Metrics.counter(name, labels_schema) -&gt; Counter\n    Metrics.gauge(name, labels_schema) -&gt; Gauge\n    Metrics.histogram(name, labels_schema, buckets=None) -&gt; Histogram\n</code></pre> <p>Instrumentation helpers: - <code>time_block(name, labels)</code> \u2192 context manager that observes a histogram duration</p>"},{"location":"roadmap/observability/#tracing","title":"Tracing","text":"Python<pre><code>start_span(name: str, attributes: dict | None = None) -&gt; context manager\nset_trace_id(trace_id: str) -&gt; None\nget_trace_id() -&gt; str | None\n</code></pre>"},{"location":"roadmap/observability/#integration-points","title":"Integration Points","text":"<ul> <li><code>core/message.py</code><ul> <li>On Message creation: if <code>headers.trace_id</code> missing, generate via <code>utils.ids</code></li> </ul> </li> <li><code>core/edge.py</code><ul> <li>On <code>put()</code>: increment <code>enqueued_total</code> or <code>dropped_total</code>; update <code>queue_depth</code>; if BLOCKED, record <code>blocked_time</code> as appropriate</li> <li>On <code>get()</code>: increment <code>dequeued_total</code>; update <code>queue_depth</code></li> <li>Logging at debug for enqueue/dequeue; info/warn for drops if needed (rate-limited or disabled by default)</li> <li>Tracing: annotate enqueue/dequeue events when enabled</li> </ul> </li> <li><code>core/node.py</code><ul> <li>Before <code>on_message</code>/<code>on_tick</code>: set <code>contextvars</code> trace_id; start span (optional)</li> <li>After callback: increment <code>messages_total</code>; observe tick duration; handle exceptions (log error; increment <code>errors_total</code>)</li> <li>Lifecycle logs: <code>on_start</code>/<code>on_stop</code> with node identity</li> </ul> </li> <li><code>core/scheduler.py</code><ul> <li>On each loop: observe <code>loop_latency</code> histogram; update <code>runnable_nodes</code> gauge</li> <li>When selecting priority band: increment <code>priority_applied_total</code> with band label</li> <li>Lifecycle logs: <code>scheduler.start</code>/<code>scheduler.shutdown</code></li> <li>Optional span per iteration at debug or sampling enabled</li> </ul> </li> </ul>"},{"location":"roadmap/observability/#configuration","title":"Configuration","text":"YAML<pre><code>ObservabilityConfig\n    logs:\n        level: \"INFO\" | \"DEBUG\" | \"WARN\" | \"ERROR\"\n        json: bool (default true)\n    metrics:\n        exporter: \"noop\" | \"prometheus\"\n        prometheus:\n            namespace: \"meridian\"\n            default_buckets: [0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2, 5]\n    tracing:\n        enabled: bool (default false)\n        provider: \"opentelemetry\" | \"noop\"\n        sample_rate: float (0.0\u20131.0), default 0.0 if disabled\n</code></pre> <p>Runtime wiring: - Provide a simple <code>configure_observability(config: ObservabilityConfig)</code> function - Defaults: logs <code>INFO</code>, metrics noop, tracing disabled</p>"},{"location":"roadmap/observability/#performance-and-overhead","title":"Performance and Overhead","text":"<ul> <li>Keep logging allocations out of the hot path; guard debug logs behind level checks</li> <li>Metrics:<ul> <li>Pre-bind label sets for hot counters/gauges to avoid per-call dict allocations</li> <li>Use integer IDs for node/edge where feasible; export human-readable labels but store numeric keys internally</li> </ul> </li> <li>Tracing:<ul> <li>Disabled by default; fast no-op when off</li> <li>If enabled, keep spans coarse-grained and sampled</li> </ul> </li> </ul>"},{"location":"roadmap/observability/#metric-catalog-initial","title":"Metric Catalog (Initial)","text":"<ul> <li><code>meridian_node_messages_total{node}</code></li> <li><code>meridian_node_errors_total{node}</code></li> <li><code>meridian_node_tick_duration_seconds_bucket/sum/count{node}</code></li> <li><code>meridian_edge_enqueued_total{edge_id, policy}</code></li> <li><code>meridian_edge_dequeued_total{edge_id}</code></li> <li><code>meridian_edge_dropped_total{edge_id, policy}</code></li> <li><code>meridian_edge_queue_depth{edge_id}</code></li> <li><code>meridian_edge_blocked_time_seconds_total{edge_id}</code></li> <li><code>meridian_scheduler_runnable_nodes{band}</code></li> <li><code>meridian_scheduler_loop_latency_seconds_bucket/sum/count{}</code></li> <li><code>meridian_scheduler_priority_applied_total{band}</code></li> </ul>"},{"location":"roadmap/observability/#testing-strategy","title":"Testing Strategy","text":""},{"location":"roadmap/observability/#unit-tests","title":"Unit tests","text":"<ul> <li><code>logging_test.py</code>: structured JSON shape, level filtering, context enrichment, error logging with stack</li> <li><code>metrics_test.py</code>: counters/gauges/histograms API behavior, no-op safety, Prometheus adapter label validation</li> <li><code>tracing_test.py</code>: <code>contextvars</code> propagation, no-op behavior when disabled, span attributes set when enabled</li> <li><code>edge_obs_test.py</code>: counters and gauges update on enqueue/dequeue/drop; blocked time accounting sanity</li> <li><code>node_obs_test.py</code>: tick duration histogram observed; <code>messages_total</code> and <code>errors_total</code> increment; logs emitted with node context</li> <li><code>scheduler_obs_test.py</code>: <code>runnable_nodes</code> gauge updates; loop latency histogram observed; <code>priority_applied</code> increments</li> </ul>"},{"location":"roadmap/observability/#integration-tests","title":"Integration tests","text":"<ul> <li>End-to-end run of <code>hello_graph</code> example:<ul> <li>Ensure basic metrics are incremented and logs are present</li> </ul> </li> <li>Backpressure scenario:<ul> <li>Validate drops/blocked metrics under latest/drop/block policies respectively</li> </ul> </li> <li>Tracing smoke (if provider available):<ul> <li>Verify spans created and trace_id propagated across <code>on_message</code></li> </ul> </li> </ul>"},{"location":"roadmap/observability/#stress-and-reliability","title":"Stress and Reliability","text":"<ul> <li>Run with debug logging disabled to ensure minimal overhead</li> <li>Measure edge put/get throughput with metrics enabled; compare to baseline (\u22645\u201310% overhead target)</li> <li>Long-running soak to ensure metric counters do not overflow typical types and memory remains stable</li> </ul>"},{"location":"roadmap/observability/#acceptance-criteria","title":"Acceptance Criteria","text":"<ul> <li>Logging facade provides structured JSON logs with context and is used across core</li> <li>Metrics interface implemented with no-op default and Prometheus adapter; hot-path instrumentation wired for nodes/edges/scheduler</li> <li>Tracing adapter integrated via <code>contextvars</code>, disabled by default, with verified propagation when enabled</li> <li>Unit and integration tests pass; observability code coverage \u226585% (\u226590% preferred)</li> <li>Overhead remains within acceptable bounds; debug logs can be fully disabled without code changes</li> <li>Documentation updated with configuration, metric catalog, and example dashboards/alerts</li> </ul>"},{"location":"roadmap/observability/#risks-and-mitigations","title":"Risks and Mitigations","text":"<ul> <li>Excessive overhead in hot paths:<ul> <li>Mitigation: No-op fast paths, pre-bound labels, guard debug logs, coarse-grained spans</li> </ul> </li> <li>Log flooding:<ul> <li>Mitigation: Debug level for high-frequency events; rate-limit or disable drop logs by default; rely on metrics for high-rate signals</li> </ul> </li> <li>Metrics cardinality explosion:<ul> <li>Mitigation: Keep labels minimal; avoid per-message IDs; ensure edge_id/node labels remain bounded</li> </ul> </li> <li>Tracing vendor lock-in:<ul> <li>Mitigation: Adapter pattern; optional dependency; strict no-op defaults</li> </ul> </li> </ul>"},{"location":"roadmap/observability/#out-of-scope-deferred","title":"Out of Scope (deferred)","text":"<ul> <li>Auto-exposing Prometheus HTTP endpoint (leave to host application)</li> <li>Advanced log redaction frameworks (provide hooks only)</li> <li>Distributed tracing propagation across processes (future milestones)</li> </ul>"},{"location":"roadmap/observability/#traceability","title":"Traceability","text":"<ul> <li>Implements Technical Blueprint Implementation Plan M4.</li> <li>Satisfies EARS observability requirements for logs, metrics, and tracing, including error reporting and performance-awareness.</li> </ul>"},{"location":"roadmap/observability/#checklist","title":"Checklist","text":"<ul> <li> <code>logging.py</code>: JSON logger, context enrichment, global config</li> <li> <code>metrics.py</code>: interfaces, no-op implementation, Prometheus adapter</li> <li> <code>tracing.py</code>: <code>contextvars</code>-backed adapter, OTEL integration (optional)</li> <li> Core wiring: message, edge, node, scheduler instrumented</li> <li> Tests: unit and integration for observability components</li> <li> Docs: configuration guide, metric catalog, and operational guidance</li> </ul>"},{"location":"roadmap/observability/#completion-summary","title":"Completion Summary","text":"<p>Status: \u2705 COMPLETED on 2025-01-13 Test Results: 99/99 tests passing, 86% overall coverage Deliverables: All M4 requirements satisfied</p>"},{"location":"roadmap/observability/#implementation-details","title":"Implementation Details","text":"<p>Core Observability Components:</p> <ul> <li><code>src/meridian/observability/logging.py</code> (103 lines) - JSON structured logging with <code>contextvars</code></li> <li><code>src/meridian/observability/metrics.py</code> (129 lines) - Prometheus metrics with no-op defaults</li> <li><code>src/meridian/observability/tracing.py</code> (96 lines) - Optional tracing with <code>contextvars</code> integration</li> <li><code>src/meridian/observability/config.py</code> (31 lines) - Unified configuration utilities</li> <li><code>src/meridian/utils/ids.py</code> (13 lines) - ID generation utilities</li> </ul> <p>Core Module Integration:</p> <ul> <li>Enhanced <code>message.py</code> with automatic trace_id generation and headers</li> <li>Instrumented <code>edge.py</code> with comprehensive logging and metrics</li> <li>Enhanced <code>node.py</code> with lifecycle logging and message processing metrics</li> <li>Instrumented <code>scheduler.py</code> with loop latency and scheduling metrics</li> </ul> <p>Testing:</p> <ul> <li>52 new observability unit tests (100% pass rate)</li> <li>1 comprehensive integration test demonstrating end-to-end functionality  </li> <li>Coverage: 97% logging, 100% metrics, 99% tracing</li> </ul> <p>Integration Test Results:</p> <ul> <li>\u2705 3 messages processed successfully</li> <li>\u2705 17 metrics recorded (8 counters, 2 gauges, 7 histograms)</li> <li>\u2705 842 spans created (comprehensive tracing coverage)</li> <li>\u2705 107 structured log lines generated</li> </ul>"},{"location":"roadmap/observability/#ears-requirements-satisfied","title":"EARS Requirements Satisfied","text":"<p>All M4 EARS requirements have been implemented and tested:</p> <ul> <li>\u2705 Structured JSON logs for lifecycle events, exceptions, and key actions</li> <li>\u2705 Metrics for nodes (ticks, processed, errors), edges (depth, rates, drops, blocked time), and scheduler (runnable nodes, loop latency, priority usage)</li> <li>\u2705 Optional tracing with correlation ID propagation and span creation</li> <li>\u2705 No-op observability by default with configurable Prometheus and tracing adapters</li> <li>\u2705 Performance-aware implementation with minimal overhead</li> </ul>"},{"location":"roadmap/observability/#architecture-decisions","title":"Architecture Decisions","text":"<ul> <li>Modular Design: Separate modules for logging, metrics, and tracing with clear interfaces</li> <li>No-op Defaults: Zero overhead when observability is disabled</li> <li>Context Propagation: Uses <code>contextvars</code> for automatic context enrichment</li> <li>Prometheus Compatible: Standard metric naming and label conventions</li> <li>Configuration Driven: Simple configuration for development/production environments</li> </ul>"},{"location":"roadmap/observability/#next-steps","title":"Next Steps","text":"<p>M4 Observability is complete and ready for integration with future milestones. The observability infrastructure provides comprehensive visibility into runtime behavior and performance characteristics.</p>"},{"location":"roadmap/quality-pass/","title":"Milestone M99: Quality Pass (Code Comments, Docs Fixes, CI Docs Checks)","text":"<p>Status: In Progress Owner: Core Maintainers (Lead: <code>doubletap-dave</code>) Duration: 2\u20134 days Branch: <code>main</code> (merged via PR #13 from <code>feature/m99-quality-pass</code>)</p>"},{"location":"roadmap/quality-pass/#1-purpose","title":"1) Purpose","text":"<p>Elevate overall project quality before the next milestone by ensuring:</p> <ul> <li>Public code surfaces are properly documented with clear, typed docstrings and inline comments where helpful.</li> <li>Documentation renders correctly on both GitHub and the GitHub Pages site (MkDocs Material).</li> <li>Documentation is sufficiently detailed, cohesive, and discoverable.</li> <li>CI validates docs build, checks links, and optionally validates code snippets where feasible.</li> </ul>"},{"location":"roadmap/quality-pass/#2-standards-and-scope","title":"2) Standards and Scope","text":""},{"location":"roadmap/quality-pass/#standards-ears-ubiquitous","title":"Standards (EARS: Ubiquitous)","text":"<ul> <li>The project shall follow SRP/DRY and ~200 lines/file guidance for maintainability.</li> <li>The codebase shall expose discoverable, typed public APIs with module/class/function docstrings and usage notes.</li> <li>The documentation shall render without layout/formatting surprises on both GitHub (Markdown viewer) and MkDocs (Material theme).</li> <li>CI shall validate docs build and perform link checks, and optionally verify example/snippet execution where reasonable.</li> </ul>"},{"location":"roadmap/quality-pass/#scope","title":"Scope","text":"<ul> <li><code>src/</code>: docstrings and comments for public APIs and complex logic.</li> <li><code>docs/</code>: formatting fixes, readability polish, navigation sanity.</li> <li><code>examples/</code>: light commentary to guide new users.</li> <li>CI: add docs build + link checking, optional snippet validation, and verification that all workflows are green (lint, type, tests, packaging, pages deploy).</li> </ul>"},{"location":"roadmap/quality-pass/#out-of-scope-for-m99","title":"Out of Scope (for M99)","text":"<ul> <li>Feature work or API changes beyond documentation clarifications.</li> <li>New examples beyond small snippet adjustments.</li> <li>Heavy redesign of the docs site IA\u2014only iterative improvements.</li> </ul>"},{"location":"roadmap/quality-pass/#3-ears-requirements","title":"3) EARS Requirements","text":""},{"location":"roadmap/quality-pass/#documentation-rendering-structure","title":"Documentation Rendering &amp; Structure","text":"<ul> <li>Ubiquitous: The documentation shall render correctly on GitHub and on the MkDocs site with the Material theme.</li> <li>Event-driven: When documentation contains visual separators, the content shall avoid bare YAML front-matter delimiters (<code>---</code> at top of file or isolated lines) that cause rendering ambiguity; use <code>***</code> or <code>&lt;hr&gt;</code> instead.</li> <li>Unwanted: If a Markdown page references another page, links shall be valid for both GitHub preview and MkDocs navigation (prefer root-relative in MkDocs or local paths without <code>../docs</code>).</li> <li>State-driven: While using fenced code blocks, the docs shall specify language identifiers (<code>bash</code>, <code>python</code>, <code>toml</code>, <code>yaml</code>, etc.) for proper highlighting and readability.</li> </ul>"},{"location":"roadmap/quality-pass/#documentation-completeness-clarity","title":"Documentation Completeness &amp; Clarity","text":"<ul> <li>Ubiquitous: The docs shall include clear Quickstart, API overview, Patterns, Observability, and Troubleshooting pages with navigable links from the homepage.</li> <li>Event-driven: When an example is introduced, the docs shall include concise, copy\u2011paste commands to run it (<code>uv</code> commands).</li> <li>Unwanted: If a concept is introduced (e.g., \"latest\" policy), the docs shall cross-link to the API definitions or Patterns section where the behavior is documented, avoiding duplication.</li> <li>State-driven: While the docs evolve, each page shall retain a \"last updated\" indicator (plugin-backed), and broken links shall be flagged in CI.</li> </ul>"},{"location":"roadmap/quality-pass/#code-comments-docstrings","title":"Code Comments &amp; Docstrings","text":"<ul> <li>Ubiquitous: The <code>src/meridian</code> package shall provide docstrings for public classes, functions, and modules that describe contracts, parameters, return types, and error/side-effects semantics.</li> <li>Event-driven: When code includes non-obvious decisions or performance-sensitive logic, the code shall include short comments explaining rationale and expected complexity trade-offs.</li> <li>Unwanted: If a public symbol lacks docstrings, the linter/checker shall fail (or at minimum surface warnings) during CI for M99.</li> <li>State-driven: While maintaining small files, docstrings shall be concise yet sufficient\u2014favor references to API sections in docs for deeper narratives.</li> </ul>"},{"location":"roadmap/quality-pass/#ci-docs-checks","title":"CI Docs Checks","text":"<ul> <li>Ubiquitous: The CI shall build MkDocs and publish artifacts only if docs build succeeds for main and PRs.</li> <li>Event-driven: When CI runs for PRs, it shall run a link checker against the built site or Markdown corpus and fail on broken links.</li> <li>Unwanted: If docs contain malformed Markdown (e.g., unterminated fences), CI shall fail and provide actionable error output.</li> <li>Complex: Where feasible, CI shall validate selected code snippets (shell/python) using a lightweight snippet checker or example execution smoke (best-effort, non-flaky).</li> </ul>"},{"location":"roadmap/quality-pass/#ci-workflow-health-all-jobs-green","title":"CI Workflow Health (All Jobs Green)","text":"<ul> <li>Ubiquitous: All GitHub Actions workflows (lint, format check, type-check, tests with coverage, packaging, and GitHub Pages deploy) shall complete successfully on main and PRs.</li> <li>Event-driven: When a workflow fails, the project shall triage and fix the failure prior to merge; flaky jobs shall be stabilized or quarantined with clear tracking.</li> <li>Unwanted: If a job is intermittently flaky, CI shall apply retries only as a temporary mitigation while a root-cause fix is implemented and documented.</li> <li>State-driven: While coverage targets are enforced, thresholds shall be explicit and documented; any temporary relaxations shall be tracked and time-bounded.</li> </ul>"},{"location":"roadmap/quality-pass/#4-deliverables","title":"4) Deliverables","text":""},{"location":"roadmap/quality-pass/#code-documentation","title":"Code Documentation","text":"<ul> <li>Pass across <code>src/meridian/core/*</code>, <code>src/meridian/observability/*</code>, <code>src/meridian/utils/*</code> to ensure public classes/functions have docstrings with:<ul> <li>Purpose and contracts</li> <li>Parameters and types</li> <li>Return values and types</li> <li>Exceptions and side effects</li> <li>Notes on performance or hot-path constraints (where relevant)</li> </ul> </li> </ul>"},{"location":"roadmap/quality-pass/#docs-rendering-fixes","title":"Docs Rendering Fixes","text":"<ul> <li>Replace problematic horizontal rule markers (<code>---</code> used as separators) with <code>***</code> or HTML <code>&lt;hr&gt;</code>.</li> <li>Ensure code fences specify languages consistently.</li> <li>Normalize relative links to be valid in both GitHub and MkDocs (avoid <code>../docs</code> patterns).</li> <li>Confirm nav entries correspond to real files; adjust headings where it improves page structure.</li> </ul>"},{"location":"roadmap/quality-pass/#docs-completeness","title":"Docs Completeness","text":"<ul> <li>Align homepage references (Quickstart, API, Patterns, Observability, Troubleshooting) and ensure they are consistent and discoverable.</li> <li>Add clarifying examples where minimal, and cross-link to deeper documentation.</li> </ul>"},{"location":"roadmap/quality-pass/#ci-enhancements-docs-specific","title":"CI Enhancements (docs-specific)","text":"<ul> <li>Job to build MkDocs site.</li> <li>Link check job (Markdown or built site).</li> <li>Optional snippet verification job for small example blocks or end-to-end example smoke run.</li> </ul>"},{"location":"roadmap/quality-pass/#ci-workflow-health","title":"CI Workflow Health","text":"<ul> <li>Ensure existing jobs (lint, format, type-check, tests with coverage, packaging) are green.</li> <li>Ensure Pages deploy workflow is green and publishes the site successfully.</li> <li>Add failure triage guidance and ownership for broken or flaky jobs.</li> </ul>"},{"location":"roadmap/quality-pass/#5-work-breakdown","title":"5) Work Breakdown","text":""},{"location":"roadmap/quality-pass/#task-group-a-code-docstrings-and-comments","title":"Task Group A: Code Docstrings and Comments","text":"<ul> <li>A1: Inventory public surfaces in <code>src/meridian/core/</code> and add or refine docstrings.</li> <li>A2: Inventory <code>src/meridian/observability/</code> and document adapters and configuration flows.</li> <li>A3: Inventory <code>src/meridian/utils/</code> and add examples to docstrings where helpful.</li> <li>A4: Add rationale comments for performance-sensitive or non-obvious logic.</li> </ul>"},{"location":"roadmap/quality-pass/#task-group-b-docs-formatting-and-links","title":"Task Group B: Docs Formatting and Links","text":"<ul> <li>B1: Replace bare <code>---</code> separators in docs with <code>***</code> or <code>&lt;hr&gt;</code> where used as visual separators.</li> <li>B2: Add language identifiers to code blocks (<code>bash</code>, <code>python</code>, <code>toml</code>, <code>yaml</code>).</li> <li>B3: Normalize internal links:<ul> <li>Homepage \u2192 <code>quickstart</code>/<code>api</code>/<code>patterns</code>/<code>observability</code>/<code>troubleshooting</code></li> <li>Remove <code>../docs</code> pathing in Markdown links; prefer local MkDocs-friendly paths.</li> </ul> </li> <li>B4: Validate headings and page structure for readability and consistent navigation.</li> </ul>"},{"location":"roadmap/quality-pass/#task-group-c-docs-completeness","title":"Task Group C: Docs Completeness","text":"<ul> <li>C1: Tighten Quickstart commands; ensure <code>uv</code>-based steps are copy-paste-able.</li> <li>C2: API overview alignment: ensure section titles map to public API and reference core docs.</li> <li>C3: Patterns: ensure short examples and cross-links to API semantics (<code>block</code>/<code>drop</code>/<code>latest</code>/<code>coalesce</code>).</li> <li>C4: Observability: confirm metric names align with docs; add sample configuration snippet.</li> <li>C5: Troubleshooting: add clearer remediation steps for common miswiring/type issues.</li> </ul>"},{"location":"roadmap/quality-pass/#task-group-d-ci-docs-checks","title":"Task Group D: CI Docs Checks","text":"<ul> <li>D1: Add job to build the MkDocs site (PR and main).</li> <li>D2: Add link-check job (Markdown or built site).</li> <li>D3: Optional: snippet execution checks or example smoke runs for docs examples (best-effort).</li> <li>D4: Cache dependencies appropriately for speed.</li> </ul>"},{"location":"roadmap/quality-pass/#task-group-e-ci-workflow-health-all-jobs-green","title":"Task Group E: CI Workflow Health (All Jobs Green)","text":"<ul> <li>E1: Audit all workflows (lint, format, type-check, tests, coverage, packaging, Pages deploy) for current failures and flakiness.</li> <li>E2: Fix failing jobs (tool pinning, cache keys, step ordering, permissions, concurrency) and stabilize flaky steps.</li> <li>E3: Enforce required checks on PRs; document ownership and escalation for CI failures.</li> <li>E4: Record coverage thresholds and ensure reporting; revisit temporary relaxations and set timelines to restore targets.</li> <li>E5: Add code scanning (CodeQL) and enable weekly scans; update ruleset to require code scanning results after first successful run.</li> <li>E6: Add Dependabot for GitHub Actions and Python packages (including docs tooling) with weekly cadence and minimal churn.</li> </ul>"},{"location":"roadmap/quality-pass/#6-acceptance-criteria","title":"6) Acceptance Criteria","text":""},{"location":"roadmap/quality-pass/#documentation","title":"Documentation","text":"<ul> <li>All Markdown pages render correctly on both GitHub and the MkDocs site.</li> <li>No broken links in CI's link-check job.</li> <li>Code fences include proper language identifiers.</li> <li>Homepage and README consistently link to Quickstart, API, Patterns, Observability, and Troubleshooting.</li> </ul>"},{"location":"roadmap/quality-pass/#code-docstrings","title":"Code Docstrings","text":"<ul> <li>All public classes, functions, and modules in <code>src/meridian</code> have typed docstrings with contracts and side effects where applicable.</li> <li>Comments exist for non-obvious logic and performance-sensitive sections.</li> </ul>"},{"location":"roadmap/quality-pass/#ci","title":"CI","text":"<ul> <li>CI builds docs and fails on errors. Status: Implemented and green.</li> <li>Link-check job passes; broken links fail PRs. Status: Running but currently non-blocking pending stability.</li> <li>Optional snippet/execution checks pass or are quarantined with clear skip rationale. Status: \"Validate docs commands\" using <code>uv</code> is passing.</li> <li>All workflows (lint, format, type-check, tests with coverage, packaging, Pages deploy) pass on PRs and main; any temporary skips or relaxations are documented and time-bounded. Status: Green on main; badge reflects passing.</li> </ul>"},{"location":"roadmap/quality-pass/#7-risks-and-mitigations","title":"7) Risks and Mitigations","text":""},{"location":"roadmap/quality-pass/#risk-ci-flakiness-in-link-checkingsnippet-execution","title":"Risk: CI flakiness in link checking/snippet execution","text":"<p>Mitigation: Start with deterministic link checking; add snippet checks selectively; mark unstable checks as optional or nightly until stable.</p>"},{"location":"roadmap/quality-pass/#risk-overly-heavy-docstrings-or-duplicated-narratives-across-code-and-docs","title":"Risk: Overly heavy docstrings or duplicated narratives across code and docs","text":"<p>Mitigation: Keep docstrings concise and link to docs for deeper narratives; avoid duplication.</p>"},{"location":"roadmap/quality-pass/#risk-formatting-differences-between-github-and-mkdocs-causing-surprises","title":"Risk: Formatting differences between GitHub and MkDocs causing surprises","text":"<p>Mitigation: Use robust Markdown practices (language fences, avoid front-matter markers as separators, prefer simple relative links).</p>"},{"location":"roadmap/quality-pass/#risk-docs-build-time-increase","title":"Risk: Docs build time increase","text":"<p>Mitigation: Cache dependency installs; skip analytics/extras in CI builds.</p>"},{"location":"roadmap/quality-pass/#8-implementation-notes-and-conventions","title":"8) Implementation Notes and Conventions","text":""},{"location":"roadmap/quality-pass/#docstrings","title":"Docstrings","text":"<ul> <li>Use concise summaries (first line), followed by parameter/return type details.</li> <li>Capture error semantics and side effects (e.g., scheduling, I/O, metrics emission).</li> <li>Reference corresponding sections in docs with stable page anchors where helpful.</li> </ul>"},{"location":"roadmap/quality-pass/#markdown-practices","title":"Markdown Practices","text":"<ul> <li>Replace horizontal rules <code>---</code> used as visual separators with <code>***</code> or <code>&lt;hr&gt;</code> (avoid YAML front-matter ambiguity).</li> <li>Prefer short, local relative links in Markdown (e.g., <code>./quickstart.md</code>) that MkDocs resolves to <code>/quickstart/</code>.</li> <li>Always specify language for code fences: <code>bash`,</code>python<code>, ````toml</code>, <code>```yaml</code>, etc.</li> <li>Keep commands copy-paste friendly; avoid prompts (<code>$</code>).</li> </ul>"},{"location":"roadmap/quality-pass/#ci_1","title":"CI","text":"<ul> <li>Build docs as part of PR checks.</li> <li>Run link-checker against the built site or <code>.md</code> files.</li> <li>Gate merges on docs build + link checks.</li> <li>Optionally run a quick snippet or example smoke to catch drift.</li> </ul>"},{"location":"roadmap/quality-pass/#9-ci-checklist-high-level","title":"9) CI Checklist (High-Level)","text":"<ul> <li> Docs build job added to CI (PR + main). Notes: MkDocs build job is green and runs on PRs and main.</li> <li> Link-checking job added and green. Notes: Link-check runs with retries and caching; promotion to \"required\" is a manual branch protection step after observing stability on main.</li> <li> Optional snippet execution or example smoke job (allowed to fail initially, then promote to required). Notes: \"Validate docs commands\" fixed via <code>uv</code>; runs successfully.</li> <li> All workflow jobs green on PRs and main: lint, format, type-check, tests with coverage, packaging, and Pages deploy. Notes: CI badge reflects passing; flaky link checks quarantined.</li> <li> Coverage thresholds enforced and documented; relaxations (if any) tracked with a deadline to restore targets.</li> <li> Ownership and on-failure triage guidance documented.</li> </ul>"},{"location":"roadmap/quality-pass/#10-execution-checklist","title":"10) Execution Checklist","text":""},{"location":"roadmap/quality-pass/#code-documentation_1","title":"Code Documentation","text":"<ul> <li> <code>src/meridian/core/*</code> docstrings complete and typed \u2014 Completed across Node, Message, Ports, Policies, Edge, Priority Queue, Runtime Plan, Subgraph, and module init. Includes parameters, returns, exceptions, and side\u2011effects.</li> <li> <code>src/meridian/observability/*</code> docstrings complete and typed \u2014 Completed for logging, metrics, tracing, and unified config; includes usage and configuration semantics.</li> <li> <code>src/meridian/utils/*</code> docstrings complete and typed \u2014 Completed for ids, time, and validation helpers; clarified legacy aliases and shallow vs. runtime validations.</li> <li> Non-obvious logic annotated with short clarifying comments \u2014 Added notes on backpressure, fairness model, coalescing behavior, and timing utilities.</li> </ul>"},{"location":"roadmap/quality-pass/#docs-rendering-and-structure","title":"Docs Rendering and Structure","text":"<ul> <li> Replace <code>---</code> separators with <code>***</code> or <code>&lt;hr&gt;</code> where used visually \u2014 Completed in docs sweep (PR #13)</li> <li> Add language identifiers to all fenced code blocks \u2014 Completed in docs sweep (PR #13)</li> <li> Normalize internal links (no <code>../docs</code> in page body) \u2014 Completed in docs sweep (PR #13)</li> <li> Validate headings and section structure for scanability \u2014 Completed primary pass (Quickstart, Patterns). Further polish optional.</li> </ul>"},{"location":"roadmap/quality-pass/#docs-completeness_1","title":"Docs Completeness","text":"<ul> <li> Quickstart commands are consistent and copy\u2011paste ready \u2014 Updated and verified (PR #13)</li> <li> API overview aligned with public classes and semantics \u2014 Verified anchors and examples; incremental fixes applied (PR #13)</li> <li> Patterns include small examples; cross-link to API \u2014 Examples fixed; anchors normalized (PR #13)</li> <li> Observability metrics and configuration confirmed and exemplified \u2014 Example confirmed; no changes required in sweep</li> <li> Troubleshooting includes clear remediation steps \u2014 Filled code fences and commands (PR #13)</li> </ul>"},{"location":"roadmap/quality-pass/#ci-docs-checks_1","title":"CI Docs Checks","text":"<ul> <li> MkDocs build job added and green \u2014 Site build verified on PRs and main.</li> <li> Link-check job added and green \u2014 Stabilized with caching and retries; promotion to \"required\" is a manual branch protection change once main has clean passes.</li> <li> Optional snippet/execution checks configured or queued for nightly \u2014 \"Validate docs commands\" fixed using <code>uv</code> and passing.</li> </ul>"},{"location":"roadmap/quality-pass/#ci-workflow-health_1","title":"CI Workflow Health","text":"<ul> <li> All jobs green on PRs and main (lint, format, type-check, tests with coverage, packaging, Pages deploy) \u2014 CI badge now passing.</li> <li> Flaky jobs identified with a mitigation plan and owner \u2014 Link-check flakiness mitigated via ignores and non-blocking status.</li> <li> Coverage thresholds enforced; relaxations documented and time-bounded \u2014 Gate set via <code>pytest --cov-fail-under</code> in CI; documented thresholds and restoration timelines captured in CONTRIBUTING and M99 notes.</li> <li> Code scanning added and scheduled \u2014 CodeQL workflow runs on PRs, main, and weekly; \"Require code scanning results\" enabled in the main ruleset (CodeQL).</li> <li> Dependency automation added \u2014 Dependabot configured for GitHub Actions, Python packages, and docs tooling with weekly updates.</li> </ul>"},{"location":"roadmap/quality-pass/#11-traceability","title":"11) Traceability","text":"<ul> <li>Aligns with M0 governance (SRP/DRY, small modules, docs-as-product).</li> <li>Supports M6 documentation outcomes by ensuring consistent rendering and completeness.</li> <li>Prepares for M7/M8 by preventing documentation regressions and ensuring code/API are discoverable via docstrings.</li> </ul>"},{"location":"roadmap/quality-pass/#12-change-management","title":"12) Change Management","text":"<ul> <li>Update CHANGELOG with a Quality section noting documentation and CI improvements. \u2014 Next PR</li> <li>Review PRs for docstring quality and Markdown formatting alignment. \u2014 Ongoing</li> <li>Enforce docs build and link checks as required PR gates after proving stability. \u2014 Promotion of link-check to \"required\" occurs via a manual branch protection setting after stability on main. Code scanning requirement enabled: \"Require code scanning results\" (CodeQL) is active in the main ruleset.</li> </ul>"},{"location":"roadmap/quality-pass/#13-acceptance-sign-off","title":"13) Acceptance Sign-off","text":"<ul> <li>Owner: Lead maintainer validates CI additions, rendering fixes, and docstring completeness.</li> <li>Criteria: Docs sweep merged in PR #13; CI green; proceed to promote link-check to required after stability; finalize coverage thresholds and triage ownership notes.</li> </ul>"},{"location":"roadmap/release-v1.0.0/","title":"Codebase Modularization (Phased)","text":"<p>This release includes internal refactors to modularize several monolithic files into focused packages while preserving the public API.</p> <p>Highlights: - Scheduler split into <code>meridian.core.scheduler</code> package (config, coordination, execution, fairness, shutdown) - Observability split across packages: <code>meridian.observability.{tracing,metrics,logging}</code> - Core graph components split: <code>meridian.core.{node,subgraph,edge}</code> packages - Utilities: <code>meridian.core.{priority_queue,runtime_plan,policies}</code> packages</p> <p>Backwards compatibility: - All public imports from <code>meridian.core</code> and <code>meridian.observability</code> continue to work via re-exports - Added import compatibility tests in the test suite</p> <p>Migration notes: - No breaking changes expected. If deep internal imports were used, prefer the package entry points.</p> <p>Owner: GhostWeasel</p>"},{"location":"roadmap/scheduler/","title":"Milestone M3: Scheduler","text":""},{"location":"roadmap/scheduler/#ears-tasks-and-git-workflow","title":"EARS Tasks and Git Workflow","text":"<p>Branch name: <code>feature/m3-scheduler</code></p>"},{"location":"roadmap/scheduler/#ears-loop","title":"EARS Loop","text":"<ul> <li>Explore: review readiness signals, priority bands, backpressure cooperation</li> <li>Analyze: design runnable queues, tick cadence, and BLOCKED handling</li> <li>Implement: <code>scheduler.py</code> run loop, <code>runtime_plan</code>, mutators</li> <li>Specify checks: unit/integration tests for fairness, priorities, shutdown, backpressure</li> <li>Commit after each major step</li> </ul>"},{"location":"roadmap/scheduler/#git-commands","title":"Git Commands","text":"Bash<pre><code>git checkout -b feature/m3-scheduler\ngit add -A &amp;&amp; git commit -m \"feat(scheduler): add Scheduler skeleton and registration\"\ngit add -A &amp;&amp; git commit -m \"feat(scheduler): implement runnable queues and priority bands\"\ngit add -A &amp;&amp; git commit -m \"feat(scheduler): cooperative loop with tick cadence and backpressure\"\ngit add -A &amp;&amp; git commit -m \"feat(scheduler): runtime mutators and graceful shutdown\"\ngit add -A &amp;&amp; git commit -m \"test(scheduler): fairness, priority bias, shutdown semantics\"\ngit push -u origin feature/m3-scheduler\n</code></pre>"},{"location":"roadmap/scheduler/#overview","title":"Overview","text":"<p>Implement the cooperative scheduler that drives node lifecycle and message delivery across the graph. The scheduler evaluates node readiness, drains edges with priority bias for control-plane traffic, and invokes <code>on_message</code>/<code>on_tick</code> and start/stop hooks. It integrates non-blocking backpressure semantics introduced in M2 and readies the runtime for observability wiring in M4.</p>"},{"location":"roadmap/scheduler/#ears-requirements","title":"EARS Requirements","text":"<ul> <li>The system shall provide a Scheduler with public APIs:<ul> <li><code>register(unit: Node | Subgraph)</code> -&gt; None</li> <li><code>run()</code> -&gt; None</li> <li><code>shutdown()</code> -&gt; None</li> <li><code>set_priority(edge_id: str, priority: int)</code> -&gt; None</li> <li><code>set_capacity(edge_id: str, capacity: int)</code> -&gt; None</li> </ul> </li> <li>When the scheduler starts, the system shall invoke <code>on_start</code> for all nodes exactly once.</li> <li>When a message is available on an input edge for a node, the system shall invoke <code>on_message(port, msg)</code> respecting type/port contracts.</li> <li>When the tick cadence elapses, the system shall invoke <code>on_tick</code> on nodes that are runnable.</li> <li>If a shutdown is requested, the system shall gracefully stop the graph, invoking <code>on_stop</code> on each node, and handle draining/flushing of edges according to policy.</li> <li>The system shall prioritize control-plane edges over data-plane edges where priorities are configured.</li> <li>While running, the scheduler shall maintain fairness to avoid starvation across runnable nodes.</li> <li>If a node raises an exception in a lifecycle callback, the system shall capture it and surface through error channels (logs/metrics in M4), and apply node error policy (retry/skip/stop stubbed for now).</li> <li>The system shall support cooperative backpressure: if an output edge signals BLOCKED, the scheduler shall avoid busy-waiting and reschedule producer/consumer appropriately.</li> <li>The system shall remain single-process and asyncio-friendly without requiring async to use it (adapter layer can be added later).</li> </ul>"},{"location":"roadmap/scheduler/#deliverables","title":"Deliverables","text":"<ul> <li><code>src/meridian/core/scheduler.py</code><ul> <li>Scheduler class and run loop [DONE]</li> <li>Registration of graphs/subgraphs with expansion into an internal plan (nodes, edges, ports) [DONE]</li> <li>Runnable queues and priority biasing [DONE]</li> <li>Tick cadence control [DONE]</li> <li>Graceful shutdown and stop semantics [DONE]</li> <li>Runtime mutators: <code>set_priority</code>, <code>set_capacity</code> (with validation and safe application) [DONE]</li> <li>Backpressure-aware emit routing glue between <code>Node.emit</code> and <code>Edge.put</code>/<code>try_put</code> [DONE]</li> </ul> </li> <li><code>src/meridian/core/runtime_plan.py</code> (optional small helper)<ul> <li>Flatten Subgraph into execution plan: topo order, node/edge indices, port maps [DONE - integrated into scheduler]</li> <li>Deterministic IDs for edges and addressable endpoints [DONE]</li> </ul> </li> <li>Minimal integration hooks<ul> <li>Metrics/tracing placeholders (no-op) called at key points (loop iteration start/end, callbacks, enqueue/dequeue) [DONE]</li> </ul> </li> <li>Tests (see Testing Strategy) [DONE - comprehensive unit tests]</li> </ul>"},{"location":"roadmap/scheduler/#scheduling-model","title":"Scheduling Model","text":"<ul> <li> <p>Cooperative loop: [DONE]</p> <ul> <li>Maintain two primary readiness signals: [DONE]<ol> <li>Message-ready: input queues non-empty for a node [DONE]</li> <li>Tick-ready: elapsed tick interval for a node (global cadence with per-node hints) [DONE]</li> </ol> </li> <li>Maintain a runnable structure keyed by <code>(priority_class, node_id)</code> with round-robin within class [DONE]</li> </ul> </li> <li> <p>Priorities: [DONE]</p> <ul> <li>Edge priority integer; map to bands (e.g., control-plane &gt; high &gt; normal) [DONE]</li> <li>Node effective class derived from its highest-priority ready input; if none, normal [DONE]</li> <li>Bias: service higher bands more frequently with a simple ratio (e.g., 4:2:1) [DONE]</li> </ul> </li> <li> <p>Fairness: [DONE]</p> <ul> <li>Within a band, nodes are scheduled round-robin to avoid starvation [DONE]</li> <li>Limit per-iteration work with a budget (e.g., max messages per node per turn) to bound tail latency [DONE]</li> </ul> </li> <li> <p>Backpressure handling: [DONE]</p> <ul> <li><code>Node.emit</code> \u2192 <code>Edge.put</code> returns PutResult: OK, BLOCKED, DROPPED, COALESCED [DONE]</li> <li>On BLOCKED: mark producing node as yield-required; give consumers a chance; requeue producer later [DONE]</li> <li>Avoid busy waits by tracking edges that caused BLOCKED and revisiting when downstream consumption occurs [DONE]</li> </ul> </li> </ul>"},{"location":"roadmap/scheduler/#lifecycle-and-semantics","title":"Lifecycle and Semantics","text":"<ul> <li> <p>start():</p> <ul> <li>Expand subgraphs, allocate runtime plan</li> <li>Initialize nodes: <code>on_start</code> in topo order (producers first); catch exceptions</li> <li>Prime tick timers</li> </ul> </li> <li> <p>run(): [DONE]</p> <ul> <li>Loop until shutdown flag set and all outstanding work quiesces (subject to policy) [DONE]</li> <li> <p>Each iteration:</p> <ul> <li>Pull next node from runnable queues according to priority bands and fairness [DONE]</li> <li>If message-ready: pop one (or small batch) from input edges and invoke <code>on_message</code> [DONE]</li> <li>Else if tick-ready: invoke <code>on_tick</code> [DONE]</li> <li>Track work done; update metrics intents [DONE]</li> </ul> </li> <li> <p>Idle strategy: brief sleep/yield when no work (configurable) [DONE]</p> </li> </ul> </li> <li> <p>shutdown():</p> <ul> <li>Stop accepting new external inputs (if applicable)</li> <li>Drain policy:<ul> <li>block: attempt graceful draining until timeout; then stop</li> <li>drop/latest/coalesce: allow loop to quiesce; then stop</li> </ul> </li> <li><code>on_stop</code> in reverse topo order (consumers first)</li> </ul> </li> </ul>"},{"location":"roadmap/scheduler/#public-apis","title":"Public APIs","text":"<ul> <li><code>register(unit: Node | Subgraph)</code> -&gt; None [DONE]<ul> <li>Accept a Node or Subgraph; multiple calls allowed before <code>run()</code> [DONE]</li> <li>Validate names and conflicts across registrations [DONE]</li> </ul> </li> <li><code>run()</code> -&gt; None [DONE]<ul> <li>Blocking call that runs until shutdown requested [DONE]</li> <li>Optional parameters via constructor: <code>tick_interval</code>, <code>max_batch_per_node</code>, <code>idle_sleep_ms</code> [DONE]</li> </ul> </li> <li><code>shutdown()</code> -&gt; None [DONE]<ul> <li>Signals loop to exit; <code>run()</code> returns after graceful stop [DONE]</li> </ul> </li> <li><code>set_priority(edge_id: str, priority: int)</code> -&gt; None [DONE]<ul> <li>Validate edge exists; adjust band assignment atomically [DONE]</li> </ul> </li> <li><code>set_capacity(edge_id: str, capacity: int)</code> -&gt; None [DONE]<ul> <li>Validate and apply to the underlying Edge safely (may require temporary lock) [DONE]</li> </ul> </li> </ul>"},{"location":"roadmap/scheduler/#configuration","title":"Configuration","text":"<ul> <li>SchedulerConfig<ul> <li><code>tick_interval_ms</code>: default tick cadence baseline (e.g., 50\u2013100ms)</li> <li><code>fairness_ratio</code>: e.g., {control: 4, high: 2, normal: 1}</li> <li><code>max_batch_per_node</code>: to bound per-iteration work</li> <li><code>idle_sleep_ms</code>: backoff when no runnable nodes</li> <li><code>shutdown_timeout_s</code>: soft limit for drain on shutdown</li> </ul> </li> <li>Node hints (optional):<ul> <li><code>desired_tick_interval_ms</code></li> <li><code>priority_override</code> for special nodes (discouraged; use edge priorities instead)</li> </ul> </li> </ul>"},{"location":"roadmap/scheduler/#data-structures","title":"Data Structures","text":"<ul> <li>Ready queues:<ul> <li>Per-band deque of <code>node_ids</code></li> <li>Map <code>node_id</code> -&gt; ReadyState {<code>message_ready</code>, <code>tick_ready</code>, <code>blocked_edges</code>}</li> </ul> </li> <li>Edge registry:<ul> <li><code>edge_id</code> -&gt; EdgeRef {<code>capacity</code>, <code>policy</code>, <code>priority_band</code>, <code>src</code>, <code>dst</code>}</li> </ul> </li> <li>Node registry:<ul> <li><code>node_id</code> -&gt; NodeRef {<code>instance</code>, <code>inputs</code>, <code>outputs</code>, <code>tick_timer</code>, <code>error_policy</code>}</li> </ul> </li> <li>Port map:<ul> <li><code>(node_id, port_name)</code> -&gt; <code>edge_id</code> for inputs/outputs</li> </ul> </li> <li>Message buffers:<ul> <li>Per-input-port pending deque (reads from Edge, small batch caching)</li> </ul> </li> </ul>"},{"location":"roadmap/scheduler/#error-handling","title":"Error Handling","text":"<ul> <li>Catch exceptions from hooks:<ul> <li><code>on_message</code>/<code>on_tick</code>/<code>on_start</code>/<code>on_stop</code> wrapped with try/except</li> <li>Record error intent; apply node error policy (default: skip and continue; configurable later)</li> <li>Avoid bringing down the scheduler unless policy demands</li> </ul> </li> <li>Misconfiguration at runtime mutators:<ul> <li><code>set_priority</code>/<code>set_capacity</code> validate and raise ValueError with context</li> </ul> </li> <li>Backpressure and drops:<ul> <li>Respect PutResult; never spin; ensure progress via consumer scheduling</li> </ul> </li> </ul>"},{"location":"roadmap/scheduler/#testing-strategy","title":"Testing Strategy","text":""},{"location":"roadmap/scheduler/#unit-tests","title":"Unit Tests","text":"<ul> <li>Ready queues and fairness:<ul> <li>Round-robin servicing within band; ratio across bands respected</li> </ul> </li> <li>Priority bias:<ul> <li>Control-plane inputs preempt data-plane consistently</li> </ul> </li> <li>Tick cadence:<ul> <li>Tick-ready nodes get scheduled at configured intervals</li> </ul> </li> <li>Backpressure flow:</li> <li>Producer with BLOCKED result yields; consumer runs; producer resumes successfully</li> <li>Shutdown semantics:<ul> <li>Graceful stop invokes <code>on_stop</code> in reverse topo; drain behavior matches policy</li> </ul> </li> <li>Runtime mutators:<ul> <li><code>set_priority</code> changes servicing band immediately</li> <li><code>set_capacity</code> applied, validated, and reflected in Edge</li> </ul> </li> </ul>"},{"location":"roadmap/scheduler/#integration-tests","title":"Integration Tests","text":"<ul> <li>Producer \u2192 Edge (block) \u2192 Slow Consumer:<ul> <li>Observe producer backpressure and steady-state throughput</li> </ul> </li> <li>Control-plane kill switch:<ul> <li>Control edge triggers immediate <code>on_message</code> even under heavy data-plane load</li> </ul> </li> <li>Mixed policies:<ul> <li>latest/coalesce edges behave under burst; end-to-end message correctness</li> </ul> </li> <li>Error propagation:<ul> <li>Node raising in <code>on_message</code> doesn't crash loop; error counted and flow continues</li> </ul> </li> </ul>"},{"location":"roadmap/scheduler/#stress-and-reliability","title":"Stress and Reliability","text":"<ul> <li>High-throughput graph (multiple producers/consumers) to validate scheduler loop latency bounds</li> <li>Starvation avoidance under varied ready patterns</li> <li>Long-running test (30\u201360 min) without memory growth</li> </ul>"},{"location":"roadmap/scheduler/#performance-guidance","title":"Performance Guidance","text":"<ul> <li>Minimize allocations in loop; pre-allocate small objects where possible</li> <li>Prefer integer <code>node_ids</code>/<code>edge_ids</code> and array-backed structures for hot paths</li> <li>Bound per-iteration work to keep tail latency predictable</li> <li>Use simple timing (monotonic) and avoid per-iteration system time calls when possible</li> </ul>"},{"location":"roadmap/scheduler/#acceptance-criteria","title":"Acceptance Criteria","text":"<ul> <li>Scheduler supports run, shutdown, registration of at least one Subgraph</li> <li>Priority bias demonstrably preempts data-plane under load</li> <li>Backpressure semantics validated with block policy</li> <li>Tick cadence operates within tolerance (\u00b11 tick interval under light load)</li> <li>All unit/integration tests for scheduler pass; coverage for scheduler \u226590%</li> <li>Public API conforms to the draft (README/report), or deviations documented</li> </ul>"},{"location":"roadmap/scheduler/#risks-and-mitigations","title":"Risks and Mitigations","text":"<ul> <li>Over-engineering scheduling policy:<ul> <li>Mitigation: Keep bias ratios simple; no complex RT algorithms in v1</li> </ul> </li> <li>Busy waiting under backpressure:<ul> <li>Mitigation: Explicit BLOCKED handling and consumer-first scheduling</li> </ul> </li> <li>Priority inversion:<ul> <li>Mitigation: Band-based ready queues; derive node band from highest-priority ready input</li> </ul> </li> <li>Complexity in subgraph expansion:<ul> <li>Mitigation: <code>runtime_plan</code> helper with deterministic IDs and small surface area</li> </ul> </li> <li>Shutdown hangs:<ul> <li>Mitigation: Shutdown timeout; policy-aware drain; robust stop ordering</li> </ul> </li> </ul>"},{"location":"roadmap/scheduler/#out-of-scope-deferred","title":"Out of Scope (Deferred)","text":"<ul> <li>Async/await-native scheduler APIs (adapter can be added post-v1)</li> <li>Multi-process or distributed scheduling</li> <li>Advanced error policies (retries with jitter, DLQ routing) beyond placeholders</li> <li>Full observability (wired in M4)</li> </ul>"},{"location":"roadmap/scheduler/#traceability","title":"Traceability","text":"<ul> <li>Implements Technical Blueprint Implementation Plan M3.</li> <li>Fulfills EARS requirements for lifecycle orchestration, priorities, backpressure cooperation, fairness, and graceful shutdown.</li> </ul>"},{"location":"roadmap/scheduler/#checklist","title":"Checklist","text":"<ul> <li> <code>scheduler.py</code>: run loop, readiness detection, lifecycle calls</li> <li> Priority bands and fairness ratio implemented</li> <li> Backpressure-aware emit routing</li> <li> Shutdown semantics with reverse topo <code>on_stop</code></li> <li> Runtime mutators (priority, capacity) with validation</li> <li> Unit/integration tests and coverage \u226590% for scheduler</li> </ul>"},{"location":"roadmap/testing-and-hardening/","title":"Milestone M7: Testing and Hardening","text":""},{"location":"roadmap/testing-and-hardening/#ears-tasks-and-git-workflow","title":"EARS Tasks and Git Workflow","text":"<p>Branch name: <code>feature/m7-testing-hardening</code></p> <p>EARS loop</p> <ul> <li>Explore: inventory gaps in unit/integration/stress/soak coverage</li> <li>Analyze: set performance budgets and diagnostics</li> <li>Implement: tests across suites; benchmarks; CI gates</li> <li>Specify checks: coverage thresholds and regression comparisons</li> <li>Commit after each major step</li> </ul> <p>Git commands</p> Bash<pre><code>git checkout -b feature/m7-testing-hardening\ngit add -A &amp;&amp; git commit -m \"test(unit): expand core coverage for primitives and scheduler\"\ngit add -A &amp;&amp; git commit -m \"test(integration): backpressure, policies, priorities, shutdown\"\ngit add -A &amp;&amp; git commit -m \"test(stress,soak): throughput/latency and long-running stability\"\ngit add -A &amp;&amp; git commit -m \"chore(ci): coverage gates and benchmark regression checks\"\ngit add -A &amp;&amp; git commit -m \"docs(testing): how to run suites and interpret benchmarks\"\ngit push -u origin feature/m7-testing-hardening\n</code></pre> <p>Open PR early; keep commits small and focused</p> <p>Status: In Progress Owner: Core Maintainers Duration: 5\u20137 days</p> <p>PR: <code>feature/m7-testing-hardening</code> (draft) \u2013 incremental commits aligned to checklist</p>"},{"location":"roadmap/testing-and-hardening/#overview","title":"Overview","text":"<p>This milestone raises product confidence to release quality by expanding unit and integration coverage, adding stress and soak tests, validating backpressure correctness, and hardening error paths and shutdown semantics. It also introduces lightweight benchmarking and performance budgets for hot paths (edges and scheduler) and formalizes diagnostics and regression prevention in CI.</p>"},{"location":"roadmap/testing-and-hardening/#ears-requirements","title":"EARS Requirements","text":"<ul> <li>The system shall achieve \u226590% test coverage for core modules and \u226580% overall.</li> <li>The system shall provide unit tests for core classes: <code>Message</code>, <code>PortSpec</code>, <code>Policies</code>, <code>Edge</code>, <code>Node</code>, <code>Subgraph</code>, and <code>Scheduler</code>.</li> <li>The system shall provide integration tests for subgraph composition, backpressure propagation, overflow policies, and control-plane priorities.</li> <li>The system shall provide stress tests that validate throughput and latency characteristics under load, including starvation avoidance and priority preemption.</li> <li>The system shall provide long-running reliability tests to detect memory growth and resource leaks.</li> <li>When a node raises exceptions, the system shall continue running (unless configured otherwise), log errors, and increment metrics.</li> <li>When shutdown is requested, the system shall gracefully stop within a configurable timeout and adhere to edge policies for in-flight items.</li> <li>If regressions are detected by benchmarks (exceeding budget thresholds), the CI shall fail and require triage.</li> </ul>"},{"location":"roadmap/testing-and-hardening/#scope-of-work","title":"Scope of Work","text":""},{"location":"roadmap/testing-and-hardening/#1-unit-tests-core-correctness","title":"1) Unit Tests (Core Correctness)","text":"<ul> <li>Message:<ul> <li>Header normalization, <code>trace_id</code> generation, timestamp helpers.</li> <li>Immutability-by-convention checks and safe header enrichment.</li> </ul> </li> <li>Ports:<ul> <li><code>PortSpec</code> creation, schema compatibility, optional Pydantic adapter hooks (guarded).</li> </ul> </li> <li>Policies:<ul> <li><code>Block</code>: capacity limits return <code>BLOCKED</code> semantics; no drops.</li> <li><code>Drop</code>: counts drops and preserves queue depth.</li> <li><code>Latest</code>: replaces older items; ensures depth bounded to latest semantics.</li> <li><code>Coalesce</code>: deterministic merge function behavior, error surfacing.</li> </ul> </li> <li>Edge:<ul> <li>Bounded capacity accounting, enqueue/dequeue semantics.</li> <li>Overflow behavior per policy with metrics intents.</li> <li>Type enforcement at enqueue boundaries.</li> </ul> </li> <li>Node:<ul> <li>Lifecycle hooks order, emit routing, error policy placeholder behavior.</li> </ul> </li> <li>Subgraph:<ul> <li>Wiring validation, type compatibility, exposure correctness, deterministic edge IDs.</li> </ul> </li> <li>Scheduler:<ul> <li>Ready-queue fairness (round-robin within band).</li> <li>Priority bias ratio across bands.</li> <li>Tick cadence tolerance.</li> <li>Backpressure cooperative scheduling (producer yields, consumer runs, producer resumes).</li> <li>Shutdown sequencing (reverse topo <code>on_stop</code>), drain per policy, timeout behavior.</li> </ul> </li> </ul>"},{"location":"roadmap/testing-and-hardening/#2-integration-tests-end-to-end-scenarios","title":"2) Integration Tests (End-to-End Scenarios)","text":"<ul> <li>Backpressure propagation: (COMPLETE)<ul> <li>Producer \u2192 block edge \u2192 slow consumer: producer experiences <code>BLOCKED</code>; consumer throughput stabilizes. (<code>tests/integration/test_backpressure_end_to_end.py</code>)</li> </ul> </li> <li>Mixed overflow policies: (COMPLETE)<ul> <li><code>latest</code> and <code>drop</code> under burst; validate final outputs and counters. (<code>tests/integration/test_mixed_overflow_policies.py</code>)</li> </ul> </li> <li>Control-plane priority (preemption under load): (COMPLETE)<ul> <li><code>CONTROL</code> messages preempt data-plane and are delivered with bounded latency. (<code>tests/integration/test_priority_preemption_under_load.py</code>)</li> </ul> </li> <li>Shutdown semantics and lifecycle ordering: (COMPLETE)<ul> <li>Start-before-work, reverse stop ordering, deterministic shutdown. (<code>tests/integration/test_shutdown_semantics.py</code>)</li> </ul> </li> <li>Observability smoke: (COMPLETE)<ul> <li>Metrics counters increment; logs include node/scheduler lifecycle and error events. (unit + integration observability tests)</li> </ul> </li> <li>Validation errors:<ul> <li>Mismatched port types and invalid capacities are reported with actionable messages. (covered in unit tests for ports/subgraph)</li> </ul> </li> </ul>"},{"location":"roadmap/testing-and-hardening/#3-stress-soak-and-performance-tests","title":"3) Stress, Soak, and Performance Tests","text":"<ul> <li>Throughput stress:<ul> <li>Multiple producers/consumers; measure enqueue/dequeue rate and loop latency histogram.</li> </ul> </li> <li>Starvation and fairness:<ul> <li>Adversarial patterns to ensure no runnable node is starved across bands.</li> </ul> </li> <li>Priority enforcement under load:<ul> <li>High data-plane traffic with low-rate control messages; ensure bounded preemption latency.</li> </ul> </li> <li>Soak test (30\u201360 min):<ul> <li>Memory usage stability; no unbounded growth; consistent throughput.</li> </ul> </li> <li>Performance budgets (baseline and guardrails):<ul> <li>Edge put/get ops/sec target with metrics disabled vs. enabled (overhead \u2264 5\u201310%).</li> <li>Scheduler loop latency p95 under steady load.</li> <li>Regression thresholds stored as JSON/CSV artifact and compared in CI.</li> </ul> </li> </ul>"},{"location":"roadmap/testing-and-hardening/#4-diagnostics-and-developer-tooling","title":"4) Diagnostics and Developer Tooling","text":"<ul> <li>Enhanced test logging:<ul> <li>Structured logs at info level for lifecycle; debug off by default.</li> </ul> </li> <li>Deterministic seeds:<ul> <li>Pseudo-random test inputs seeded; record seed on failure for reproducibility.</li> </ul> </li> <li>Flake mitigation:<ul> <li>Time-based assertions with tolerances; retries for non-deterministic external timing only where justified.</li> </ul> </li> <li>Failure artifacts:<ul> <li>On failure, emit metrics snapshots, runnable queue stats, and recent logs (captured in-memory) to assist triage.</li> </ul> </li> </ul>"},{"location":"roadmap/testing-and-hardening/#5-ci-and-coverage-gates","title":"5) CI and Coverage Gates","text":"<ul> <li>Coverage thresholds:<ul> <li>Core modules \u226590%, overall \u226580%; enforced in CI.</li> </ul> </li> <li>Sharded test execution:<ul> <li>Split unit, integration, stress into separate jobs; stress/soak may run on nightly builds.</li> </ul> </li> <li>Benchmark job:<ul> <li>Microbenchmarks for edge and scheduler; compare to baseline; fail on significant regressions (&gt;10% unless justified).</li> </ul> </li> <li>Flake quarantine:<ul> <li>Label tests as flaky only with triage issue; auto-retry at most once; track in CI dashboard.</li> </ul> </li> </ul>"},{"location":"roadmap/testing-and-hardening/#test-matrix","title":"Test Matrix","text":"<ul> <li>Python versions: 3.11 (primary), 3.12 (if feasible).</li> <li>Operating systems: Linux (primary), macOS (best-effort smoke).</li> <li>Config toggles:<ul> <li>Observability: metrics/logging on/off; tracing disabled by default; optional smoke with tracing enabled.</li> <li>Policies: <code>block</code>/<code>drop</code>/<code>latest</code>/<code>coalesce</code> coverage.</li> <li>Capacities: small (8\u201316), medium (64\u2013256), large (\u22651024).</li> </ul> </li> </ul>"},{"location":"roadmap/testing-and-hardening/#example-test-cases-representative","title":"Example Test Cases (Representative)","text":"<ul> <li><code>unit/test_edge_policies.py</code><ul> <li><code>test_block_applies_backpressure_until_get</code></li> <li><code>test_drop_increments_counter_and_preserves_depth</code></li> <li><code>test_latest_keeps_only_newest_during_burst</code></li> <li><code>test_coalesce_merges_fast_and_is_pure</code></li> </ul> </li> <li><code>unit/test_scheduler_priority.py</code><ul> <li><code>test_control_plane_preempts_data_plane</code></li> <li><code>test_fairness_within_priority_band_round_robin</code></li> <li><code>test_pq_edge_cases_and_starvation_avoidance</code> (PLANNED)</li> </ul> </li> <li><code>integration/test_backpressure_end_to_end.py</code> (COMPLETE)<ul> <li><code>test_producer_slowed_by_block_policy_slow_consumer</code></li> </ul> </li> <li><code>integration/test_priority_preemption_under_load.py</code> (COMPLETE)<ul> <li><code>test_control_pierces_data_under_sustained_load</code></li> </ul> </li> <li><code>integration/test_mixed_overflow_policies.py</code> (COMPLETE)<ul> <li><code>test_latest_and_drop_under_burst_with_bounded_depth</code></li> </ul> </li> <li><code>integration/test_shutdown_semantics.py</code> (COMPLETE)<ul> <li><code>test_graceful_shutdown_respects_policies_and_timeout_and_ordering</code></li> </ul> </li> <li><code>unit/test_scheduler_pq_edge_cases.py</code> (COMPLETE)<ul> <li><code>test_deduplication_on_reenqueue</code></li> <li><code>test_fifo_within_band_under_reenqueue</code></li> <li><code>test_ratio_bias_prefers_control_but_services_lower_bands</code></li> <li><code>test_fallback_selects_any_available_band</code></li> <li><code>test_bounded_skew_two_nodes_same_band</code></li> </ul> </li> <li><code>stress/test_throughput_and_latency.py</code> (PLANNED)<ul> <li><code>test_scheduler_loop_latency_under_load_with_budgets</code></li> </ul> </li> <li><code>soak/test_long_running_stability.py</code> (PLANNED)<ul> <li><code>test_no_memory_growth_over_time</code></li> </ul> </li> </ul>"},{"location":"roadmap/testing-and-hardening/#performance-and-reliability-budgets","title":"Performance and Reliability Budgets","text":"<ul> <li>Edge operations:<ul> <li>put/get \u2265 1\u20135 million ops/minute on a typical dev machine without metrics; overhead with metrics \u2264 10%.</li> </ul> </li> <li>Scheduler loop:<ul> <li>p95 loop latency within 1\u20132x tick interval baseline under normal load; bounded growth under burst with batch limits.</li> </ul> </li> <li>Priority preemption:<ul> <li>Control-plane message service latency stays below a target bound (e.g., &lt; one tick interval) under sustained data-plane load.</li> </ul> </li> <li>Memory:<ul> <li>No unbounded growth in soak; queues bounded by capacity; references released on drain.</li> </ul> </li> </ul>"},{"location":"roadmap/testing-and-hardening/#risk-assessment-and-mitigations","title":"Risk Assessment and Mitigations","text":"<ul> <li>Flaky timing-sensitive tests:<ul> <li>Mitigation: Use monotonic clocks, tolerances, and deterministic seeds; separate timing-heavy tests into nightly.</li> </ul> </li> <li>Benchmark noise in CI:<ul> <li>Mitigation: Run benchmarks multiple times; use median; allow small variance window; cache warm-up iterations.</li> </ul> </li> <li>Hidden coupling or global state in tests:<ul> <li>Mitigation: Test isolation, fixture teardown, and avoidance of shared singletons; <code>contextvars</code> reset per test.</li> </ul> </li> <li>Coverage inflation without meaningful assertions:<ul> <li>Mitigation: Enforce assertion density in reviews; prefer behavior-focused tests over line coverage alone.</li> </ul> </li> </ul>"},{"location":"roadmap/testing-and-hardening/#acceptance-criteria","title":"Acceptance Criteria","text":"<ul> <li>Core coverage \u226590%, overall coverage \u226580%, enforced in CI. (IN PROGRESS \u2013 tests added; CI gating pending)</li> <li>Unit, integration, stress, and soak suites implemented; stress/soak may run nightly with artifacts. (PARTIAL \u2013 unit/integration complete; stress/soak pending)</li> <li>Backpressure correctness verified end-to-end for all policies. (COMPLETE for Block/Drop/Latest; Coalesce covered in unit)</li> <li>Priority preemption verified with bounded latency under load. (COMPLETE)</li> <li>Graceful shutdown verified with policy-respecting drain and timeout fallback. (COMPLETE)</li> <li>Benchmarks established with stored baselines; CI fails on significant regressions. (PENDING \u2013 initial bench shim present)</li> <li>Failures produce actionable diagnostics (logs, metrics snapshots, seeds). (IN PROGRESS \u2013 logging/metrics integrated; artifacting for failures pending)</li> <li>PR task list alignment: incremental commits for each completed item; PR checklist updated (IN PROGRESS)</li> </ul>"},{"location":"roadmap/testing-and-hardening/#deliverables","title":"Deliverables","text":"<ul> <li>Tests:<ul> <li><code>tests/unit/*</code> covering core primitives, node, subgraph, scheduler.</li> <li><code>tests/integration/*</code> covering backpressure, priorities, shutdown, observability smoke.</li> <li><code>tests/stress/*</code> minimal benchmarks and high-load validations.</li> <li><code>tests/soak/*</code> long-running stability checks (nightly).</li> </ul> </li> <li>CI updates:<ul> <li>Jobs for unit, integration; optional nightly stress/soak; benchmark comparison step; coverage gates.</li> </ul> </li> <li>Docs:<ul> <li><code>CONTRIBUTING/testing.md</code>: how to run suites locally, interpret benchmarks, and debug failures.</li> <li><code>README</code> links to testing docs; note coverage goals and nightly jobs.</li> </ul> </li> </ul>"},{"location":"roadmap/testing-and-hardening/#traceability","title":"Traceability","text":"<ul> <li>Implements Technical Blueprint Implementation Plan M7.</li> <li>Satisfies EARS requirements for coverage, backpressure validation, priority behavior, graceful shutdown, observability validation, and regression prevention.</li> </ul>"},{"location":"roadmap/testing-and-hardening/#checklist","title":"Checklist","text":"<ul> <li> Unit tests: core primitives, node/subgraph, scheduler</li> <li> Unit tests: PQ edge cases (dedup, FIFO, ratio bias, bounded skew)</li> <li> Integration tests: backpressure, priorities (preemption), mixed overflow policies, shutdown, observability smoke</li> <li> Unit tests: node lifecycle error isolation (<code>on_start</code>/<code>on_tick</code>/<code>on_message</code>/<code>on_stop</code>)</li> <li> Stress tests: throughput, latency, fairness, priority preemption</li> <li> Soak tests: long-running stability and memory checks</li> <li> Benchmarks: edge put/get, scheduler loop latency; baseline stored</li> <li> CI: coverage gates, shard runs, nightly stress/soak, benchmark comparison</li> <li> Docs: testing guide, how to run suites and interpret benchmarks; debugging and diagnostics</li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/","title":"Milestone M5: Utilities and Scaffolding","text":""},{"location":"roadmap/utilities-and-scaffolding/#ears-tasks-and-git-workflow","title":"EARS Tasks and Git Workflow","text":"<p>Branch name: <code>feature/m5-utilities-scaffolding</code></p> <p>EARS loop</p> <ul> <li>Explore: identify id/time/validation helpers and scaffolding CLI needs</li> <li>Analyze: finalize templates and validation contracts</li> <li>Implement: utils (ids, time, validation) and generators (node, subgraph)</li> <li>Specify checks: unit tests for utils; e2e generation smoke tests</li> <li>Commit after each major step</li> </ul> <p>Git commands</p> Bash<pre><code>git checkout -b feature/m5-utilities-scaffolding\ngit add -A &amp;&amp; git commit -m \"feat(utils): add ids and time helpers\"\ngit add -A &amp;&amp; git commit -m \"feat(utils): add validation helpers for ports/graphs\"\ngit add -A &amp;&amp; git commit -m \"feat(scaffold): generate_node CLI with templates and tests\"\ngit add -A &amp;&amp; git commit -m \"feat(scaffold): generate_subgraph CLI with templates and tests\"\ngit add -A &amp;&amp; git commit -m \"test(utils,scaffold): unit and generation smoke tests\"\ngit push -u origin feature/m5-utilities-scaffolding\n</code></pre> <p>Open PR early; keep commits small and focused</p>"},{"location":"roadmap/utilities-and-scaffolding/#overview","title":"Overview","text":"<p>Provide developer utilities and project scaffolding to accelerate consistent, SRP/DRY-friendly node and subgraph creation. Utilities include time helpers, correlation ID generation, and validation helpers for types and graph contracts. Scaffolding includes generators to create node and subgraph skeletons conforming to Meridian conventions (~200 lines/file, explicit typing, docstrings, tests).</p>"},{"location":"roadmap/utilities-and-scaffolding/#ears-requirements","title":"EARS Requirements","text":"<ul> <li>The system shall provide utilities for correlation ID generation, monotonic time, and validation helpers for ports and graphs.</li> <li>The system shall provide scaffolding commands to generate node and subgraph templates with recommended structure, typing, and tests.</li> <li>When a developer runs a generator, the system shall create files in the appropriate package locations with consistent naming and boilerplate.</li> <li>If the target path already exists, the generator shall abort with a clear error or optionally support a <code>--force</code> overwrite flag.</li> <li>The system shall maintain SRP/DRY by keeping generator templates small, focused, and extensible.</li> <li>Where Pydantic is enabled, the utilities shall support optional schema adapters without hard dependencies.</li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#deliverables","title":"Deliverables","text":"<ul> <li><code>src/meridian/utils/ids.py</code><ul> <li>Correlation ID generator (uuid4, ULID-like or short lexicographic-friendly option).</li> <li>Functions: <code>new_trace_id()</code>, <code>new_id(prefix: str | None = None)</code>.</li> </ul> </li> <li><code>src/meridian/utils/time.py</code><ul> <li>Monotonic and wall-clock helpers: <code>now_ts_ms()</code>, <code>now_rfc3339()</code>, <code>monotonic_ns()</code>.</li> <li>Simple duration context manager: <code>time_block()</code> \u2192 elapsed seconds.</li> </ul> </li> <li><code>src/meridian/utils/validation.py</code><ul> <li>Port and schema validation helpers.</li> <li>Graph wiring checks (non-exhaustive): type compatibility, unique names, positive capacities.</li> <li>Optional Pydantic adapter interface for schema validation.</li> </ul> </li> <li><code>src/meridian/scaffolding/generate_node.py</code><ul> <li>CLI for generating node modules with class skeleton, typing, docstring, and unit test.</li> <li>Options: <code>--name</code>, <code>--package</code>, <code>--inputs</code>, <code>--outputs</code>, <code>--dir</code>, <code>--force</code>, <code>--include-tests</code>.</li> </ul> </li> <li><code>src/meridian/scaffolding/generate_subgraph.py</code><ul> <li>CLI for generating subgraph modules with exposed ports, connect wiring stubs, and tests.</li> <li>Options: <code>--name</code>, <code>--package</code>, <code>--dir</code>, <code>--force</code>, <code>--include-tests</code>.</li> </ul> </li> <li>Template files (inline within generators or small template directory) that adhere to ~200 lines/file guidance.</li> <li>Documentation updates:<ul> <li>Scaffolding usage guide with examples.</li> <li>Utilities reference and examples for ids/time/validation.</li> </ul> </li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#scaffolding-cli-design","title":"Scaffolding CLI Design","text":""},{"location":"roadmap/utilities-and-scaffolding/#command-generate_nodepy","title":"Command: <code>generate_node.py</code>","text":"<p>Usage:</p> Bash<pre><code>uv run python -m meridian-runtime.scaffolding.generate_node --name PriceNormalizer --package meridian-runtime.nodes --inputs in:dict --outputs out:dict --dir src --include-tests\n</code></pre> <p>Behavior:</p> <ul> <li>Create <code>src/meridian-runtime/nodes/price_normalizer.py</code> with class <code>PriceNormalizer(Node)</code>.</li> <li>Generate stubs for <code>name()</code>, <code>inputs()</code>, <code>outputs()</code>, <code>on_start()</code>, <code>on_message()</code>, <code>on_tick()</code>, <code>on_stop()</code>, and emit usage.</li> <li>Create <code>tests/unit/test_price_normalizer.py</code> with a smoke test and typing checks.</li> </ul> <p>Options:</p> <ul> <li><code>--name</code>: PascalCase class name (required).</li> <li><code>--package</code>: dot path under <code>src/</code> (default: <code>meridian-runtime.nodes</code>).</li> <li><code>--inputs</code>/<code>--outputs</code>: comma-separated list of port:type pairs (e.g., <code>in:int,in2:dict</code>).</li> <li><code>--dir</code>: base directory (default: <code>src</code>).</li> <li><code>--force</code>: overwrite files if they exist.</li> <li><code>--include-tests</code>: create test file under <code>tests/unit/</code>.</li> <li><code>--policy</code>: default edge policy hints in docstring.</li> </ul> <p>Validation:</p> <ul> <li>Validate package path exists or create it.</li> <li>Validate name convention and no conflicts unless <code>--force</code>.</li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#command-generate_subgraphpy","title":"Command: <code>generate_subgraph.py</code>","text":"<p>Usage: Bash<pre><code>uv run python -m meridian-runtime.scaffolding.generate_subgraph --name MarketPipeline --package meridian-runtime.subgraphs --dir src --include-tests\n</code></pre></p> <p>Behavior:</p> <ul> <li>Create <code>src/meridian-runtime/subgraphs/market_pipeline.py</code> with class <code>MarketPipeline(Subgraph)</code>.</li> <li>Add stubs for <code>add_node</code>/<code>connect</code> wiring, <code>expose_input</code>/<code>expose_output</code>, and <code>validate</code> call.</li> <li>Create <code>tests/integration/test_market_pipeline.py</code> with a smoke run (scheduler added by M6/M7 examples).</li> </ul> <p>Options:</p> <ul> <li><code>--name</code>: PascalCase class name (required).</li> <li><code>--package</code>: dot path under <code>src/</code> (default: <code>meridian-runtime.subgraphs</code>).</li> <li><code>--dir</code>: base directory (default: <code>src</code>).</li> <li><code>--force</code>: overwrite files if they exist.</li> <li><code>--include-tests</code>: create integration test file.</li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#template-content-guidelines","title":"Template Content Guidelines","text":""},{"location":"roadmap/utilities-and-scaffolding/#node-template-highlights","title":"Node template highlights","text":"<ul> <li>Class name, module docstring, explicit typing on all public methods.</li> <li>Minimal logic in constructor; keep runtime behavior in lifecycle hooks.</li> <li>Docstring sections: Purpose, Ports, Policies, Error handling, Observability.</li> <li>Emit helper usage with type-safe <code>Message</code> creation.</li> <li>Example usage snippet at bottom (guarded by <code>if __name__ == \"__main__\":</code>) optional and disabled by default.</li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#subgraph-template-highlights","title":"Subgraph template highlights","text":"<ul> <li>Composition pattern with TODO comments to wire nodes.</li> <li>Expose input/output patterns with clear type comments.</li> <li><code>validate()</code> invocation and simple example of capacity/policy configuration in comments.</li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#tests-templates","title":"Tests templates","text":"<ul> <li>Unit test for node: lifecycle calls, <code>on_message</code> invoked, basic emit/contract checks.</li> <li>Integration test for subgraph: basic wiring validation; optional scheduler smoke deferred to M6/M7 but included as TODO.</li> <li>Coverage-friendly structure and markers (pytest).</li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#utilities-design","title":"Utilities Design","text":""},{"location":"roadmap/utilities-and-scaffolding/#idspy","title":"<code>ids.py</code>","text":"Python<pre><code>new_trace_id() -&gt; str\n    Default: UUID4 hex without dashes for compactness.\n    Alternative: ULID-like for lexicographic sort (optional; documented).\n\nnew_id(prefix: str | None = None) -&gt; str\n    If prefix given, return f\"{prefix}_{uuid4hex}\".\n</code></pre> <p>Non-cryptographic note: Document use; not for security tokens.</p>"},{"location":"roadmap/utilities-and-scaffolding/#timepy","title":"<code>time.py</code>","text":"Python<pre><code>now_ts_ms() -&gt; int: epoch milliseconds.\nnow_rfc3339() -&gt; str: RFC3339 with UTC.\nmonotonic_ns() -&gt; int: time.monotonic_ns passthrough.\ntime_block(name: str | None = None) -&gt; context manager:\n    Yields start time, on exit returns elapsed seconds (float) to caller's variable if used with `as`.\n    Keep allocation minimal; no logging here (observed by M4 metrics).\n</code></pre>"},{"location":"roadmap/utilities-and-scaffolding/#validationpy","title":"<code>validation.py</code>","text":"Python<pre><code>validate_ports(node) -&gt; list[Issue]\n    Ensure declared inputs/outputs are PortSpec or supported types.\n\nvalidate_connection(src_spec, dst_spec) -&gt; Issue | None\n    Schema compatibility rules (basic isinstance/typing checks).\n\nvalidate_graph(subgraph) -&gt; list[Issue]\n    Check unique names, capacities &gt; 0, policies not None, and no dangling exposures.\n\npydantic adapter (optional):\n    Protocol class for `validate_payload(model, payload)` if model provided; otherwise no-op.\n\nIssue dataclass:\n    severity: \"error\" | \"warning\"\n    message: str\n    location: tuple or string identifier (node, port, edge)\n</code></pre>"},{"location":"roadmap/utilities-and-scaffolding/#developer-experience-and-conventions","title":"Developer Experience and Conventions","text":"<ul> <li>Generated code adheres to ~200 lines/file guideline; split if expanding.</li> <li>All public methods strictly typed; docstrings explain contracts.</li> <li>Avoid runtime reflection/magic in templates; keep it explicit and easy to test.</li> <li>Scaffolding creates minimal viable code that passes lint, type-check, and unit tests immediately.</li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#documentation-updates","title":"Documentation Updates","text":"<ul> <li><code>docs/scaffolding.md</code>:<ul> <li>Installation/usage examples for both generators.</li> <li>Naming conventions: snake_case modules, PascalCase classes, short port names.</li> <li>Examples of input/output type annotations and Policies usage in docstrings.</li> </ul> </li> <li><code>docs/utils.md</code>:<ul> <li>Quick reference for ids/time/validation helpers.</li> <li>Examples integrating <code>validate_graph</code> into CI or pre-commit.</li> </ul> </li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#testing-strategy","title":"Testing Strategy","text":""},{"location":"roadmap/utilities-and-scaffolding/#unit-tests","title":"Unit tests","text":"<ul> <li><code>ids_test.py</code>: ensure unique IDs; prefix handling; basic performance sanity.</li> <li><code>time_test.py</code>: monotonic returns increasing values; RFC3339 formatting; <code>time_block</code> duration sanity.</li> <li><code>validation_test.py</code>: correct issue detection for incompatible port types, duplicate names, and invalid capacities.</li> <li><code>scaffolding_node_test.py</code>: invoke generator in a temp dir; validate created files compile and basic test template runs.</li> <li><code>scaffolding_subgraph_test.py</code>: invoke generator; validate module import and integration test template created.</li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#integration-tests","title":"Integration tests","text":"<ul> <li>End-to-end generation + run lint/type/tests:<ul> <li>Programmatically generate a node and subgraph; run ruff, mypy (on generated code subset), and pytest for generated tests.</li> </ul> </li> <li>Optional: Use <code>uv run</code> to simulate actual developer flow in CI (documented, not mandatory in M5).</li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#performance-and-maintainability","title":"Performance and Maintainability","text":"<ul> <li>Keep generators small; prefer inline string templates with format variables or a tiny templating helper (no heavy templating engines).</li> <li>Limit options to what's needed; extensibility via comments and TODOs in generated files.</li> <li>Ensure templates are idempotent and deterministic to ease code review in downstream projects.</li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#acceptance-criteria","title":"Acceptance Criteria","text":"<ul> <li>Utilities (ids, time, validation) implemented with docstrings and typing; unit tests pass and coverage \u226590% for utilities.</li> <li>Scaffolding CLIs generate runnable, typed skeletons and tests that pass lint/type/test on creation.</li> <li>Documentation for scaffolding and utilities is added and links from README.</li> <li>Generated files conform to conventions (naming, typing, ~200 lines guidance).</li> <li>CI includes a job that runs scaffolding smoke tests in a temporary workspace.</li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#risks-and-mitigations","title":"Risks and Mitigations","text":"<ul> <li>Overly complex generators:<ul> <li>Mitigation: Keep to a small option set; expose extensibility via TODOs, not codegen complexity.</li> </ul> </li> <li>Template drift with core API evolution:<ul> <li>Mitigation: Add tests that validate generated code imports core APIs; update alongside breaking changes.</li> </ul> </li> <li>Hidden dependency on optional libs (Pydantic):<ul> <li>Mitigation: Use adapters; document optional installation for schema validation.</li> </ul> </li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#out-of-scope-deferred","title":"Out of Scope (deferred)","text":"<ul> <li>Cookiecutter or large templating frameworks.</li> <li>IDE project files or editor integrations.</li> <li>Auto-registration or plugin discovery mechanisms.</li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#traceability","title":"Traceability","text":"<ul> <li>Implements Technical Blueprint Implementation Plan M5.</li> <li>Satisfies EARS requirements for utilities and scaffolding, enabling consistent developer experience and faster adoption.</li> </ul>"},{"location":"roadmap/utilities-and-scaffolding/#checklist","title":"Checklist","text":"<ul> <li> <code>ids.py</code> implemented and tested</li> <li> <code>time.py</code> implemented and tested</li> <li> <code>validation.py</code> implemented and tested</li> <li> <code>generate_node.py</code> CLI implemented; templates and tests</li> <li> <code>generate_subgraph.py</code> CLI implemented; templates and tests</li> <li> Docs updated: <code>scaffolding.md</code>, <code>utils.md</code>, README references</li> <li> CI smoke test for scaffolding end-to-end</li> </ul>"},{"location":"support/HOW-TO-REPORT-ISSUES/","title":"How to Report Issues (Privacy\u2011First)","text":""},{"location":"support/HOW-TO-REPORT-ISSUES/#summary","title":"Summary","text":"<p>This guide explains how to file effective bug reports and feature requests for Meridian Runtime while protecting sensitive information. It provides step\u2011by\u2011step instructions, redaction guidance, and copy\u2011paste templates.</p>"},{"location":"support/HOW-TO-REPORT-ISSUES/#key-principles","title":"Key principles","text":"<ul> <li>Safety by default: avoid sharing secrets, tokens, PII, or domain data payloads.</li> <li>Reproducibility: provide enough context (versions, platform, steps) to reproduce.</li> <li>Precision: include observed vs expected behavior and the smallest failing example you can.</li> <li>Optional diagnostics: prefer anonymized, redacted bundles when sharing runtime context.</li> </ul>"},{"location":"support/HOW-TO-REPORT-ISSUES/#before-you-file","title":"Before You File","text":"<ol> <li> <p>Check the docs</p> <ul> <li><code>README</code> and <code>docs/plan/</code> for intended behavior.</li> <li><code>docs/support/TROUBLESHOOTING.md</code> for known issues and fixes.</li> </ul> </li> <li> <p>Search existing issues/discussions</p> <ul> <li>Your issue may be known, have a workaround, or be in progress.</li> </ul> </li> <li> <p>Prepare a minimal reproduction</p> <ul> <li>Reduce your graph to the smallest example that still fails.</li> <li>Use fake or anonymized data. Do not include payload contents.</li> </ul> </li> </ol>"},{"location":"support/HOW-TO-REPORT-ISSUES/#information-to-include","title":"Information to Include","text":""},{"location":"support/HOW-TO-REPORT-ISSUES/#required","title":"Required","text":"<ul> <li>Summary: 1\u20133 sentences describing the issue or request.</li> <li>Environment: OS, Python version (3.11+), Meridian version.</li> <li>Reproduction: clear steps and minimal, anonymized example (no payload contents).</li> <li>Observed vs Expected: what happened vs what you expected.</li> <li>Logs/errors (redacted): structured logs or error messages with sensitive data removed.</li> </ul>"},{"location":"support/HOW-TO-REPORT-ISSUES/#helpful","title":"Helpful","text":"<ul> <li>Scheduler/graph details: edge bounds and overflow policy, node lifecycle hooks in use.</li> <li>Configuration snippets: anonymized and redacted, or checksums if content is sensitive.</li> <li>Metrics snapshots: <code>counts</code>/<code>gauges</code>/<code>histograms</code> as numbers; avoid labels with PII.</li> <li>Timeline: when the problem started, whether it's intermittent or consistent.</li> <li>Workarounds tried: what you've already tested.</li> </ul>"},{"location":"support/HOW-TO-REPORT-ISSUES/#out-of-scope-for-reports","title":"Out of scope for reports","text":"<ul> <li>Secrets, tokens, credentials, PII, or raw domain payloads.</li> <li>Production\u2011only identifiers (use placeholders).</li> </ul>"},{"location":"support/HOW-TO-REPORT-ISSUES/#redaction-guidance","title":"Redaction Guidance","text":""},{"location":"support/HOW-TO-REPORT-ISSUES/#always-remove-or-replace","title":"Always remove or replace","text":"<ul> <li>Secrets: API keys, tokens, passwords, private URLs.</li> <li>PII: names, emails, phone numbers, addresses, IDs.</li> <li>Payloads: message bodies and data records. If necessary, share schema or field names only.</li> <li>Hostnames and IPs: replace with <code>HOST_A</code>, <code>203.0.113.10</code>, etc.</li> <li>Internal IDs: replace with opaque placeholders (<code>ID_123</code> \u2192 <code>ID_A</code>).</li> </ul>"},{"location":"support/HOW-TO-REPORT-ISSUES/#best-practices","title":"Best practices","text":"<ul> <li>Prefer schemas over data. Example: <code>{user_id: str, balance_cents: int}</code>.</li> <li>For logs, keep structure and keys; replace values with <code>&lt;REDACTED&gt;</code> or representative shapes.</li> <li>For configs, show only relevant keys; mask secrets entirely.</li> </ul>"},{"location":"support/HOW-TO-REPORT-ISSUES/#optional-diagnostics-bundle-planned-cli","title":"Optional: Diagnostics Bundle (Planned CLI)","text":""},{"location":"support/HOW-TO-REPORT-ISSUES/#planned-command-meridian-diagnostics-collect","title":"Planned command: <code>meridian diagnostics collect</code>","text":"<ul> <li>Purpose: gather anonymized runtime metadata, environment info, config checksums, recent logs, and a redacted graph/scheduler snapshot.</li> <li>Default posture: privacy\u2011first. Payload contents are not included by default; sensitive fields are scrubbed.</li> <li>Output: a timestamped archive that you can attach to your issue.</li> </ul>"},{"location":"support/HOW-TO-REPORT-ISSUES/#until-the-cli-is-available","title":"Until the CLI is available:","text":"<ul> <li> <p>Provide a manual bundle with:</p> <ul> <li>Environment: OS, Python, Meridian version.</li> <li>Graph topology snapshot: node/edge counts, edge bounds and overflow policy (no payload schemas required).</li> <li>Logs: last 200\u2013500 lines of structured logs, redacted.</li> <li>Config: relevant settings as key names and <code>boolean</code>/<code>enum</code> values; omit secrets or replace with <code>CHECKSUM(...)</code> if you need to show distinct values without exposing them.</li> <li>Minimal repro: a small, sanitized script or snippet demonstrating the issue.</li> </ul> </li> </ul>"},{"location":"support/HOW-TO-REPORT-ISSUES/#templates","title":"Templates","text":""},{"location":"support/HOW-TO-REPORT-ISSUES/#bug-report","title":"Bug Report","text":"Text Only<pre><code>Title: [Bug] Short description\n\nSummary\nA concise summary of the problem (1\u20133 sentences).\n\nEnvironment\n- OS: macOS/Linux/Windows (version)\n- Python: 3.11.x\n- Meridian: x.y.z\n- Install/Tooling: uv version (if applicable)\n\nReproduction Steps\n1) \u2026\n2) \u2026\n3) \u2026\n\nMinimal Repro Snippet (sanitized; no payload contents)\n- Show relevant node/edge definitions, edge bounds, overflow policies, lifecycle hooks.\n- Provide fake schemas or placeholder field names only.\n\nObserved Behavior\n- What happened, including any redacted stack traces or error codes.\n- Relevant structured logs (redacted):\n  - event=\"edge_overflow\", edge_id=\"EDGE_A\", policy=\"drop\", count=123\n  - event=\"node_error\", node_id=\"NODE_X\", error_type=\"ValueError\", message=\"&lt;REDACTED&gt;\"\n\nExpected Behavior\n- What you expected to happen.\n\nAdditional Context (optional)\n- Metrics counters/gauges (no sensitive labels)\n- Workarounds tried\n- Frequency and timing\n</code></pre>"},{"location":"support/HOW-TO-REPORT-ISSUES/#feature-request","title":"Feature Request","text":"Text Only<pre><code>Title: [Feature] Short description\n\nSummary\n- What problem this would solve and for whom.\n\nMotivation and Use Cases\n- Context and examples (sanitized).\n\nProposed Behavior\n- High\u2011level API or runtime behavior.\n- Defaults and opt\u2011in/opt\u2011out expectations.\n\nAlternatives Considered\n- Other approaches and trade\u2011offs.\n\nImpact and Scope\n- Affected modules (runtime, scheduler, observability, CLI).\n- Backward compatibility considerations.\n</code></pre>"},{"location":"support/HOW-TO-REPORT-ISSUES/#examples-of-good-vs-poor-reports","title":"Examples of Good vs Poor Reports","text":"<p>Good</p> <ul> <li>Includes versions, OS, and tooling.</li> <li>Provides a minimal repro with redacted logs.</li> <li>Specifies observed vs expected behavior.</li> <li>Avoids payload contents and sensitive details.</li> </ul> <p>Poor</p> <ul> <li>\"It doesn't work\" without a repro or environment info.</li> <li>Shares raw production data or secrets.</li> <li>Vague expectations or no description of the failure mode.</li> </ul>"},{"location":"support/HOW-TO-REPORT-ISSUES/#where-and-how-to-submit","title":"Where and How to Submit","text":"<ul> <li>Use your organization's chosen issue tracker or discussion forum.</li> <li>If a private channel exists for sensitive cases, prefer it for sharing any diagnostics bundle.</li> <li>If you email or chat, paste the template with redacted content and attach the sanitized bundle.</li> </ul>"},{"location":"support/HOW-TO-REPORT-ISSUES/#maintainer-process-what-to-expect","title":"Maintainer Process (What to Expect)","text":"<ul> <li>Triage: confirm receipt, label, and request missing info if needed.</li> <li>Reproduce: attempt to reproduce with your minimal example.</li> <li>Diagnose: share findings; may ask for additional sanitized logs or metrics.</li> <li>Fix/Decision: propose a fix, workaround, or an RFC/DR for larger changes.</li> <li>Verify: ask you to validate a patch or a pre\u2011release build when applicable.</li> </ul>"},{"location":"support/HOW-TO-REPORT-ISSUES/#quick-checklist","title":"Quick Checklist","text":"<ul> <li> Read <code>troubleshooting.md</code> and search existing issues</li> <li> Collected environment details (OS, Python, Meridian version)</li> <li> Prepared minimal, sanitized reproduction</li> <li> Redacted logs and configs (no secrets, no payload contents)</li> <li> Wrote clear observed vs expected behavior</li> <li> Attached optional sanitized diagnostics bundle (manual for now)</li> </ul>"},{"location":"support/HOW-TO-REPORT-ISSUES/#faq","title":"FAQ","text":"<p>See our FAQ page for answers to common questions about issue reporting and support.</p> <p>Thank you for helping improve Meridian Runtime while keeping your data safe.</p>"},{"location":"support/TROUBLESHOOTING/","title":"Troubleshooting (Privacy\u2011First)","text":""},{"location":"support/TROUBLESHOOTING/#summary","title":"Summary","text":"<p>This page helps you diagnose and fix common issues when building and running Meridian Runtime, with minimal, privacy\u2011respecting steps. It also cross\u2011links to the API Reference where appropriate and includes corroborated metrics/log event names emitted by the runtime.</p> <p>If a problem isn't covered here, open an issue with full context (OS, Python, commands, logs) or start a discussion.</p>"},{"location":"support/TROUBLESHOOTING/#quick-checklist","title":"Quick checklist","text":"<ol> <li> <p>Verify environment</p> <ul> <li>Python 3.11+ is installed and active in your virtualenv.</li> <li>Dependencies installed via <code>uv sync</code> (or <code>pip install -e \".[dev]\"</code>).</li> </ul> </li> <li> <p>Reproduce with a minimal example</p> <ul> <li>Simplify the graph: few nodes, clear edge capacities/policies.</li> <li>Replace real data with dummy values; remove payload contents.</li> </ul> </li> <li> <p>Collect redacted artifacts</p> <ul> <li>Structured logs: redact values; keep keys, counts, and policy names.</li> <li>Config snippets: include only relevant keys; mask secrets.</li> <li>Metrics snapshots: numeric values; avoid PII in labels.</li> </ul> </li> <li> <p>Compare observed vs expected</p> <ul> <li>Write down what actually happens vs what you expect.</li> </ul> </li> <li> <p>Sanity checks</p> <ul> <li> <p>Lint/type/tests pass:</p> <ul> <li><code>make lint</code></li> <li><code>uv run pytest -q</code></li> </ul> </li> <li> <p>Docs build:</p> <ul> <li><code>make docs-build</code></li> <li><code>uv run mkdocs build</code></li> </ul> </li> </ul> </li> </ol>"},{"location":"support/TROUBLESHOOTING/#common-issues-and-fixes","title":"Common issues and fixes","text":""},{"location":"support/TROUBLESHOOTING/#environment-and-imports","title":"Environment and imports","text":"<p>Symptoms</p> <ul> <li><code>ModuleNotFoundError</code> for project modules or extras.</li> <li>Examples crash or can't import modules.</li> </ul> <p>Fix</p> <ul> <li> <p>Ensure your env is active:</p> <ul> <li><code>source .venv/bin/activate</code> (or platform equivalent)</li> </ul> </li> <li> <p>Re-install dependencies:</p> <ul> <li><code>uv sync</code></li> </ul> </li> <li> <p>Verify Python version:</p> <ul> <li><code>python --version</code> (must be 3.11+)</li> </ul> </li> <li> <p>Run examples using module form to ensure proper PYTHONPATH:</p> <ul> <li><code>uv run python -m examples.hello_graph.main</code></li> </ul> </li> </ul> <p>See also</p> <ul> <li>Concepts overview</li> </ul>"},{"location":"support/TROUBLESHOOTING/#edge-overflow-or-backpressure-surprises","title":"Edge overflow or backpressure surprises","text":""},{"location":"support/TROUBLESHOOTING/#what-the-runtime-does","title":"What the runtime does","text":"<ul> <li>Edges are capacity\u2011bounded FIFO queues with policy\u2011controlled overflow (see API: Edge).</li> <li>If you don't provide a policy on enqueue, the runtime applies internal policy implementations or the edge's configured <code>default_policy</code>.</li> <li>Runtime behavior and outcomes (see API: PutResult):<ul> <li><code>Block</code> \u2192 <code>PutResult.BLOCKED</code>: producer should yield/wait when full.</li> <li><code>Drop</code> \u2192 <code>PutResult.DROPPED</code>: item is discarded when full.</li> <li><code>Latest</code> \u2192 <code>PutResult.REPLACED</code>: keep only the most recent item when full.</li> <li><code>Coalesce(fn)</code> \u2192 <code>PutResult.COALESCED</code>: merge old/new via fn when full.</li> </ul> </li> </ul>"},{"location":"support/TROUBLESHOOTING/#metrics","title":"Metrics","text":"<p>(emitted per edge_id: <code>\"src_node:src_port-&gt;dst_node:dst_port\"</code>)</p> <ul> <li><code>edge_enqueued_total</code></li> <li><code>edge_dequeued_total</code></li> <li><code>edge_dropped_total</code></li> <li><code>edge_queue_depth</code> (gauge)</li> <li><code>edge_blocked_time_seconds</code> (histogram)</li> </ul>"},{"location":"support/TROUBLESHOOTING/#representative-log-events","title":"Representative log events","text":"<ul> <li><code>edge.enqueue</code></li> <li><code>edge.replace</code></li> <li><code>edge.coalesce</code></li> <li><code>edge.coalesce_error</code></li> <li><code>edge.validation_failed</code></li> <li><code>edge.drop</code></li> <li><code>edge.blocked</code></li> <li><code>edge.dequeue</code></li> </ul> <p>Symptoms</p> <ul> <li>Messages stall or appear to drop.</li> <li>Queue depth near capacity; lower throughput than expected.</li> </ul> <p>Likely causes</p> <ul> <li>Capacity too small for bursty workloads.</li> <li>Policy mismatch for the workload (<code>Drop</code> vs <code>Block</code> vs <code>Latest</code> vs <code>Coalesce</code>).</li> <li>Upstream/downstream rate mismatch or blocking operations.</li> </ul> <p>What to try</p> <ol> <li> <p>Inspect and adjust edge configuration</p> <ul> <li>Increase capacity for bursty edges.</li> <li>Use <code>Block</code> for strict delivery (be aware of backpressure).</li> <li>Use <code>Latest</code> for freshness when only the newest matters.</li> <li>Use <code>Coalesce(fn)</code> to merge bursts into fewer items.</li> </ul> </li> <li> <p>Balance node workloads</p> <ul> <li>Move blocking I/O to async or dedicated executors; batch where appropriate.</li> </ul> </li> <li> <p>Add metrics/logs</p> <ul> <li>Track enqueued/dequeued/dropped, blocked time, and depth per edge.</li> </ul> </li> <li> <p>Validate fairness</p> <ul> <li>Ensure scheduler policies aren't starving a node.</li> </ul> </li> </ol> <p>What to collect (redacted)</p> <ul> <li>Edge definitions with capacity and policy names.</li> <li> <p>Logs:</p> <ul> <li><code>event=\"edge.enqueue\" edge_id=\"A:out-&gt;B:in\"</code></li> <li><code>event=\"edge.replace\" edge_id=\"A:out-&gt;B:in\"</code></li> <li><code>event=\"edge.coalesce\" edge_id=\"A:out-&gt;B:in\"</code></li> <li><code>event=\"edge.drop\" edge_id=\"A:out-&gt;B:in\"</code></li> </ul> </li> <li> <p>Metrics snapshot: <code>edge_queue_depth</code>, <code>edge_dropped_total</code>, <code>edge_blocked_time_seconds</code>.</p> </li> </ul> <p>See also</p> <ul> <li>API Reference: Edge</li> <li>API Reference: Backpressure and Overflow</li> <li>API Reference: PutResult</li> </ul>"},{"location":"support/TROUBLESHOOTING/#scheduler-starvation-or-unfairness","title":"Scheduler starvation or unfairness","text":"<p>Symptoms</p> <ul> <li>Certain nodes rarely run or lag behind others.</li> <li>Control\u2011plane tasks take too long to apply.</li> </ul> <p>Likely causes</p> <ul> <li>Long\u2011running tasks monopolize execution.</li> <li>Blocking operations in async contexts causing stalls.</li> <li>High contention on shared resources.</li> </ul> <p>What to try</p> <ol> <li> <p>Audit node work</p> <ul> <li>Break long tasks into smaller units.</li> <li>Use asyncio\u2011friendly APIs; offload blocking calls.</li> </ul> </li> <li> <p>Control\u2011plane prioritization</p> <ul> <li>Ensure control operations have clear priority.</li> </ul> </li> <li> <p>Tune fairness strategy</p> <ul> <li>Try round\u2011robin vs weighted fairness; adjust weights if supported.</li> </ul> </li> </ol> <p>What to collect (redacted)</p> <ul> <li>Summary of node durations (ranges).</li> <li>Structured logs around scheduling decisions (no payloads).</li> <li>Minimal graph snapshot: node names, edge topology.</li> <li>Scheduler metrics: <code>scheduler_runnable_nodes</code>, <code>scheduler_loop_latency_seconds</code>.</li> </ul> <p>See also</p> <ul> <li>API Reference: Scheduler</li> <li>Concepts: Observability</li> </ul>"},{"location":"support/TROUBLESHOOTING/#shutdown-hangs-or-unclean-teardown","title":"Shutdown hangs or unclean teardown","text":"<p>Symptoms</p> <ul> <li>Runtime fails to exit promptly.</li> <li>Nodes' <code>on_stop</code> hooks not called or appear stuck.</li> <li>In\u2011flight work not draining.</li> </ul> <p>Likely causes</p> <ul> <li>Blocking in shutdown paths.</li> <li>Pending tasks waiting on unbounded/stuck conditions.</li> <li>Missing timeouts or cancellation guards.</li> </ul> <p>What to try</p> <ol> <li> <p>Add timeouts to <code>on_stop</code> and drain operations</p> </li> <li> <p>Make <code>on_stop</code> idempotent</p> <ul> <li>Avoid enqueuing new work on shutdown.</li> </ul> </li> <li> <p>Emit lifecycle logs</p> <ul> <li>Provide start/end markers for shutdown sequences.</li> </ul> </li> <li> <p>Use per\u2011edge policies</p> <ul> <li>Drain or drop remaining work explicitly.</li> </ul> </li> <li> <p>Implement proper shutdown handling:</p> Python<pre><code>try:\n    scheduler.run()\nexcept KeyboardInterrupt:\n    print(\"Shutting down gracefully...\")\n    scheduler.shutdown()\nexcept Exception as e:\n    print(f\"Error during execution: {e}\")\n    scheduler.shutdown()\n    raise\n</code></pre> </li> </ol> <p>What to collect (redacted)</p> <ul> <li> <p>Logs:</p> <ul> <li><code>event=\"scheduler.shutdown_start\"</code></li> <li><code>event=\"scheduler.shutdown_requested\"</code></li> <li><code>event=\"scheduler.shutdown_complete\"</code></li> <li><code>event=\"node.start\"</code></li> <li><code>event=\"node.stop\"</code></li> </ul> </li> <li> <p>Note tasks still pending after timeout.</p> </li> </ul> <p>See also</p> <ul> <li>API Reference: Node</li> <li>API Reference: Scheduler</li> </ul>"},{"location":"support/TROUBLESHOOTING/#validation-errors-or-unexpected-payload-handling","title":"Validation errors or unexpected payload handling","text":"<p>What the runtime does</p> <ul> <li>If an edge has a <code>PortSpec</code>, values (or <code>Message.payload</code>) are validated during enqueue. Mismatch logs <code>edge.validation_failed</code> and raises <code>TypeError</code>.</li> </ul> <p>Symptoms</p> <ul> <li>Frequent validation failures.</li> <li>Error events too sparse or too verbose.</li> </ul> <p>Likely causes</p> <ul> <li>Mismatched schema vs runtime data shape.</li> <li>Validation at the wrong boundary.</li> <li>Error policy not configured as intended.</li> </ul> <p>What to try</p> <ol> <li> <p>Validate at boundaries</p> <ul> <li>Use <code>PortSpec</code> at ingress/egress and, when applicable, schema validators in your producer/consumer code.</li> </ul> </li> <li> <p>Tighten/loosen schema choices</p> <ul> <li>Optional vs required fields as systems evolve.</li> </ul> </li> <li> <p>Confirm privacy posture</p> <ul> <li>No payloads in error logs; attach only metadata.</li> </ul> </li> <li> <p>Use subgraph validation before execution:</p> Python<pre><code>issues = subgraph.validate()\nif issues:\n    print(\"Validation issues found:\")\n    for issue in issues:\n        print(f\"  {issue.level}: {issue.message}\")\n    exit(1)\n</code></pre> </li> </ol> <p>What to collect (redacted)</p> <ul> <li>Schema shape (names and types only; no values).</li> <li> <p>Error logs without payload contents:</p> <ul> <li><code>event=\"edge.validation_failed\" edge_id=\"A:out-&gt;B:in\"</code></li> </ul> </li> <li> <p>Validation issues from <code>Subgraph.validate()</code>.</p> </li> </ul> <p>See also</p> <ul> <li>API Reference: Ports and PortSpec</li> <li>API Reference: Message</li> <li>API Reference: ValidationIssue</li> </ul>"},{"location":"support/TROUBLESHOOTING/#loggingtracing-too-verbose-or-too-sparse","title":"Logging/tracing too verbose or too sparse","text":"<p>Symptoms</p> <ul> <li>High log volume impacting performance.</li> <li>Not enough information to diagnose issues.</li> </ul> <p>What to try</p> <ol> <li> <p>Right\u2011size log levels</p> <ul> <li><code>INFO</code> for lifecycle, <code>WARN</code>/<code>ERROR</code> for anomalies, <code>DEBUG</code> sparingly.</li> </ul> </li> <li> <p>Adopt key conventions</p> <ul> <li><code>event</code>, <code>node_id</code>, <code>edge_id</code>, <code>policy</code>, <code>counts</code>, <code>durations</code>.</li> </ul> </li> <li> <p>Sampling</p> <ul> <li>Apply sampling for repetitive debug events.</li> </ul> </li> </ol> <p>What to collect (redacted)</p> <ul> <li>A short sequence (last 200\u2013500 lines) with structured entries.</li> <li>Note which events are missing for diagnosis.</li> </ul> <p>See also</p> <ul> <li>Concepts: Observability</li> </ul>"},{"location":"support/TROUBLESHOOTING/#performance-regressions","title":"Performance regressions","text":"<p>Symptoms</p> <ul> <li>Increased latency or reduced throughput vs a previous run.</li> <li>Hot CPU or I/O saturation.</li> </ul> <p>Likely causes</p> <ul> <li>New blocking paths introduced.</li> <li>Higher cardinality in metric labels or verbose logging.</li> <li>Insufficient edge capacity or missing coalescing for bursty flows.</li> </ul> <p>What to try</p> <ol> <li> <p>Revert to known\u2011good settings</p> <ul> <li>Compare metrics before/after a change.</li> </ul> </li> <li> <p>Profile hot paths (locally)</p> <ul> <li>Identify blocking calls; offload or batch.</li> </ul> </li> <li> <p>Reduce label cardinality</p> <ul> <li>Keep metrics labels low and stable.</li> </ul> </li> </ol> <p>What to collect (redacted)</p> <ul> <li>Before/after metrics: <code>throughput</code>, <code>queue_depth</code>, <code>dropped counts</code>, <code>latency percentiles</code> (if available).</li> <li>Configuration diffs: policy names, capacities.</li> <li>Scheduler metrics: <code>scheduler_loop_latency_seconds</code>, <code>scheduler_runnable_nodes</code>.</li> </ul> <p>See also</p> <ul> <li>API Reference: Backpressure and Overflow</li> <li>Concepts: Patterns</li> </ul>"},{"location":"support/TROUBLESHOOTING/#debugging","title":"Debugging","text":"<ul> <li>Enable debug logs in your observability configuration.</li> <li>Use metrics to inspect edge depths and drops.</li> <li> <p>Use module execution for tests/examples to avoid path issues:</p> <ul> <li><code>uv run pytest</code></li> <li><code>uv run python -m examples.pipeline_demo.main</code></li> </ul> </li> </ul> <p>Key metrics to monitor:</p> <ul> <li>Edge metrics: <code>edge_queue_depth</code>, <code>edge_dropped_total</code>, <code>edge_blocked_time_seconds</code></li> <li>Scheduler metrics: <code>scheduler_runnable_nodes</code>, <code>scheduler_loop_latency_seconds</code>, <code>scheduler_priority_applied_total</code></li> <li>Node metrics: <code>node_messages_total</code>, <code>node_errors_total</code>, <code>node_tick_duration_seconds</code></li> </ul> <p>See also</p> <ul> <li>Concepts: Observability</li> <li>API Reference</li> </ul>"},{"location":"support/TROUBLESHOOTING/#minimal-reproduction-strategy","title":"Minimal reproduction strategy","text":"<ol> <li> <p>Start small</p> <ul> <li>One or two nodes, one edge, a single message type.</li> </ul> </li> <li> <p>Replace data</p> <ul> <li>Use shape\u2011equivalent dummy values; avoid real payloads.</li> </ul> </li> <li> <p>Fix the seed</p> <ul> <li>Avoid non\u2011determinism in tests unless necessary.</li> </ul> </li> <li> <p>Log only essentials</p> <ul> <li>Lifecycle transitions, scheduling decisions, edge <code>enqueues</code>/<code>replaces</code>/<code>coalesce</code>, error summaries.</li> </ul> </li> </ol> <p>Conceptual example (sanitized)</p> <ul> <li>Configure an edge with <code>capacity=10</code> and <code>policy=\"Drop\"</code>.</li> <li>Send 100 synthetic messages; confirm <code>dropped counts</code> rise.</li> <li>Observe metrics and expected behavior.</li> </ul>"},{"location":"support/TROUBLESHOOTING/#safe-artifacts-for-triage","title":"Safe artifacts for triage","text":"<ul> <li> <p>Environment</p> <ul> <li>OS, Python, Meridian versions; tooling versions.</li> </ul> </li> <li> <p>Graph topology snapshot</p> <ul> <li>Node/edge names, capacities, policies; no payload schemas required.</li> </ul> </li> <li> <p>Logs (redacted)</p> <ul> <li>Keep keys; redact values: <code>&lt;REDACTED&gt;</code>.</li> </ul> </li> <li> <p>Metrics</p> <ul> <li>Numeric <code>counters</code>/<code>gauges</code>/<code>histograms</code>; avoid PII in labels.</li> </ul> </li> <li> <p>Config differences</p> <ul> <li>Show changed keys and <code>enum</code>/<code>boolean</code> values; mask secrets or replace with <code>CHECKSUM(...)</code> or <code>PLACEHOLDER</code>.</li> </ul> </li> </ul> <p>Never include</p> <ul> <li>Secrets, tokens, credentials.</li> <li>PII or business data payloads.</li> <li>Proprietary identifiers without anonymization.</li> </ul>"},{"location":"support/TROUBLESHOOTING/#diagnostics-to-include-when-asking-for-help","title":"Diagnostics to include when asking for help","text":"<ul> <li>OS and Python version.</li> <li>Exact command(s) you ran.</li> <li>Minimal snippet or steps to reproduce.</li> <li>Full error output and any relevant logs (redacted).</li> <li>Any local changes or configuration differences.</li> </ul>"},{"location":"support/TROUBLESHOOTING/#known-pitfalls","title":"Known pitfalls","text":"<ul> <li> <p>Mixing package managers</p> <ul> <li>Prefer <code>uv</code> for this repo to avoid environment drift; don't interleave <code>pip</code> unless necessary.</li> </ul> </li> <li> <p>Stale caches</p> <ul> <li>Clear <code>.pytest_cache</code>, <code>.mypy_cache</code>, <code>.ruff_cache</code>, and any build artifacts if behavior seems inconsistent.</li> </ul> </li> <li> <p>Renamed documentation</p> <ul> <li>After file moves/renames, update internal links and nav in <code>mkdocs.yml</code>. In strict mode, broken links abort the build.</li> </ul> </li> </ul>"},{"location":"support/TROUBLESHOOTING/#see-also","title":"See also","text":"<ul> <li>How to report issues</li> <li>Contributing guide</li> <li>API Reference</li> <li>Concepts overview</li> </ul>"},{"location":"support/deprecation-policy/","title":"Deprecation policy","text":"<p>We follow Semantic Versioning (SemVer): MAJOR.MINOR.PATCH.</p> <ul> <li>Breaking changes only in MAJOR versions.</li> <li>MINOR versions may add features and deprecate APIs.</li> <li>PATCH versions include bug fixes and internal-only changes.</li> </ul>"},{"location":"support/deprecation-policy/#deprecation-process","title":"Deprecation process","text":"<ol> <li>Mark API as deprecated with clear warnings in docs and code (where applicable).</li> <li>Maintain the deprecated API for at least one MINOR release after the deprecation is announced.</li> <li>Remove the deprecated API in the next MAJOR release.</li> </ol>"},{"location":"support/deprecation-policy/#guidance","title":"Guidance","text":"<ul> <li>Prefer additive changes when possible.</li> <li>Provide migration notes and examples in the release notes.</li> <li>Emit non-intrusive warnings (logging/doc) rather than raising errors.</li> </ul>"},{"location":"support/deprecation-policy/#compatibility-guarantees","title":"Compatibility guarantees","text":"<ul> <li>Built-in nodes aim for forward-compatible configuration defaults.</li> <li>Node behavior changes will be documented and versioned with clear guidance.</li> </ul>"},{"location":"support/faq/","title":"Frequently Asked Questions (FAQ)","text":"<p>This page consolidates common questions about Meridian Runtime, organized by topic.</p>"},{"location":"support/faq/#general-questions","title":"General Questions","text":""},{"location":"support/faq/#what-is-meridian-runtime-and-what-are-its-core-components","title":"What is Meridian Runtime and what are its core components?","text":"<p>Meridian Runtime is a minimal, reusable, graph-based runtime for Python designed for building real-time, observable dataflows. It models applications as graphs of <code>Node</code>s connected by typed <code>Edge</code>s and composed into <code>Subgraph</code>s. The execution is coordinated by a <code>Scheduler</code>.</p> <p>Core components:</p> <ul> <li>Nodes: Single-responsibility processing units that consume messages, perform work, and emit messages. They have lifecycle hooks (<code>on_start</code>, <code>on_message</code>, <code>on_tick</code>, <code>on_stop</code>) and handle errors locally.</li> <li>Edges: Typed, bounded queues connecting two nodes. They enforce message schemas, provide flow control, and apply overflow policies when capacity is reached. Edges are always bounded to prevent memory exhaustion.</li> <li>Subgraphs: Reusable compositions of nodes and edges that encapsulate a set of functionalities with defined inputs and outputs, allowing for modularity and reuse.</li> <li>Scheduler: The orchestrator of the runtime, responsible for dispatching ready work units, honoring priorities (e.g., control-plane over data-plane), managing concurrency and fairness, and facilitating graceful shutdown.</li> <li>Messages: Immutable containers carrying payloads and headers (e.g., <code>trace_id</code>, timestamp) across edges. They can be classified as <code>DATA</code>, <code>CONTROL</code>, or <code>ERROR</code> messages, influencing their routing and priority.</li> <li>PortSpec: Defines the name, schema/type, and overflow policy for a port, driving <code>Edge</code> typing and validation.</li> </ul>"},{"location":"support/faq/#is-a-graph-runtime-overkill-for-my-use-case","title":"Is a graph runtime overkill for my use case?","text":"<p>For simple, linear pipelines a small asyncio app may suffice. Meridian shines when you have multiple interacting flows, need backpressure and priorities, and value observability and reuse.</p>"},{"location":"support/faq/#does-meridian-require-a-specific-web-framework-or-broker","title":"Does Meridian require a specific web framework or broker?","text":"<p>No. It is framework\u2011agnostic and runs in\u2011process. Brokers/codecs become relevant in future distributed modes.</p>"},{"location":"support/faq/#can-i-use-pydanticpyrightmypy-with-meridian","title":"Can I use Pydantic/Pyright/MyPy with Meridian?","text":"<p>Yes. Meridian encourages explicit typing and can integrate optional schema libraries. Choose what fits your project's standards.</p>"},{"location":"support/faq/#how-do-i-handle-longrunning-or-blocking-work","title":"How do I handle long\u2011running or blocking work?","text":"<p>Prefer async IO; for CPU\u2011bound tasks, offload to thread/process pools and keep nodes responsive. Use backpressure to prevent overload.</p>"},{"location":"support/faq/#architecture-and-design","title":"Architecture and Design","text":""},{"location":"support/faq/#how-does-meridian-runtime-ensure-predictability-and-stability-under-load","title":"How does Meridian Runtime ensure predictability and stability under load?","text":"<p>Meridian Runtime prioritizes predictability and stability through several key design principles and mechanisms:</p> <ul> <li>Bounded Edges with Overflow Policies: All edges have a fixed capacity. When an edge reaches capacity, a configured overflow policy (e.g., <code>block</code>, <code>drop</code>, <code>latest</code>, <code>coalesce</code>) is applied, preventing unbounded queue growth and memory exhaustion. The <code>block</code> policy applies backpressure upstream, signaling producers to slow down.</li> <li>Cooperative Scheduler with Priorities and Fairness: The scheduler dispatches work based on node readiness (messages or ticks) while maintaining fairness among runnable nodes to avoid starvation. It also supports priority bands (e.g., Control-plane &gt; High &gt; Normal), ensuring critical operations are processed first, even under heavy data-plane load.</li> <li>Graceful Shutdown: The system is designed to stop gracefully upon request, draining in-flight messages according to policies and invoking <code>on_stop</code> hooks on nodes in reverse topological order, ensuring resources are released cleanly.</li> <li>Error Handling Policies: If a node raises an exception in a lifecycle hook, the system captures and reports it via observability, applying the node's error policy (default: skip and continue) without crashing the entire scheduler.</li> <li>Low-Overhead Observability: While under sustained load, the system maintains bounded queue depths and an efficient idle strategy to avoid busy loops, ensuring that observability features (logs, metrics, tracing) have minimal overhead when enabled and are fast no-ops when off.</li> </ul>"},{"location":"support/faq/#how-are-applications-structured-and-composed-in-meridian-runtime","title":"How are applications structured and composed in Meridian Runtime?","text":"<p>Meridian Runtime promotes a modular and composable approach to application structuring, centered around <code>Node</code>s and <code>Subgraph</code>s:</p> <ul> <li>Graph of Nodes and Edges: Applications are modeled as directed graphs where individual <code>Node</code>s (single-responsibility processing units) are connected by typed, bounded <code>Edge</code>s.</li> <li>Subgraph Composition: <code>Subgraph</code>s are reusable composite units that encapsulate a set of nodes and edges with defined input and output ports. This allows for hierarchical composition, where smaller subgraphs can be nested into larger ones, promoting reusability and local reasoning about performance and failure modes.</li> <li>Clear Boundaries: Each component (<code>Node</code>, <code>Edge</code>, <code>Subgraph</code>, <code>Scheduler</code>) has a clear, narrow purpose, adhering to the Single Responsibility Principle (SRP). This design philosophy leads to smaller, more testable modules (guidance of ~200 lines per file) and avoids hidden domain coupling.</li> <li>Explicit Wiring and Validation: Connections between nodes within a subgraph, and exposed ports of subgraphs, are explicitly defined. The system performs comprehensive validation during graph composition (e.g., unique names, port existence, schema compatibility, positive capacities, consistent policies) to ensure structural integrity and refuse to run invalid graphs.</li> <li>Framework-Agnostic and In-Process: The runtime is designed to be framework-agnostic and in-process, providing APIs that are friendly to asyncio usage without requiring it, enhancing its portability and ease of integration into existing Python applications.</li> </ul>"},{"location":"support/faq/#how-does-meridian-runtime-handle-backpressure-and-overflow-conditions-on-its-edges","title":"How does Meridian Runtime handle backpressure and overflow conditions on its edges?","text":"<p>Meridian Runtime's design fundamentally incorporates backpressure and explicit overflow policies on its bounded edges to ensure system stability and predictable behavior under varying loads:</p> <ul> <li>Bounded Edges: Every <code>Edge</code> has a defined, finite capacity. This is a critical design choice, as unbounded queues are explicitly not supported to prevent memory exhaustion.</li> <li>Overflow Policies: When an <code>Edge</code>'s capacity is reached, one of the following configurable overflow policies is applied:</li> <li>Block (Default): The system applies backpressure upstream, causing the producer node to yield or block until space becomes available in the queue. This ensures lossless delivery for critical data.</li> <li>Drop: New messages are immediately discarded if the queue is full, and a drop metric is incremented. This is suitable for telemetry or low-importance streams where freshness is more critical than completeness.</li> <li>Latest: Only the newest message is retained, discarding older messages beyond the capacity limit. This is useful for UI state updates or configuration changes where only the most recent value matters.</li> <li>Coalesce: Incoming messages are combined with existing queued messages using a supplied, deterministic function. This policy is effective for aggregating or summarizing bursty data, preserving type correctness while compressing bursts (e.g., combining sensor readings into a single aggregate).</li> <li>Cooperative Backpressure: The <code>Scheduler</code> cooperates with these policies. If an output edge signals <code>BLOCKED</code>, the scheduler avoids busy-waiting and reschedules the producer, prioritizing consumers to make forward progress. This mechanism prevents deadlocks and ensures efficient resource utilization.</li> <li>Metrics for Visibility: Edges expose metrics such as <code>queue_depth</code>, <code>drops_total</code>, and <code>blocked_time_seconds</code>, providing crucial visibility into how backpressure and overflow policies are performing and where bottlenecks might occur.</li> </ul>"},{"location":"support/faq/#observability","title":"Observability","text":""},{"location":"support/faq/#what-are-the-observability-features-in-meridian-runtime","title":"What are the observability features in Meridian Runtime?","text":"<p>Meridian Runtime provides first-class, built-in observability through structured logging, metrics collection, and distributed tracing. These features are designed for low overhead and seamless integration with external monitoring systems.</p> <ul> <li>Structured JSON Logs: The system emits line-delimited JSON logs for lifecycle events, exceptions, and key actions. Logs include contextual fields like <code>ts</code>, <code>level</code>, <code>component</code>, <code>node</code>, <code>port</code>, <code>edge_id</code>, and <code>trace_id</code>, making them machine-readable and easy to aggregate. Debug-level logs are used for high-frequency events and can be disabled to minimize overhead.</li> <li>Metrics Collection: The system exposes a variety of metrics for different components:</li> <li>Nodes: <code>messages_total</code>, <code>errors_total</code>, <code>tick_duration_seconds</code> (histogram).</li> <li>Edges: <code>enqueued_total</code>, <code>dequeued_total</code>, <code>dropped_total</code>, <code>queue_depth</code> (gauge), <code>blocked_time_seconds</code> (counter/histogram).</li> <li>Scheduler: <code>runnable_nodes</code> (gauge), <code>loop_latency_seconds</code> (histogram), <code>priority_applied_total</code> (counter labeled by band). Metrics follow Prometheus-compatible conventions and are accessible via an interface, with a no-op default and an optional Prometheus adapter.</li> <li>Distributed Tracing: When enabled, the system propagates correlation IDs (<code>trace_id</code>) across messages and creates spans at node and edge boundaries. This is achieved through <code>contextvars</code> integration and an optional OpenTelemetry-friendly adapter. Tracing is disabled by default to ensure zero overhead when not needed.</li> <li>Privacy-Safe Diagnostics: The system ensures that sensitive information (secrets, PII, payload contents) is scrubbed or omitted by default from logs and diagnostics bundles, providing hooks for log redaction at the application layer.</li> </ul>"},{"location":"support/faq/#how-do-i-enable-metrics-and-tracing","title":"How do I enable metrics and tracing?","text":"<p>Metrics are enabled by default with no-op implementation. To enable Prometheus metrics:</p> Python<pre><code>from meridian.observability import configure_observability\n\nconfigure_observability({\n    \"metrics\": {\"exporter\": \"prometheus\"}\n})\n</code></pre> <p>Tracing is disabled by default. Enable with:</p> Python<pre><code>configure_observability({\n    \"tracing\": {\"enabled\": True, \"provider\": \"opentelemetry\"}\n})\n</code></pre>"},{"location":"support/faq/#what-metrics-should-i-monitor","title":"What metrics should I monitor?","text":"<p>Key metrics to watch: - Node metrics: <code>meridian_node_messages_total</code>, <code>meridian_node_errors_total</code>, <code>meridian_node_tick_duration_seconds</code> - Edge metrics: <code>meridian_edge_queue_depth</code>, <code>meridian_edge_dropped_total</code>, <code>meridian_edge_blocked_time_seconds_total</code> - Scheduler metrics: <code>meridian_scheduler_runnable_nodes</code>, <code>meridian_scheduler_loop_latency_seconds</code></p>"},{"location":"support/faq/#how-do-i-handle-high-throughput-scenarios","title":"How do I handle high-throughput scenarios?","text":"<ol> <li>Use appropriate edge capacities and policies</li> <li>Monitor for backpressure and adjust accordingly</li> <li>Consider using <code>Latest</code> or <code>Coalesce</code> policies for burst handling</li> <li>Profile node processing times and optimize bottlenecks</li> </ol>"},{"location":"support/faq/#development-and-contributing","title":"Development and Contributing","text":""},{"location":"support/faq/#what-development-and-operational-tooling-does-meridian-runtime-provide","title":"What development and operational tooling does Meridian Runtime provide?","text":"<p>Meridian Runtime offers a robust set of tooling and practices to ensure a smooth developer experience, high quality, and predictable operations:</p> <ul> <li>Reproducible Development Workflow: The system supports a <code>uv</code>-native workflow (<code>uv init</code>, <code>uv lock</code>, <code>uv sync</code>, <code>uv run</code> / <code>uvx</code>) for consistent and reproducible development, testing, and examples across environments.</li> <li>Scaffolding Commands: CLI commands are provided to generate <code>Node</code> and <code>Subgraph</code> skeletons, including class structure, explicit typing, docstrings, and basic unit/integration tests, accelerating consistent and convention-adhering development.</li> <li>Automated Quality Gates: Continuous Integration (CI) enforces high quality standards by running linting (<code>ruff</code>), formatting (<code>black</code>), static type analysis (<code>mypy</code>), and automated tests (<code>pytest</code>) with strict coverage thresholds (\u226590% for core, \u226580% overall). These checks are mandatory for merging code.</li> <li>Semantic Versioning and Release Process: The project adheres to Semantic Versioning for its public API, publishing artifacts to package registries (e.g., PyPI) with signed distributions. A formal deprecation policy ensures API stability and provides clear migration guidance for users.</li> <li>Comprehensive Documentation: All aspects of the runtime, from installation and core concepts to API references, common patterns, troubleshooting guides, and observability configuration, are thoroughly documented. Examples are runnable, modular, and demonstrate best practices, aiding in faster adoption and understanding.</li> <li>Diagnostics and Troubleshooting: The CLI supports gathering anonymized runtime metadata, environment info, and logs into a diagnostics bundle to assist in troubleshooting issues, with built-in redaction rules for sensitive data.</li> </ul>"},{"location":"support/faq/#why-keep-milestone-files-in-git","title":"Why keep milestone files in Git?","text":"<p>It ensures plans are versioned with code, discussed via PRs, and discoverable close to implementation.</p>"},{"location":"support/faq/#how-do-milestones-relate-to-issuesprs","title":"How do milestones relate to issues/PRs?","text":"<p>Each milestone should link to a tracking issue or project board; individual items are implemented via issues/PRs that reference the milestone.</p>"},{"location":"support/faq/#whats-the-file-size-guidance-for-contributions","title":"What's the file size guidance for contributions?","text":"<p>Keep files small (~200 lines) and responsibilities focused. Include unit tests for core changes; add integration tests for subgraph behavior.</p>"},{"location":"support/faq/#how-does-meridian-runtime-prioritize-quality-and-maintainability","title":"How does Meridian Runtime prioritize quality and maintainability?","text":"<p>Meridian Runtime is built with a strong emphasis on quality and maintainability, driven by clear principles and continuous integration practices:</p> <ul> <li>Single Responsibility Principle (SRP) and DRY: Components are designed with a clear, narrow purpose, and the codebase adheres to SRP and \"Don't Repeat Yourself\" (DRY) principles, with a guidance of keeping files small (~200 lines per file).</li> <li>Async-Friendly and Framework-Agnostic: Implemented in Python 3.11+, the system is designed to be asyncio-friendly without imposing asyncio requirements, enhancing its adaptability and reducing coupling. It avoids global mutable state, preferring explicit dependency injection.</li> <li>Comprehensive Testing: The project maintains high code coverage (\u226590% for core modules, \u226580% overall), enforced by CI gates. This includes extensive unit tests for core primitives, integration tests for end-to-end scenarios (e.g., backpressure propagation, control-plane priority, graceful shutdown), and plans for stress and soak tests to validate performance and detect resource leaks under load.</li> <li>Static Analysis and Linting: CI checks enforce code quality through linting (<code>ruff</code>), formatting (<code>black</code>), and static type analysis (<code>mypy</code>) to ensure consistency and catch errors early.</li> <li>Structured Logging and Error Handling: The system emits structured JSON logs for all key events and errors, ensuring consistent, machine-readable output. Error messages are meaningful, provide contextual metadata, and omit sensitive payloads by default. Node exceptions are captured and handled gracefully without crashing the scheduler.</li> <li>Docs-as-Product: Documentation is treated as a first-class product artifact. It includes comprehensive guides, API references, common patterns, troubleshooting steps, and runnable examples. Documentation quality is also verified in CI for correct rendering, valid links, and code snippet execution.</li> <li>Semantic Versioning and API Stability: Public APIs are clearly defined and follow Semantic Versioning, with documented deprecation policies and migration notes to ensure backward compatibility and predictable evolution for users.</li> <li>Performance Principles: Hot paths are designed to be allocation-light, with pre-bound metric label handles and internal integer IDs to optimize performance. Performance budgets and CI regression checks are planned to prevent slowdowns.</li> </ul>"},{"location":"support/faq/#issue-reporting-and-support","title":"Issue Reporting and Support","text":""},{"location":"support/faq/#can-i-share-payload-data-if-it-seems-harmless","title":"Can I share payload data if it seems harmless?","text":"<p>No. Share schemas or field names only. Keep values redacted.</p>"},{"location":"support/faq/#i-cant-create-a-minimal-repro-what-should-i-do","title":"I can't create a minimal repro. What should I do?","text":"<p>Provide the smallest set of sanitized logs, graph configuration details (edge bounds/policies), and environment info you can. Maintainers may suggest a narrowed test based on your description.</p>"},{"location":"support/faq/#what-if-the-issue-is-securitysensitive","title":"What if the issue is security\u2011sensitive?","text":"<p>Use a private reporting channel if available. Do not share details publicly. Briefly describe impact and request a secure handoff.</p>"},{"location":"support/faq/#will-maintainers-sign-ndas","title":"Will maintainers sign NDAs?","text":"<p>The project is designed to avoid the need for sensitive data. We strongly prefer anonymized, redacted artifacts.</p>"},{"location":"support/faq/#roadmap-and-planning","title":"Roadmap and Planning","text":""},{"location":"support/faq/#what-is-the-post-v1-roadmap-for-meridian-runtime","title":"What is the post-v1 roadmap for Meridian Runtime?","text":"<p>The post-v1 roadmap for Meridian Runtime outlines high-value initiatives beyond the initial 1.0.0 release, guided by themes such as composability, predictable performance, operational transparency, developer ergonomics, and incremental feature delivery. It is organized into near-term (v1.x), mid-term (v2.x), and long-term (v3.x+) horizons:</p> <p>Horizon 1: Near-Term (v1.x series) focuses on enhancing developer experience and performance optimizations:</p> <ul> <li>CLI Enhancements: Diagnostics collection with redaction, graph validation, linting, quick profiling, and topology export.</li> <li>Rust Fast Path Extensions: Optional <code>meridian_fast</code> extension for performance-critical components (e.g., bounded ring buffers for edges, scheduler primitives) via PyO3, with graceful fallback to pure Python.</li> <li>CPU Topology Awareness: Optional CPU affinity setting for process pinning on Linux.</li> <li>Deterministic Metrics Overhead Minimization: Ensuring metrics have zero overhead when disabled and batch increments for efficiency.</li> <li>Graph Inspector (TUI): A terminal user interface for runtime introspection.</li> <li>Schema and Validation Ergonomics: Improved optional validators (e.g., Pydantic) and structured error mapping.</li> <li>Scheduler Profiling and Fairness Tuning: Recording scheduling latencies and supporting configurable fairness strategies.</li> <li>Persistence-Friendly Hooks: Extension points for durable inbox/outbox adapters.</li> </ul> <p>Horizon 2: Mid-Term (v2.x series) introduces more advanced capabilities and tools:</p> <ul> <li>Visual Graph Inspector: An optional web or local visualizer for graph topology and metrics.</li> <li>Pluggable Storage for Edges: Allowing edge queues to use various storage backends (memory, mmap, local DB).</li> <li>Extended Backpressure Strategies: Advanced configurations like watermarks and adaptive coalescing.</li> <li>Graph Versioning and Migration Aids: Strategies for upgrading graph definitions.</li> <li>Replay and Time-Travel Debugging: Opt-in local replay from persisted event logs.</li> <li>Policy-Driven Error Handling: Configurable error policies like retry with backoff or circuit breakers.</li> <li>Structured Configuration Layer: Loading configuration from files (TOML/YAML) with strict validation.</li> </ul> <p>Horizon 3: Long-Term (v3.x+) explores distributed execution and advanced system-level features:</p> <ul> <li>Multi-Process/Distributed Execution: Support for partitioned execution across processes or hosts, likely leveraging Rust bridges for shared memory or lock-free queues.</li> <li>Adaptive Scheduling and QoS: Scheduler adapting priorities based on QoS classes and queue depth.</li> <li>Formal Verification Aids: Optional formal models for critical components.</li> <li>Pluggable Security Posture: Policy modules for encryption, signed configurations, and policy-as-code redaction.</li> <li>Remote Control Plane: Secure remote operations (pause/resume nodes, swap subgraphs).</li> </ul> <p>Cross-cutting concerns like observability, privacy/redaction, performance, and API stability will continue to be prioritized throughout all horizons.</p>"},{"location":"support/faq/#how-do-i-propose-changes-to-the-roadmap","title":"How do I propose changes to the roadmap?","text":"<p>For small edits to existing milestones, make a PR that clearly states the change and links to evidence when changing scope or risk.</p> <p>For new milestones: 1. Copy the template from the roadmap into a new <code>Mx-title.md</code> file 2. Open a PR and request review from maintainers</p>"},{"location":"support/faq/#can-milestone-numbers-be-reordered","title":"Can milestone numbers be reordered?","text":"<p>Avoid churn. If order must change, prefer updating dependencies and \"Order of operations\" instead of renaming files. If a rename is necessary, include redirect notes in docs and update references across the repo.</p>"},{"location":"support/faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"support/faq/#my-graph-isnt-processing-messages-what-should-i-check","title":"My graph isn't processing messages. What should I check?","text":"<ol> <li>Verify all nodes are properly connected with valid port types</li> <li>Check that the scheduler is running (<code>scheduler.run()</code>)</li> <li>Ensure nodes are emitting messages to their output ports</li> <li>Look for validation errors in the logs</li> </ol>"},{"location":"support/faq/#how-do-i-debug-backpressure-issues","title":"How do I debug backpressure issues?","text":"<ol> <li>Check edge capacities and policies</li> <li>Monitor queue depth metrics</li> <li>Look for <code>BLOCKED</code> or <code>DROP</code> events in logs</li> <li>Verify consumer nodes are processing messages at expected rates</li> </ol>"},{"location":"support/faq/#why-are-my-messages-being-dropped","title":"Why are my messages being dropped?","text":"<p>This could be due to: - Edge capacity limits with <code>Drop</code> or <code>Latest</code> policies - Type validation failures at edge boundaries - Consumer nodes not processing messages fast enough</p> <p>Check the edge policy configuration and monitor drop counters in metrics.</p>"},{"location":"support/faq/#migration-and-upgrades","title":"Migration and Upgrades","text":""},{"location":"support/faq/#how-do-i-upgrade-between-versions","title":"How do I upgrade between versions?","text":"<ol> <li>Check the <code>CHANGELOG</code> for breaking changes</li> <li>Update your dependency version</li> <li>Run your test suite</li> <li>Review any deprecation warnings</li> <li>Update code if needed based on breaking changes</li> </ol>"},{"location":"support/faq/#whats-the-deprecation-policy","title":"What's the deprecation policy?","text":"<ul> <li>Deprecated APIs are marked with warnings and docstrings</li> <li>Minimum deprecation window: one <code>MINOR</code> release before removal</li> <li>Deprecations are documented in <code>CHANGELOG</code> and API docs</li> </ul>"},{"location":"support/faq/#still-have-questions","title":"Still Have Questions?","text":"<ul> <li>Check the troubleshooting guide for common issues</li> <li>Review the API documentation for detailed usage</li> <li>Search existing issues for similar questions</li> <li>Open a new issue if your question isn't covered here</li> </ul>"},{"location":"support/templates/BUG_REPORT/","title":"Meridian Runtime Bug Report Template (Privacy\u2011First)","text":""},{"location":"support/templates/BUG_REPORT/#owner-ghostweasel-lead-doubletap-dave","title":"Owner: GhostWeasel (Lead: doubletap-dave)","text":""},{"location":"support/templates/BUG_REPORT/#purpose-help-you-file-actionable-bug-reports-while-protecting-sensitive-data","title":"Purpose: Help you file actionable bug reports while protecting sensitive data.","text":""},{"location":"support/templates/BUG_REPORT/#1-summary","title":"1) Summary","text":""},{"location":"support/templates/BUG_REPORT/#2-environment","title":"2) Environment","text":"<ul> <li>OS: (e.g., macOS 14.5 / Ubuntu 22.04 / Windows 11)</li> <li>Python: 3.11.x</li> <li>Meridian Runtime: x.y.z</li> <li>Install/Tooling: (e.g., <code>uv</code> version, <code>ruff</code>/<code>mypy</code>/<code>pytest</code> versions)</li> <li>How installed: (<code>pip</code>/<code>uv</code>/source)</li> </ul>"},{"location":"support/templates/BUG_REPORT/#3-reproduction-steps","title":"3) Reproduction Steps","text":"<p>1) \u2026 2) \u2026 3) \u2026</p>"},{"location":"support/templates/BUG_REPORT/#minimal-repro-sanitized","title":"Minimal Repro (Sanitized)","text":"<ul> <li>Graph summary: number of nodes/edges, relevant edges' bounds and overflow policies (<code>block</code>/<code>drop</code>/<code>latest</code>/<code>coalesce</code>).</li> <li>Relevant node lifecycle hooks: <code>on_start</code> / <code>on_message</code> / <code>on_tick</code> / <code>on_stop</code>.</li> <li>Validation in use (optional): <code>TypedDict</code> / <code>Pydantic</code> (schema names only).</li> </ul> <p>Example (conceptual, no real data): - Edge E_A: <code>bound=10</code>, <code>policy=\"drop\"</code> - Node N_input -&gt; Edge E_A -&gt; Node N_worker</p>"},{"location":"support/templates/BUG_REPORT/#4-observed-behavior","title":"4) Observed Behavior","text":"<ul> <li>Behavior:</li> <li>\u2026</li> <li>Redacted errors/stack traces (if any):</li> <li>\u2026</li> <li>Relevant structured logs (redacted values, keep keys):</li> <li><code>event=\"edge_overflow\", edge_id=\"E_A\", policy=\"drop\", dropped=123</code></li> <li><code>event=\"node_error\", node_id=\"N_worker\", error_type=\"ValueError\", message=\"&lt;REDACTED&gt;\"</code></li> </ul>"},{"location":"support/templates/BUG_REPORT/#5-expected-behavior","title":"5) Expected Behavior","text":"<ul> <li>\u2026</li> </ul>"},{"location":"support/templates/BUG_REPORT/#6-additional-technical-detail-optional-redacted","title":"6) Additional Technical Detail (Optional, Redacted)","text":"<ul> <li>Metrics snapshot (numbers only; avoid PII in labels):</li> <li><code>queue_depth=</code>, <code>overflow_count=</code>, <code>processed_total=</code>, <code>error_total=</code></li> <li>Config highlights (redacted):</li> <li>Relevant keys and enum/boolean values; replace secrets with <code>&lt;REDACTED&gt;</code> or <code>CHECKSUM(...)</code></li> <li>Timing/frequency:</li> <li>Intermittent vs consistent; began after version/change</li> <li>Workarounds tried:</li> <li>\u2026</li> </ul>"},{"location":"support/templates/BUG_REPORT/#7-impact","title":"7) Impact","text":"<ul> <li>(e.g., Blocks release; production impact; affects one workflow; minor inconvenience)</li> </ul>"},{"location":"support/templates/BUG_REPORT/#8-attachments-optional-sanitized","title":"8) Attachments (Optional, Sanitized)","text":"<ul> <li>Attached: yes/no</li> <li>Notes on redaction: \u2026</li> </ul>"},{"location":"support/templates/BUG_REPORT/#9-maintainer-questions-optional","title":"9) Maintainer Questions (Optional)","text":"<ul> <li>\u2026</li> </ul>"},{"location":"support/templates/BUG_REPORT/#10-redaction-guidance-strongly-enforced","title":"10) Redaction Guidance (Strongly Enforced)","text":"<p>MUST remove or replace: - Secrets: API keys, tokens, passwords, private URLs. - PII: names, emails, phone numbers, addresses, IDs. - Payload contents: message/body data, records; share only schemas/field names if necessary. - Hostnames/IPs: replace with <code>HOST_A</code> or <code>203.0.113.10</code>. - Internal IDs: replace with opaque placeholders (<code>ID_123</code> \u2192 <code>ID_A</code>).</p> <p>Best practices: - Prefer schemas over data (example: <code>{user_id: str, balance_cents: int}</code>). - Keep log structure and keys; replace values with <code>&lt;REDACTED&gt;</code> or representative shapes. - For configs, include only relevant keys and non-sensitive values; mask secrets entirely. - If you must differentiate distinct secret/config values without exposing them, use checksums:   - <code>DB_PASSWORD: CHECKSUM(sha256:abcd...)</code></p> <p>What not to share: - Raw payloads or domain data - Credentials or tokens - Proprietary identifiers without anonymization</p>"},{"location":"support/templates/BUG_REPORT/#11-checklist","title":"11) Checklist","text":"<ul> <li> Removed payload contents, secrets, tokens, and PII</li> <li> Included OS/Python/Meridian Runtime versions and install method</li> <li> Added minimal, sanitized reproduction steps</li> <li> Provided redacted logs/errors and metrics snapshots if relevant</li> <li> Described observed vs expected behavior</li> </ul>"},{"location":"support/templates/BUG_REPORT/#references","title":"References","text":"<ul> <li>Troubleshooting: <code>docs/support/TROUBLESHOOTING.md</code></li> <li>How to Report Issues: <code>docs/support/HOW-TO-REPORT-ISSUES.md</code></li> <li>Governance and Overview: <code>docs/roadmap/governance-and-overview.md</code></li> <li>Contributing Guide: <code>docs/contributing/guide.md</code></li> </ul>"},{"location":"support/templates/FEATURE_REQUEST/","title":"Meridian Runtime Feature Request Template (Privacy\u2011First)","text":""},{"location":"support/templates/FEATURE_REQUEST/#owner-ghostweasel-lead-doubletap-dave","title":"Owner: GhostWeasel (Lead: doubletap-dave)","text":""},{"location":"support/templates/FEATURE_REQUEST/#purpose-propose-improvements-that-align-with-meridian-runtimes-goalscomposability-predictability-observability-and-privacy","title":"Purpose: Propose improvements that align with Meridian Runtime's goals\u2014composability, predictability, observability, and privacy.","text":""},{"location":"support/templates/FEATURE_REQUEST/#1-summary","title":"1) Summary","text":""},{"location":"support/templates/FEATURE_REQUEST/#2-motivation-and-use-cases","title":"2) Motivation and Use Cases","text":"<ul> <li>Primary use case(s):</li> <li>Pain points with current behavior:</li> <li>Expected outcome/value:</li> </ul>"},{"location":"support/templates/FEATURE_REQUEST/#3-proposed-behavior-api","title":"3) Proposed Behavior / API","text":"<ul> <li>Runtime/Library API (conceptual):</li> <li>Example types/functions/classes (names and purpose only)</li> <li>CLI (if applicable):</li> <li>Subcommands, flags, and expected outputs</li> <li>Configuration (if applicable):</li> <li>Keys, defaults, and validation rules</li> </ul>"},{"location":"support/templates/FEATURE_REQUEST/#4-scope-and-nongoals","title":"4) Scope and Non\u2011Goals","text":"<ul> <li>In scope:</li> <li>Out of scope:</li> </ul>"},{"location":"support/templates/FEATURE_REQUEST/#5-alternatives-considered","title":"5) Alternatives Considered","text":"<ul> <li>Alternative A:</li> <li>Pros:</li> <li>Cons:</li> <li>Alternative B:</li> <li>Pros:</li> <li>Cons:</li> </ul>"},{"location":"support/templates/FEATURE_REQUEST/#6-impact","title":"6) Impact","text":"<ul> <li>Backward compatibility:</li> <li>Performance considerations:</li> <li>Observability implications (logs/metrics/traces):</li> <li>Privacy posture (no payloads in errors by default; redaction hooks):</li> <li>Operational complexity:</li> </ul>"},{"location":"support/templates/FEATURE_REQUEST/#7-milestone-fit","title":"7) Milestone Fit","text":"<ul> <li>Suggested horizon (v1.x / v2.x / v3.x+):</li> <li>Related roadmap items or Decision Records (if any):</li> </ul>"},{"location":"support/templates/FEATURE_REQUEST/#8-acceptance-criteria-earsstyle","title":"8) Acceptance Criteria (EARS\u2011style)","text":"<ul> <li>Ubiquitous: \"The system shall \u2026\"</li> <li>Event\u2011driven: \"When , the system shall \u2026\" <li>State\u2011driven: \"While , the system shall \u2026\" <li>Unwanted: \"If , the system shall \u2026\" <p>Example: - The system shall provide a CLI subcommand <code>meridian-runtime diagnostics collect</code> that creates a redacted bundle by default. - When a user runs the command, the CLI shall omit secrets and payload contents and include environment summaries. - While running under minimal permissions, the CLI shall degrade gracefully and indicate missing non\u2011essential data. - If redaction fails for any field, the system shall default to omission rather than inclusion.</p>"},{"location":"support/templates/FEATURE_REQUEST/#9-example-conceptual-sanitized","title":"9) Example (Conceptual, Sanitized)","text":"<ul> <li>User flow:   1) \u2026   2) \u2026   3) \u2026</li> <li>Expected structured logs (redacted values; stable keys):</li> <li><code>event=\"feature_event\", component=\"...\", status=\"success\"</code></li> </ul>"},{"location":"support/templates/FEATURE_REQUEST/#10-risks-and-mitigations","title":"10) Risks and Mitigations","text":"<ul> <li>Risk:</li> <li>Mitigation:</li> <li>Risk:</li> <li>Mitigation:</li> </ul>"},{"location":"support/templates/FEATURE_REQUEST/#11-testing-and-documentation-plan","title":"11) Testing and Documentation Plan","text":"<ul> <li>Tests:</li> <li>Unit:</li> <li>Integration:</li> <li>Regression/compatibility:</li> <li>Documentation:</li> <li>README changes:</li> <li><code>docs/plan</code> or Decision Record:</li> <li>Examples/recipes:</li> </ul>"},{"location":"support/templates/FEATURE_REQUEST/#12-dependencies-and-compatibility","title":"12) Dependencies and Compatibility","text":"<ul> <li>New dependencies (runtime vs dev):</li> <li>Compatibility with Python 3.11+:</li> <li>Adapter requirements (optional/plug\u2011in):</li> </ul>"},{"location":"support/templates/FEATURE_REQUEST/#13-open-questions","title":"13) Open Questions","text":"<ul> <li>Q1:</li> <li>Q2:</li> </ul>"},{"location":"support/templates/FEATURE_REQUEST/#14-checklist-submitter","title":"14) Checklist (Submitter)","text":"<ul> <li> No payload contents, PII, secrets, or tokens included</li> <li> Clear problem statement and target users</li> <li> Proposed behavior and non\u2011goals documented</li> <li> EARS\u2011style acceptance criteria provided</li> <li> Privacy and observability implications considered</li> <li> Testing and docs plan sketched</li> </ul>"},{"location":"support/templates/FEATURE_REQUEST/#references","title":"References","text":"<ul> <li>Governance and Overview: <code>docs/roadmap/governance-and-overview.md</code></li> <li>Future Roadmap: <code>docs/roadmap/future-roadmap.md</code></li> <li>Contributing Guide: <code>docs/contributing/guide.md</code></li> <li>Troubleshooting: <code>docs/support/TROUBLESHOOTING.md</code></li> <li>How to Report Issues: <code>docs/support/HOW-TO-REPORT-ISSUES.md</code></li> </ul>"},{"location":"support/templates/ISSUE_TEMPLATE/","title":"Meridian Runtime Issue Template (Generic)","text":""},{"location":"support/templates/ISSUE_TEMPLATE/#owner-ghostweasel-lead-doubletap-dave","title":"Owner: GhostWeasel (Lead: doubletap-dave)","text":""},{"location":"support/templates/ISSUE_TEMPLATE/#audience-users-and-contributors","title":"Audience: Users and contributors","text":""},{"location":"support/templates/ISSUE_TEMPLATE/#purpose-provide-a-concise-privacyfirst-structure-for-reporting-any-issue-bug-question-usability-concern-docs-gap-etc","title":"Purpose: Provide a concise, privacy\u2011first structure for reporting any issue (bug, question, usability concern, docs gap, etc.)","text":""},{"location":"support/templates/ISSUE_TEMPLATE/#1-issue-type","title":"1) Issue Type","text":"<ul> <li> Bug</li> <li> Question</li> <li> Feature request</li> <li> Documentation</li> <li> Performance</li> <li> Usability / DX</li> <li> Other (describe below)</li> </ul>"},{"location":"support/templates/ISSUE_TEMPLATE/#2-summary","title":"2) Summary","text":""},{"location":"support/templates/ISSUE_TEMPLATE/#3-environment","title":"3) Environment","text":"<ul> <li>OS: (e.g., macOS 14.5 / Ubuntu 22.04 / Windows 11)</li> <li>Python: 3.11.x</li> <li>Meridian Runtime version: x.y.z</li> <li>Tooling (if relevant): <code>uv</code> version, <code>ruff</code>/<code>mypy</code>/<code>pytest</code> versions</li> <li>Installation method: (e.g., <code>pip</code>/<code>uv</code>/local build)</li> </ul>"},{"location":"support/templates/ISSUE_TEMPLATE/#4-reproduction-context","title":"4) Reproduction / Context","text":"<ul> <li>Steps to reproduce:   1.   2.   3.</li> <li>Minimal repro snippet (sanitized; schemas or field names only, no real data):</li> <li>Node/edge definitions, bounds, overflow policy (<code>block</code>/<code>drop</code>/<code>latest</code>/<code>coalesce</code>)</li> <li>Any relevant lifecycle hooks (<code>on_start</code>/<code>on_message</code>/<code>on_tick</code>/<code>on_stop</code>)</li> </ul>"},{"location":"support/templates/ISSUE_TEMPLATE/#5-observed-vs-expected","title":"5) Observed vs Expected","text":"<ul> <li>Observed:</li> <li>What happened, including any redacted stack traces or error summaries.</li> <li>Example structured logs (redact values; keep keys):<ul> <li><code>event=\"edge_overflow\", edge_id=\"EDGE_A\", policy=\"drop\", dropped=123</code></li> <li><code>event=\"node_error\", node_id=\"NODE_X\", error_type=\"ValueError\", message=\"&lt;REDACTED&gt;\"</code></li> </ul> </li> <li>Expected:</li> <li>What you expected to happen instead.</li> </ul>"},{"location":"support/templates/ISSUE_TEMPLATE/#6-additional-details-optional","title":"6) Additional Details (Optional)","text":"<ul> <li>Metrics snapshot (counters/gauges; avoid PII in labels):</li> <li><code>queue_depth_example=</code>, <code>overflow_count_example=</code></li> <li>Config highlights (redacted):</li> <li>Relevant keys and enum/boolean values only. Replace secrets with <code>&lt;REDACTED&gt;</code> or <code>CHECKSUM(...)</code>.</li> <li>Frequency/timing:</li> <li>Intermittent/consistent; started after <code>&lt;version/change&gt;</code>.</li> <li>Workarounds tried:</li> <li>What you attempted and results.</li> </ul>"},{"location":"support/templates/ISSUE_TEMPLATE/#7-impact","title":"7) Impact","text":""},{"location":"support/templates/ISSUE_TEMPLATE/#8-attachments-optional","title":"8) Attachments (Optional)","text":""},{"location":"support/templates/ISSUE_TEMPLATE/#9-proposed-next-steps-optional","title":"9) Proposed Next Steps (Optional)","text":""},{"location":"support/templates/ISSUE_TEMPLATE/#checklist","title":"Checklist","text":"<ul> <li> I removed payload contents, secrets, tokens, PII, and proprietary identifiers.</li> <li> I provided a minimal reproduction or the smallest set of redacted artifacts possible.</li> <li> I included OS/Python/Meridian Runtime versions and relevant tooling info.</li> <li> I clearly described observed vs expected behavior.</li> </ul>"},{"location":"support/templates/ISSUE_TEMPLATE/#references","title":"References","text":"<ul> <li>Troubleshooting: <code>docs/support/TROUBLESHOOTING.md</code></li> <li>How to Report Issues: <code>docs/support/HOW-TO-REPORT-ISSUES.md</code></li> <li>Governance and Overview: <code>docs/roadmap/governance-and-overview.md</code></li> <li>Contributing Guide: <code>docs/contributing/guide.md</code></li> </ul>"}]}